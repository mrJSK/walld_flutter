================================================================================
PROJECT FILE STRUCTURE
================================================================================

Root: lib (lib)
â”œâ”€â”€ chat/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ chat_channel.dart
â”‚   â”‚   â”œâ”€â”€ chat_conversation.dart
â”‚   â”‚   â””â”€â”€ chat_message.dart
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ chat_repository.dart
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ chat_attachment_service.dart
â”‚   â”‚   â””â”€â”€ chat_storage_uploader.dart
â”‚   â””â”€â”€ widgets/
â”‚       â”œâ”€â”€ chat_input_bar.dart
â”‚       â”œâ”€â”€ chat_shell.dart
â”‚       â”œâ”€â”€ message_bubble.dart
â”‚       â””â”€â”€ message_list.dart
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ app_colors.dart
â”‚   â”œâ”€â”€ glass_container.dart
â”‚   â”œâ”€â”€ performance_state.dart
â”‚   â”œâ”€â”€ permissions_cache.dart
â”‚   â””â”€â”€ wallpaper_service.dart
â”œâ”€â”€ Developer/
â”‚   â”œâ”€â”€ DynamicForms/
â”‚   â”‚   â”œâ”€â”€ dynamic_forms_panel.dart
â”‚   â”‚   â”œâ”€â”€ dynamic_forms_repository.dart
â”‚   â”‚   â””â”€â”€ form_models.dart
â”‚   â”œâ”€â”€ Hierarchy/
â”‚   â”‚   â”œâ”€â”€ hierarchy_panel.dart
â”‚   â”‚   â”œâ”€â”€ hierarchy_repository.dart
â”‚   â”‚   â””â”€â”€ org_node_model.dart
â”‚   â”œâ”€â”€ Metadata/
â”‚   â”‚   â”œâ”€â”€ designation/
â”‚   â”‚   â”‚   â”œâ”€â”€ designation_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ designation_tab.dart
â”‚   â”‚   â”œâ”€â”€ form_schema/
â”‚   â”‚   â”‚   â”œâ”€â”€ form_schema_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ form_schema_tab.dart
â”‚   â”‚   â”œâ”€â”€ role_permission/
â”‚   â”‚   â”‚   â”œâ”€â”€ role_permission_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ role_permission_tab.dart
â”‚   â”‚   â”œâ”€â”€ metadata_panel.dart
â”‚   â”‚   â””â”€â”€ metadata_repository.dart
â”‚   â”œâ”€â”€ UserDatabase/
â”‚   â”‚   â”œâ”€â”€ userdatabasemodel.dart
â”‚   â”‚   â”œâ”€â”€ userdatabasepanel.dart
â”‚   â”‚   â””â”€â”€ userdatabaserepository.dart
â”‚   â””â”€â”€ developer_dashboard_screen.dart
â”œâ”€â”€ dynamic_screen/
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ floating_widget.dart
â”‚   â”‚   â”œâ”€â”€ grid_layout.dart
â”‚   â”‚   â”œâ”€â”€ screen_grid.dart
â”‚   â”‚   â”œâ”€â”€ task_form_models.dart
â”‚   â”‚   â””â”€â”€ widget.dart
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â””â”€â”€ dashboard_repository.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”œâ”€â”€ complete_task_widget.dart
â”‚   â”‚   â”œâ”€â”€ create_task_widget.dart
â”‚   â”‚   â”œâ”€â”€ login_widget.dart
â”‚   â”‚   â”œâ”€â”€ view_all_tasks_widget.dart
â”‚   â”‚   â”œâ”€â”€ view_assigned_tasks_widget.dart
â”‚   â”‚   â””â”€â”€ widgets.dart
â”‚   â”œâ”€â”€ dashboard_drawer.dart
â”‚   â”œâ”€â”€ dashboard_grid.dart
â”‚   â”œâ”€â”€ dashboard_layout_persistence.dart
â”‚   â”œâ”€â”€ dashboard_permissions.dart
â”‚   â”œâ”€â”€ dashboard_screen.dart
â”‚   â”œâ”€â”€ dashboardpanel.dart
â”‚   â”œâ”€â”€ widget_factory.dart
â”‚   â”œâ”€â”€ widget_manifest.dart
â”‚   â””â”€â”€ widgets.dart
â”œâ”€â”€ task/
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ create_task_page/
â”‚   â”‚   â”‚   â”œâ”€â”€ mixins/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user_data_loader_mixin.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ assignment_data.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assignment_type_selector.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dynamic_date_field.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ task_form_renderer.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ team_member_selector.dart
â”‚   â”‚   â”‚   â””â”€â”€ create_task_page.dart
â”‚   â”‚   â”œâ”€â”€ view_all_tasks_page/
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ created_task_view_model.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ created_task_card.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ created_task_list.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ created_task_workspace.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ manager_task_details_panel.dart
â”‚   â”‚   â”‚   â””â”€â”€ view_all_tasks_page.dart
â”‚   â”‚   â”œâ”€â”€ view_assigned_tasks_page/
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ assigned_task_view_model.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_card.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_list.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_workspace.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ lead_badge.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ task_details_panel.dart
â”‚   â”‚   â”‚   â””â”€â”€ view_assigned_tasks_page.dart
â”‚   â”‚   â””â”€â”€ complete_task_page.dart
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ user_helper.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ task_side_panel.dart
â”‚   â”œâ”€â”€ task_tabs_manifest.dart
â”‚   â””â”€â”€ task_workspace.dart
â”œâ”€â”€ workspace/
â”‚   â”œâ”€â”€ mixins/
â”‚   â”‚   â””â”€â”€ shell_performance_mixin.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ fps_counter.dart
â”‚   â”œâ”€â”€ loading_screen.dart
â”‚   â”œâ”€â”€ universal_top_bar.dart
â”‚   â”œâ”€â”€ workspace_controller.dart
â”‚   â”œâ”€â”€ workspace_ids.dart
â”‚   â”œâ”€â”€ workspace_shell.dart
â”‚   â””â”€â”€ workspace_switcher.dart
â”œâ”€â”€ firebase_options.dart
â””â”€â”€ main.dart


================================================================================

// File: lib\firebase_options.dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyCtuGo0WIcuVltvmttchCt-StQDPvXtV80',
    appId: '1:272745497278:web:5e70e948a3b71cda7794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    authDomain: 'wall-d-fcc76.firebaseapp.com',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAW4qdIw0JxmgZJzo9lWLKP62N4i-_9Eqc',
    appId: '1:272745497278:android:538512854c58fbab7794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCoSa3laqnShMxxORF_hQq7GvYO0gb3caI',
    appId: '1:272745497278:ios:635ef9197be82e587794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
    iosClientId: '272745497278-i1l9q3r1mi6e0vc1ggtgshlqn7mjcjlj.apps.googleusercontent.com',
    iosBundleId: 'com.example.walldFlutter',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCoSa3laqnShMxxORF_hQq7GvYO0gb3caI',
    appId: '1:272745497278:ios:635ef9197be82e587794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
    iosClientId: '272745497278-i1l9q3r1mi6e0vc1ggtgshlqn7mjcjlj.apps.googleusercontent.com',
    iosBundleId: 'com.example.walldFlutter',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyCtuGo0WIcuVltvmttchCt-StQDPvXtV80',
    appId: '1:272745497278:web:a251ae5cafedf1077794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    authDomain: 'wall-d-fcc76.firebaseapp.com',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );
}

================================================================================

// File: lib\main.dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:walld_flutter/Developer/developer_dashboard_screen.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';
import 'package:walld_flutter/firebase_options.dart';
import 'package:walld_flutter/workspace/loading_screen.dart';
import 'package:walld_flutter/workspace/workspace_controller.dart';
import 'package:walld_flutter/workspace/workspace_shell.dart';
import 'package:window_manager/window_manager.dart';
import 'dart:io' show Platform;


Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // STEP 1: Defer first frame until heavy init is done
  final binding = WidgetsBinding.instance;
  binding.deferFirstFrame();

  try {
    // Initialize Firebase
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );

    // STEP 2: Pre-load wallpaper service
    await WallpaperService.instance.loadSettings();
    debugPrint('âœ… WallpaperService loaded before first frame');

    // STEP 3: Setup desktop window properties
    if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
      await _setupDesktopWindow();
    }
  } catch (e) {
    debugPrint('âŒ Error during pre-initialization: $e');
  }

  // STEP 4: Allow first frame and run app
  binding.allowFirstFrame();
  runApp(const WallDApp());
}

/// Setup desktop window properties (Windows/macOS/Linux)
Future<void> _setupDesktopWindow() async {
  try {
    await windowManager.ensureInitialized();

    const windowOptions = WindowOptions(
      backgroundColor: Colors.black,
      titleBarStyle: TitleBarStyle.hidden,
      skipTaskbar: false,
    );

    await windowManager.waitUntilReadyToShow(windowOptions, () async {
      await windowManager.show();
      await windowManager.setFullScreen(false);
      await windowManager.maximize();

      // Removed: setMovable (not supported)
      await windowManager.setResizable(false);
      await windowManager.setMinimizable(false);
      await windowManager.setClosable(false);

      try {
        await windowManager.setAlwaysOnBottom(true);
      } catch (e) {
        debugPrint('âš ï¸ Could not set window to bottom: $e');
      }
    });

    debugPrint('âœ… Desktop window configured');
  } catch (e) {
    debugPrint('âŒ Desktop window setup failed: $e');
  }
}

class WallDApp extends StatefulWidget {
  const WallDApp({super.key});

  @override
  State<WallDApp> createState() => WallDAppState();
}

class WallDAppState extends State<WallDApp> {
  final WorkspaceController workspaceController = WorkspaceController();
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    debugPrint('WallDApp - initState');
  }

  @override
  void dispose() {
    debugPrint('WallDApp - dispose');
    workspaceController.dispose();
    super.dispose();
  }

  void onLoadingComplete() {
    debugPrint('WallDApp - onLoadingComplete called');
    debugPrint('Loading complete - transitioning to workspace');
    if (mounted) {
      setState(() {
        isLoading = false;
      });
      debugPrint('WallDApp - isLoading set to false - showing WorkspaceShell');
    } else {
      debugPrint('WallDApp - Widget not mounted, skipping setState');
    }
  }

  @override
  Widget build(BuildContext context) {
    debugPrint('WallDApp - build - isLoading:$isLoading');
    return MaterialApp(
      title: 'Wall-D',
      debugShowCheckedModeBanner: false,
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: const Color(0xFF05040A),
      ),
      home: isLoading 
        ? LoadingScreen(onLoadingComplete: onLoadingComplete)
        : WorkspaceShell(workspaceController: workspaceController),
      //home: const DeveloperDashboardScreen(),
    );
  }
}



================================================================================

// File: lib\chat\models\chat_channel.dart
/// Defines the type of chat channel
enum ChatChannel {
  /// Chat among all assigned team members (peer-to-peer)
  teamMembers,

  /// Chat between lead/member and manager (escalation)
  managerCommunication,
}

extension ChatChannelExt on ChatChannel {
  String get firestoreCollection {
    switch (this) {
      case ChatChannel.teamMembers:
        return 'team_members_chat';
      case ChatChannel.managerCommunication:
        return 'manager_communication_chat';
    }
  }

  String get displayName {
    switch (this) {
      case ChatChannel.teamMembers:
        return 'Team Collaboration';
      case ChatChannel.managerCommunication:
        return 'Manager Communication';
    }
  }
}

================================================================================

// File: lib\chat\models\chat_conversation.dart
import 'package:flutter/foundation.dart';

/// Metadata about a conversation (task context)
class ChatConversation {
  final String conversationId; // typically the task docId
  final String taskTitle;
  final String assignedByUid;
  final List<String> assignedToUids;
  final String? leadMemberUid;
  final String? groupName;
  final DateTime? dueDate;

  ChatConversation({
    required this.conversationId,
    required this.taskTitle,
    required this.assignedByUid,
    required this.assignedToUids,
    this.leadMemberUid,
    this.groupName,
    this.dueDate,
  });

  /// Helper: check if a user can send to assignedBy channel (Manager Communication)
  /// Only lead member OR manager can send
  bool canSendToAssignedByChannel(String currentUserUid) {
    final result = currentUserUid == leadMemberUid || currentUserUid == assignedByUid;
    debugPrint('  canSendToAssignedByChannel: $result (current=$currentUserUid, lead=$leadMemberUid, manager=$assignedByUid)');
    return result;
  }

  /// Helper: check if a user can send to team members channel (Team Collaboration)
  /// Any assigned team member OR lead member can send
  bool canSendToTeamChannel(String currentUserUid) {
    // Lead member can always send to team channel
    if (currentUserUid == leadMemberUid) {
      debugPrint('  âœ… User is lead member');
      return true;
    }
    
    // Any assigned team member can send
    final isAssigned = assignedToUids.contains(currentUserUid);
    debugPrint('  ${isAssigned ? "âœ…" : "âŒ"} User in assignedToUids: $isAssigned');
    return isAssigned;
  }
}

================================================================================

// File: lib\chat\models\chat_message.dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum MessageType { text, file, progress }

class ChatAttachment {
  final String url;
  final String name;
  final String mimeType;
  final int sizeBytes;
  final bool compressed;

  ChatAttachment({
    required this.url,
    required this.name,
    required this.mimeType,
    required this.sizeBytes,
    required this.compressed,
  });

  factory ChatAttachment.fromMap(Map<String, dynamic> map) {
    return ChatAttachment(
      url: map['url'] as String? ?? '',
      name: map['name'] as String? ?? '',
      mimeType: map['type'] as String? ?? '',
      sizeBytes: (map['size'] as num?)?.toInt() ?? 0,
      compressed: map['compressed'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'url': url,
      'name': name,
      'type': mimeType,
      'size': sizeBytes,
      'compressed': compressed,
    };
  }
}

class ChatMessage {
  final String id;
  final String senderId;
  final String senderRole;
  final MessageType type;
  final String? text;

  // legacy single file fields â€“ keep for backward compatibility
  final String? fileUrl;
  final String? fileType;

  final List<ChatAttachment> attachments;

  final DateTime createdAt;
  final String? sendTo;
  String? senderName;

  ChatMessage({
    required this.id,
    required this.senderId,
    required this.senderRole,
    required this.type,
    this.text,
    this.fileUrl,
    this.fileType,
    required this.createdAt,
    this.sendTo,
    this.senderName,
    this.attachments = const [],
  });

  factory ChatMessage.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> doc,
  ) {
    final data = doc.data() ?? {};

    final typeStr = (data['type'] ?? 'text') as String;
    final type = MessageType.values.firstWhere(
      (t) => t.name == typeStr,
      orElse: () => MessageType.text,
    );

    final timestamp = data['createdat'];
    DateTime createdAt;
    if (timestamp is Timestamp) {
      createdAt = timestamp.toDate();
    } else if (timestamp is String) {
      createdAt = DateTime.tryParse(timestamp) ?? DateTime.now();
    } else {
      createdAt = DateTime.now();
    }

    final rawList = (data['ATTCHED_FILES'] as List?) ?? const [];
    final attachments = rawList
        .whereType<Map<String, dynamic>>()
        .map(ChatAttachment.fromMap)
        .toList();

    return ChatMessage(
      id: doc.id,
      senderId: data['senderid'] as String? ?? '',
      senderRole: data['senderrole'] as String? ?? 'member',
      type: type,
      text: data['text'] as String?,
      fileUrl: data['fileurl'] as String?,
      fileType: data['filetype'] as String?,
      createdAt: createdAt,
      sendTo: data['sendto'] as String?,
      senderName: null,
      attachments: attachments,
    );
  }

  Map<String, dynamic> toFirestore() {
    final map = <String, dynamic>{
      'senderid': senderId,
      'senderrole': senderRole,
      'type': type.name,
      'createdat': Timestamp.fromDate(createdAt),
    };

    if (text != null) map['text'] = text;
    if (fileUrl != null) map['fileurl'] = fileUrl;
    if (fileType != null) map['filetype'] = fileType;

    if (attachments.isNotEmpty) {
      map['ATTCHED_FILES'] = attachments.map((a) => a.toMap()).toList();
    }

    if (sendTo != null) map['sendto'] = sendTo;

    return map;
  }
}

================================================================================

// File: lib\chat\repositories\chat_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import '../models/chat_channel.dart';
import '../models/chat_message.dart';

class ChatRepository {
  final String tenantId;
  final FirebaseFirestore db;

  ChatRepository({
    required this.tenantId,
    FirebaseFirestore? firestore,
  }) : db = firestore ?? FirebaseFirestore.instance;

  CollectionReference<Map<String, dynamic>> _channelCollection(
    String conversationId,
    ChatChannel channel,
  ) {
    return db
        .collection('tenants')
        .doc(tenantId)
        .collection('CHATS')
        .doc(conversationId)
        .collection(channel.firestoreCollection);
  }

  Stream<List<ChatMessage>> streamMessages({
    required String conversationId,
    required ChatChannel channel,
  }) {
    return _channelCollection(conversationId, channel)
        .orderBy('createdat', descending: false)
        .snapshots()
        .map((snap) => snap.docs.map(ChatMessage.fromFirestore).toList());
  }

  Future<void> sendTextMessage({
    required String conversationId,
    required ChatChannel channel,
    required String senderId,
    required String senderRole,
    required String text,
    String? sendTo,
    MessageType type = MessageType.text,
  }) async {
    try {
      final message = ChatMessage(
        id: '',
        senderId: senderId,
        senderRole: senderRole,
        type: type,
        text: text,
        createdAt: DateTime.now(),
        sendTo: sendTo,
      );

      debugPrint('ğŸ’¬ Sending text message to Firestore...');
      debugPrint('Path: tenants/$tenantId/CHATS/$conversationId/${channel.firestoreCollection}');

      await _channelCollection(conversationId, channel)
          .add(message.toFirestore());

      debugPrint('âœ… Text message saved to Firestore');
    } catch (e, stackTrace) {
      debugPrint('âŒ Firestore error (text): $e');
      debugPrint('Stack trace: $stackTrace');
      rethrow;
    }
  }

  Future<void> sendFileMessage({
    required String conversationId,
    required ChatChannel channel,
    required String senderId,
    required String senderRole,
    required List<ChatAttachment> attachments,
    String? text,
    String? sendTo,
    MessageType type = MessageType.file,
  }) async {
    try {
      final message = ChatMessage(
        id: '',
        senderId: senderId,
        senderRole: senderRole,
        type: type,
        text: text,
        createdAt: DateTime.now(),
        sendTo: sendTo,
        attachments: attachments,
      );

      debugPrint('ğŸ“ Sending file message to Firestore...');
      debugPrint('Attachments: ${attachments.length}');
      debugPrint('Path: tenants/$tenantId/CHATS/$conversationId/${channel.firestoreCollection}');

      final data = message.toFirestore();
      debugPrint('Message data: $data');

      await _channelCollection(conversationId, channel).add(data);

      debugPrint('âœ… File message saved to Firestore');
    } catch (e, stackTrace) {
      debugPrint('âŒ Firestore error (file): $e');
      debugPrint('Stack trace: $stackTrace');
      rethrow;
    }
  }
}

================================================================================

// File: lib\chat\services\chat_attachment_service.dart
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/chat_message.dart';

class ChatAttachmentService {
  static const _prefsKey = 'chat_downloads_v1';

  static Future<File> downloadToLocal({
    required String tenantId,
    required String conversationId,
    required String messageId,
    required int attachmentIndex,
    required ChatAttachment attachment,
    void Function(double progress)? onProgress,
  }) async {
    final uri = Uri.parse(attachment.url);
    final response = await http.Client().send(http.Request('GET', uri));

    final baseDir = await getApplicationSupportDirectory();
    final dir = Directory(
      p.join(
        baseDir.path,
        'attachments',
        tenantId,
        conversationId,
        messageId,
      ),
    );
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }

    final filePath = p.join(dir.path, attachment.name);
    final file = File(filePath);
    final sink = file.openWrite();

    final contentLength = response.contentLength ?? 0;
    int received = 0;

    await for (final chunk in response.stream) {
      received += chunk.length;
      sink.add(chunk);
      if (contentLength > 0 && onProgress != null) {
        onProgress(received / contentLength);
      }
    }

    await sink.close();

    await _persistDownload(
      tenantId: tenantId,
      conversationId: conversationId,
      messageId: messageId,
      attachmentIndex: attachmentIndex,
      localPath: file.path,
      remoteUrl: attachment.url,
      mimeType: attachment.mimeType,
      fileName: attachment.name,
      sizeBytes: await file.length(),
    );

    return file;
  }

  static Future<Map<String, dynamic>> _loadMap() async {
    final prefs = await SharedPreferences.getInstance();
    final raw = prefs.getString(_prefsKey);
    if (raw == null || raw.isEmpty) return {'downloads': []};
    try {
      return jsonDecode(raw) as Map<String, dynamic>;
    } catch (_) {
      return {'downloads': []};
    }
  }

  static Future<void> _saveMap(Map<String, dynamic> map) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_prefsKey, jsonEncode(map));
  }

  static Future<void> _persistDownload({
    required String tenantId,
    required String conversationId,
    required String messageId,
    required int attachmentIndex,
    required String localPath,
    required String remoteUrl,
    required String mimeType,
    required String fileName,
    required int sizeBytes,
  }) async {
    final map = await _loadMap();
    final list = (map['downloads'] as List?) ?? [];

    list.removeWhere((e) =>
        e['tenantId'] == tenantId &&
        e['conversationId'] == conversationId &&
        e['messageId'] == messageId &&
        e['attachmentIndex'] == attachmentIndex);

    list.add({
      'tenantId': tenantId,
      'conversationId': conversationId,
      'messageId': messageId,
      'attachmentIndex': attachmentIndex,
      'remoteUrl': remoteUrl,
      'fileName': fileName,
      'mimeType': mimeType,
      'localPath': localPath,
      'sizeBytes': sizeBytes,
      'downloadedAt': DateTime.now().toUtc().toIso8601String(),
    });

    map['downloads'] = list;
    await _saveMap(map);
  }

  static Future<String?> resolveLocalPath({
    required String tenantId,
    required String conversationId,
    required String messageId,
    required int attachmentIndex,
  }) async {
    final map = await _loadMap();
    final list = (map['downloads'] as List?) ?? [];
    final match = list.cast<Map<String, dynamic>?>().firstWhere(
          (e) =>
              e != null &&
              e['tenantId'] == tenantId &&
              e['conversationId'] == conversationId &&
              e['messageId'] == messageId &&
              e['attachmentIndex'] == attachmentIndex,
          orElse: () => null,
        );
    if (match == null) return null;
    final path = match['localPath'] as String?;
    if (path == null) return null;
    final file = File(path);
    if (!await file.exists()) return null;
    return path;
  }
}

================================================================================

// File: lib\chat\services\chat_storage_uploader.dart
import 'dart:io';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as p;
import '../models/chat_message.dart';

class ChatStorageUploader {
  static final FirebaseStorage _storage = FirebaseStorage.instance;

  /// Ensure user is authenticated before upload
  static Future<void> _ensureAuth() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      debugPrint('ğŸ” Signing in anonymously...');
      await FirebaseAuth.instance.signInAnonymously();
      debugPrint('âœ… Authenticated: ${FirebaseAuth.instance.currentUser?.uid}');
    }
  }

  static Future<ChatAttachment> uploadSingle({
    required String tenantId,
    required String conversationId,
    required String messageTempId,
    required ChatAttachment localAttachment,
  }) async {
    await _ensureAuth(); // âœ… Force auth

    try {
      final localPath = localAttachment.url;
      debugPrint('ğŸ“ Uploading: $localPath');

      final file = File(localPath);
      if (!await file.exists()) {
        throw Exception('âŒ File missing: $localPath');
      }

      final fileName = localAttachment.name;
      final ext = p.extension(fileName);
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final cleanName = fileName.replaceAll(RegExp(r'[<>:"/\\|?*]'), '_'); // Sanitize
      final storagePath = 'tenants/$tenantId/chats/$conversationId/$messageTempId/$cleanName';

      debugPrint('â˜ï¸ Path: $storagePath');

      final ref = _storage.ref().child(storagePath);
      
      // âœ… Delete if exists (race condition fix)
      try {
        await ref.delete();
        debugPrint('ğŸ—‘ï¸ Cleared existing file');
      } catch (e) {
        debugPrint('â„¹ï¸ No existing file to delete');
      }

      final uploadTask = ref.putFile(
        file,
        SettableMetadata(contentType: localAttachment.mimeType),
      );

      // âœ… Simple await - NO listeners (fixes threading)
      final snapshot = await uploadTask;
      debugPrint('ğŸ“ˆ Upload state: ${snapshot.state}');

      if (snapshot.state != TaskState.success) {
        throw Exception('âŒ Upload failed: ${snapshot.state}');
      }

      // âœ… Wait + verify file exists before getting URL
      await Future.delayed(const Duration(seconds: 1));
      
      // âœ… List files to verify upload
      final listResult = await ref.parent!.listAll();
      debugPrint('ğŸ“‚ Files in parent: ${listResult.items.length}');
      
      if (!listResult.items.any((item) => item.fullPath == storagePath)) {
        throw Exception('âŒ File not found in storage after upload');
      }

      // âœ… Get download URL with retry
      String? downloadUrl;
      for (int i = 0; i < 5; i++) {
        try {
          downloadUrl = await ref.getDownloadURL();
          debugPrint('âœ… URL got: ${downloadUrl.substring(0, 50)}...');
          break;
        } catch (e) {
          debugPrint('âš ï¸ URL attempt ${i + 1}/5 failed: $e');
          await Future.delayed(Duration(milliseconds: 800 * (i + 1)));
        }
      }

      if (downloadUrl == null) {
        throw Exception('âŒ Failed to get download URL after 5 attempts');
      }

      return ChatAttachment(
        url: downloadUrl,
        name: cleanName,
        mimeType: localAttachment.mimeType,
        sizeBytes: await file.length(),
        compressed: localAttachment.compressed,
      );
    } catch (e, st) {
      debugPrint('ğŸ’¥ FULL ERROR: $e');
      debugPrint('Stack: $st');
      rethrow;
    }
  }

  static Future<List<ChatAttachment>> uploadAll({
    required String tenantId,
    required String conversationId,
    required List<ChatAttachment> localAttachments,
  }) async {
    final tempMessageId = DateTime.now().millisecondsSinceEpoch.toString();
    final uploaded = <ChatAttachment>[];

    for (int i = 0; i < localAttachments.length; i++) {
      try {
        final up = await uploadSingle(
          tenantId: tenantId,
          conversationId: conversationId,
          messageTempId: tempMessageId,
          localAttachment: localAttachments[i],
        );
        uploaded.add(up);
      } catch (e) {
        debugPrint('âŒ Upload ${i + 1} failed: $e');
        rethrow; // Stop on first failure
      }
    }

    return uploaded;
  }
}

================================================================================

// File: lib\chat\widgets\chat_input_bar.dart
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:mime/mime.dart';
import '../models/chat_message.dart';

typedef SendTextCallback = Future<void> Function(String text);
typedef SendAttachmentsCallback = Future<void> Function({
  required List<ChatAttachment> attachments,
  String? text,
});

class ChatInputBar extends StatefulWidget {
  final SendTextCallback onSendText;
  final SendAttachmentsCallback onSendAttachments;
  final bool enabled;
  final String hintText;

  const ChatInputBar({
    super.key,
    required this.onSendText,
    required this.onSendAttachments,
    this.enabled = true,
    this.hintText = 'Type a message',
  });

  @override
  State<ChatInputBar> createState() => _ChatInputBarState();
}

class _ChatInputBarState extends State<ChatInputBar> {
  final TextEditingController _controller = TextEditingController();
  bool _sending = false;
  List<ChatAttachment> _selectedFiles = [];
  static const int _maxBytesPerMessage = 10 * 1024 * 1024; // 10 MB

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// âœ… FIXED: Main send handler
  Future<void> _handleSend() async {
    if (!widget.enabled || _sending) return;

    // If files are selected, send them (with or without message)
    if (_selectedFiles.isNotEmpty) {
      await _sendFilesWithMessage();
      return;
    }

    // Otherwise, send text only if not empty
    final text = _controller.text.trim();
    if (text.isNotEmpty) {
      await _sendTextOnly(text);
    }
  }

  Future<void> _sendTextOnly(String text) async {
    setState(() => _sending = true);

    try {
      await widget.onSendText(text);
      _controller.clear();
    } catch (e) {
      debugPrint('âŒ Error sending text: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send: $e'),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _sending = false);
    }
  }

  Future<void> _sendFilesWithMessage() async {
    setState(() => _sending = true);

    try {
      debugPrint('ğŸ“¤ Sending ${_selectedFiles.length} file(s)...');
      
      final text = _controller.text.trim();
      await widget.onSendAttachments(
        attachments: _selectedFiles,
        text: text.isEmpty ? null : text,
      );

      // Clear after successful send
      _controller.clear();
      setState(() => _selectedFiles.clear());
      
      debugPrint('âœ… Files sent successfully');
    } catch (e) {
      debugPrint('âŒ Error sending files: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send files: $e'),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
    } finally {
      if (mounted) setState(() => _sending = false);
    }
  }

  Future<void> _pickDocuments() async {
    if (!widget.enabled || _sending) return;

    try {
      final result = await FilePicker.platform.pickFiles(
        allowMultiple: true,
        withData: false,
        type: FileType.any,
      );

      if (result == null || result.files.isEmpty) return;

      int totalBytes = 0;
      final attachments = <ChatAttachment>[];

      for (final f in result.files) {
        final path = f.path;
        if (path == null) continue;

        final file = File(path);
        final size = await file.length();
        totalBytes += size;

        if (totalBytes > _maxBytesPerMessage) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Max 10 MB per message exceeded.'),
                backgroundColor: Colors.redAccent,
              ),
            );
          }
          return;
        }

        final mime = lookupMimeType(path) ?? 'application/octet-stream';
        attachments.add(ChatAttachment(
          url: path, // local path, will be replaced after upload
          name: f.name,
          mimeType: mime,
          sizeBytes: size,
          compressed: false,
        ));
      }

      if (attachments.isEmpty) return;

      setState(() => _selectedFiles = attachments);
    } catch (e) {
      debugPrint('âŒ Error picking files: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to pick files: $e'),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
    }
  }

  void _removeFile(int index) {
    setState(() => _selectedFiles.removeAt(index));
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // File preview section
        if (_selectedFiles.isNotEmpty)
          Container(
            constraints: const BoxConstraints(maxHeight: 200),
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.05),
              borderRadius: const BorderRadius.vertical(top: Radius.circular(12)),
            ),
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: _selectedFiles.length,
              itemBuilder: (context, index) {
                return _FilePreviewTile(
                  attachment: _selectedFiles[index],
                  onRemove: () => _removeFile(index),
                );
              },
            ),
          ),

        // Input row
        Row(
          children: [
            // Attach button (only show if no files selected)
            if (_selectedFiles.isEmpty)
              IconButton(
                onPressed: widget.enabled && !_sending ? _pickDocuments : null,
                icon: const Icon(Icons.add),
                color: Colors.white,
                tooltip: 'Attach',
              ),

            // Text field
            Expanded(
              child: TextField(
                controller: _controller,
                enabled: widget.enabled && !_sending,
                style: const TextStyle(color: Colors.white),
                minLines: 1,
                maxLines: 4,
                decoration: InputDecoration(
                  hintText: _selectedFiles.isEmpty
                      ? widget.hintText
                      : 'Add a message (optional)',
                  hintStyle: const TextStyle(color: Colors.white38),
                  filled: true,
                  fillColor: Colors.white.withOpacity(0.06),
                  contentPadding:
                      const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(18),
                    borderSide: const BorderSide(color: Colors.white24),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(18),
                    borderSide: const BorderSide(color: Colors.white24),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(18),
                    borderSide:
                        const BorderSide(color: Colors.cyanAccent, width: 1.5),
                  ),
                ),
                onSubmitted: (_) => _handleSend(),
              ),
            ),

            const SizedBox(width: 8),

            // Send button - ALWAYS enabled if files or text present
            IconButton(
              onPressed: (widget.enabled &&
                      !_sending &&
                      (_selectedFiles.isNotEmpty ||
                          _controller.text.trim().isNotEmpty))
                  ? _handleSend
                  : null,
              icon: _sending
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor:
                            AlwaysStoppedAnimation<Color>(Colors.cyanAccent),
                      ),
                    )
                  : const Icon(Icons.send_rounded, color: Colors.cyanAccent),
              tooltip: 'Send',
            ),
          ],
        ),
      ],
    );
  }
}

class _FilePreviewTile extends StatelessWidget {
  final ChatAttachment attachment;
  final VoidCallback onRemove;

  const _FilePreviewTile({
    required this.attachment,
    required this.onRemove,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.08),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.white24),
      ),
      child: Row(
        children: [
          // File icon
          Icon(
            _getFileIcon(attachment.mimeType),
            color: Colors.cyanAccent,
            size: 28,
          ),
          const SizedBox(width: 12),

          // File info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  attachment.name,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 2),
                Text(
                  '${(attachment.sizeBytes / 1024).toStringAsFixed(1)} KB',
                  style: const TextStyle(
                    color: Colors.white54,
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),

          // Remove button
          IconButton(
            icon: const Icon(Icons.close, color: Colors.redAccent, size: 20),
            onPressed: onRemove,
            tooltip: 'Remove',
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(),
          ),
        ],
      ),
    );
  }

  IconData _getFileIcon(String mime) {
    if (mime.startsWith('image/')) return Icons.image;
    if (mime == 'application/pdf') return Icons.picture_as_pdf;
    if (mime.startsWith('video/')) return Icons.videocam;
    if (mime.startsWith('audio/')) return Icons.audiotrack;
    return Icons.insert_drive_file;
  }
}

================================================================================

// File: lib\chat\widgets\chat_shell.dart
import 'package:flutter/material.dart';

import '../models/chat_channel.dart';
import '../models/chat_conversation.dart';
import '../models/chat_message.dart';
import '../repositories/chat_repository.dart';
import '../services/chat_storage_uploader.dart';
import 'chat_input_bar.dart';
import 'message_list.dart';

class ChatShell extends StatelessWidget {
  final String tenantId;
  final ChatConversation conversation;
  final ChatChannel channel;
  final String currentUserId;

  const ChatShell({
    super.key,
    required this.tenantId,
    required this.conversation,
    required this.channel,
    required this.currentUserId,
  });

  bool get canSend {
    // DEBUG: Log permission check
    debugPrint('ğŸ” ChatShell canSend check:');
    debugPrint('  Channel: ${channel.displayName}');
    debugPrint('  CurrentUserId: $currentUserId');
    debugPrint('  AssignedByUid: ${conversation.assignedByUid}');
    debugPrint('  LeadMemberUid: ${conversation.leadMemberUid}');
    debugPrint('  AssignedToUids: ${conversation.assignedToUids}');

    switch (channel) {
      case ChatChannel.teamMembers:
        final result = conversation.canSendToTeamChannel(currentUserId);
        debugPrint('  âœ… Team channel permission: $result');
        return result;

      case ChatChannel.managerCommunication:
        final result = conversation.canSendToAssignedByChannel(currentUserId);
        debugPrint('  âœ… Manager channel permission: $result');
        return result;
    }
  }

  String get hint {
    switch (channel) {
      case ChatChannel.teamMembers:
        return 'Message team members';
      case ChatChannel.managerCommunication:
        return 'Escalate to manager / Share progress';
    }
  }

  @override
  Widget build(BuildContext context) {
    final repo = ChatRepository(tenantId: tenantId);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: Row(
            children: [
              Text(
                channel.displayName,
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(width: 8),
              if (!canSend)
                const Text(
                  '(read only)',
                  style: TextStyle(
                    color: Colors.white38,
                    fontSize: 10,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              // DEBUG: Show permission details
              if (!canSend)
                Tooltip(
                  message: 'Current: $currentUserId\n'
                      'Lead: ${conversation.leadMemberUid}\n'
                      'Assigned: ${conversation.assignedToUids}',
                  child: const Padding(
                    padding: EdgeInsets.only(left: 4),
                    child: Icon(
                      Icons.info_outline,
                      size: 12,
                      color: Colors.white24,
                    ),
                  ),
                ),
            ],
          ),
        ),

        // Messages
        Expanded(
          child: StreamBuilder<List<ChatMessage>>(
            stream: repo.streamMessages(
              conversationId: conversation.conversationId,
              channel: channel,
            ),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(
                  child: CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.cyanAccent),
                    strokeWidth: 2,
                  ),
                );
              }

              final msgs = snapshot.data ?? const <ChatMessage>[];

              if (msgs.isEmpty) {
                return const Center(
                  child: Text(
                    'No messages yet. Start the conversation.',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.white38, fontSize: 11),
                  ),
                );
              }

              return MessageList(
                messages: msgs,
                currentUserId: currentUserId,
                tenantId: tenantId,
              );
            },
          ),
        ),

        const SizedBox(height: 8),

        // Input bar
        ChatInputBar(
          enabled: canSend,
          hintText: hint,
          onSendText: (text) async {
            debugPrint('ğŸ“¤ Sending text message...');
            debugPrint('  ConversationId: ${conversation.conversationId}');
            debugPrint('  Channel: ${channel.firestoreCollection}');
            debugPrint('  SenderId: $currentUserId');

            await repo.sendTextMessage(
              conversationId: conversation.conversationId,
              channel: channel,
              senderId: currentUserId,
              senderRole: _roleForCurrentUser,
              text: text,
              sendTo: _resolveSendTo,
            );

            debugPrint('âœ… Text message sent successfully');
          },
          onSendAttachments: ({
            required List<ChatAttachment> attachments,
            String? text,
          }) async {
            debugPrint('ğŸ“ Sending file message with ${attachments.length} attachments...');

            // 1. Upload local files (attachments[i].url = local path from picker)
            final uploadedAttachments = await ChatStorageUploader.uploadAll(
              tenantId: tenantId,
              conversationId: conversation.conversationId,
              localAttachments: attachments,
            );

            // 2. Save message in Firestore with ATTCHEDFILES using repository
            await repo.sendFileMessage(
              conversationId: conversation.conversationId,
              channel: channel,
              senderId: currentUserId,
              senderRole: _roleForCurrentUser,
              attachments: uploadedAttachments,
              text: text,
              sendTo: _resolveSendTo,
            );

            debugPrint('âœ… File message sent successfully');
          },
        ),
      ],
    );
  }

  String? get _resolveSendTo {
    if (channel == ChatChannel.managerCommunication) {
      return conversation.assignedByUid;
    }
    return null;
  }

  String get _roleForCurrentUser {
    if (currentUserId == conversation.assignedByUid) return 'manager';
    if (currentUserId == conversation.leadMemberUid) return 'lead';
    return 'member';
  }
}

================================================================================

// File: lib\chat\widgets\message_bubble.dart
import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';
import 'package:open_filex/open_filex.dart';
import 'package:photo_view/photo_view.dart';
import '../models/chat_message.dart';
import '../../task/utils/user_helper.dart';
import 'dart:io';

import 'package:flutter/material.dart';
import '../models/chat_message.dart';
import '../services/chat_attachment_service.dart';

class MessageBubble extends StatefulWidget {
  final ChatMessage message;
  final bool isMe;
  final String tenantId;

  const MessageBubble({
    super.key,
    required this.message,
    required this.isMe,
    required this.tenantId,
  });

  @override
  State<MessageBubble> createState() => _MessageBubbleState();
}

class _MessageBubbleState extends State<MessageBubble> {
  String? senderName;
  bool isLoadingName = true;

  @override
  void initState() {
    super.initState();
    _loadSenderName();
  }

  Future<void> _loadSenderName() async {
    final name = await UserHelper.getUserDisplayName(
      tenantId: widget.tenantId,
      userId: widget.message.senderId,
    );

    if (mounted) {
      setState(() {
        senderName = name;
        isLoadingName = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      child: Row(
        mainAxisAlignment:
            widget.isMe ? MainAxisAlignment.end : MainAxisAlignment.start,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Avatar for other users (left side)
          if (!widget.isMe) ...[
            CircleAvatar(
              radius: 16,
              backgroundColor: Colors.cyan.withOpacity(0.2),
              child: Text(
                UserHelper.getUserInitials(senderName ?? 'U'),
                style: const TextStyle(
                  color: Colors.cyan,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],

          // Message bubble
          Flexible(
            child: Column(
              crossAxisAlignment: widget.isMe
                  ? CrossAxisAlignment.end
                  : CrossAxisAlignment.start,
              children: [
                // Sender name (only for other users)
                if (!widget.isMe) ...[
                  Padding(
                    padding: const EdgeInsets.only(left: 12, bottom: 2),
                    child: isLoadingName
                        ? const SizedBox(
                            height: 10,
                            width: 10,
                            child: CircularProgressIndicator(
                              strokeWidth: 1,
                              valueColor: AlwaysStoppedAnimation(Colors.white38),
                            ),
                          )
                        : Text(
                            senderName ?? 'Loading...',
                            style: const TextStyle(
                              color: Colors.white70,
                              fontSize: 11,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                  ),
                ],

                // Message container
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 14,
                    vertical: 10,
                  ),
                  decoration: BoxDecoration(
                    color: widget.isMe
                        ? Colors.cyan.withOpacity(0.2)
                        : Colors.white.withOpacity(0.08),
                    borderRadius: BorderRadius.only(
                      topLeft: const Radius.circular(16),
                      topRight: const Radius.circular(16),
                      bottomLeft: Radius.circular(widget.isMe ? 16 : 4),
                      bottomRight: Radius.circular(widget.isMe ? 4 : 16),
                    ),
                    border: Border.all(
                      color: widget.isMe
                          ? Colors.cyan.withOpacity(0.4)
                          : Colors.white.withOpacity(0.1),
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (widget.message.text != null &&
                          widget.message.text!.trim().isNotEmpty)
                        Text(
                          widget.message.text!,
                          style: TextStyle(
                            color: widget.isMe ? Colors.white : Colors.white70,
                            fontSize: 14,
                          ),
                        ),
                      if (widget.message.attachments.isNotEmpty)
                        const SizedBox(height: 6),
                      if (widget.message.attachments.isNotEmpty)
                        ...List.generate(
                          widget.message.attachments.length,
                          (index) => _AttachmentTile(
                            tenantId: widget.tenantId,
                            messageId: widget.message.id,
                            conversationId: '', // fill from parent shell if needed
                            attachment: widget.message.attachments[index],
                            attachmentIndex: index,
                          ),
                        ),
                      const SizedBox(height: 4),
                      Text(
                        _formatTime(widget.message.createdAt),
                        style: TextStyle(
                          color: widget.isMe ? Colors.white38 : Colors.white24,
                          fontSize: 10,
                        ),
                      ),
                    ],
                  ),

                ),
              ],
            ),
          ),

          // Avatar for current user (right side)
          if (widget.isMe) ...[
            const SizedBox(width: 8),
            CircleAvatar(
              radius: 16,
              backgroundColor: Colors.cyan.withOpacity(0.3),
              child: const Icon(
                Icons.person,
                size: 16,
                color: Colors.cyan,
              ),
            ),
          ],
        ],
      ),
    );
  }

  String _formatTime(DateTime time) {
    final now = DateTime.now();
    final difference = now.difference(time);

    if (difference.inMinutes < 1) {
      return 'Just now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
    } else {
      return '${time.day}/${time.month} ${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
    }
  }
}
class _AttachmentTile extends StatefulWidget {
  final String tenantId;
  final String conversationId;
  final String messageId;
  final ChatAttachment attachment;
  final int attachmentIndex;

  const _AttachmentTile({
    required this.tenantId,
    required this.conversationId,
    required this.messageId,
    required this.attachment,
    required this.attachmentIndex,
  });

  @override
  State<_AttachmentTile> createState() => _AttachmentTileState();
}

class _AttachmentTileState extends State<_AttachmentTile> {
  bool _downloading = false;
  double _progress = 0;
  String? _localPath;

  @override
  void initState() {
    super.initState();
    _loadLocal();
  }

  Future<void> _loadLocal() async {
    final path = await ChatAttachmentService.resolveLocalPath(
      tenantId: widget.tenantId,
      conversationId: widget.conversationId,
      messageId: widget.messageId,
      attachmentIndex: widget.attachmentIndex,
    );
    if (mounted) setState(() => _localPath = path);
  }

  Future<void> _download() async {
    setState(() {
      _downloading = true;
      _progress = 0;
    });

    try {
      final file = await ChatAttachmentService.downloadToLocal(
        tenantId: widget.tenantId,
        conversationId: widget.conversationId,
        messageId: widget.messageId,
        attachmentIndex: widget.attachmentIndex,
        attachment: widget.attachment,
        onProgress: (p) {
          if (mounted) setState(() => _progress = p);
        },
      );
      if (mounted) setState(() => _localPath = file.path);
    } finally {
      if (mounted) setState(() => _downloading = false);
    }
  }

  Future<void> _open() async {
    final path = _localPath;
    if (path == null) return;
    final mime = widget.attachment.mimeType;

    if (mime.startsWith('image/')) {
      await showDialog(
        context: context,
        builder: (_) => Dialog(
          backgroundColor: Colors.black,
          child: PhotoView(
            imageProvider: FileImage(File(path)),
          ),
        ),
      );
    } else if (mime == 'application/pdf') {
      await showDialog(
        context: context,
        builder: (_) => Dialog(
          backgroundColor: Colors.black,
          child: PDFView(
            filePath: path,
          ),
        ),
      );
    } else {
      await OpenFilex.open(path);
    }
  }

  @override
  Widget build(BuildContext context) {
    final a = widget.attachment;
    final hasLocal = _localPath != null;

    return Container(
      margin: const EdgeInsets.only(top: 4),
      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.18),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.white24),
      ),
      child: Row(
        children: [
          Icon(
            a.mimeType.startsWith('image/')
                ? Icons.image
                : a.mimeType == 'application/pdf'
                    ? Icons.picture_as_pdf
                    : Icons.insert_drive_file,
            color: Colors.cyanAccent,
            size: 20,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  a.name,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 13,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  '${(a.sizeBytes / 1024).toStringAsFixed(1)} KB',
                  style: const TextStyle(
                    color: Colors.white38,
                    fontSize: 11,
                  ),
                ),
                if (_downloading)
                  Padding(
                    padding: const EdgeInsets.only(top: 4.0),
                    child: LinearProgressIndicator(
                      value: _progress,
                      minHeight: 3,
                      backgroundColor: Colors.white10,
                      valueColor: const AlwaysStoppedAnimation<Color>(
                        Colors.cyanAccent,
                      ),
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(width: 8),
          TextButton(
            onPressed: _downloading
                ? null
                : hasLocal
                    ? _open
                    : _download,
            child: Text(
              hasLocal ? 'Open' : 'Download',
              style: const TextStyle(color: Colors.cyanAccent, fontSize: 12),
            ),
          ),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\chat\widgets\message_list.dart
import 'package:flutter/material.dart';
import '../models/chat_message.dart';
import 'message_bubble.dart';

class MessageList extends StatelessWidget {
  final List<ChatMessage> messages;
  final String currentUserId;
  final String tenantId;

  const MessageList({
    super.key,
    required this.messages,
    required this.currentUserId,
    required this.tenantId,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: messages.length,
      itemBuilder: (context, index) {
        final message = messages[index];
        final isMe = message.senderId == currentUserId;

        return MessageBubble(
          message: message,
          isMe: isMe,
          tenantId: tenantId,
        );
      },
    );
  }
}

================================================================================

// File: lib\core\app_colors.dart
import 'package:flutter/material.dart';

class AppColors {
  // Greys
  static const grey300 = Color(0xFFE0E0E0);
  static const grey400 = Color(0xFFBDBDBD);
  static const grey500 = Color(0xFF9E9E9E);
  static const grey600 = Color(0xFF757575);
  static const grey700 = Color(0xFF616161);
  static const grey800 = Color(0xFF424242);
  static const grey900 = Color(0xFF212121);
  
  // Custom theme colors
  static const darkBg = Color(0xFF05040A);
  static const cardBg = Color(0x6611111C);
  static const glassWhite = Color(0x22FFFFFF);
}

================================================================================

// File: lib\core\glass_container.dart
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// import 'performancestate.dart'; // âŒ REMOVED - no more performance overrides

// Controls whether this widget applies per-widget BackdropFilter blur
enum GlassBlurMode { none, perWidget, auto }

// High-level quality selection (user-controlled only)
enum GlassQualityMode { auto, high, medium, low, ultraLow }

class GlassContainer extends StatelessWidget {
  final double blur;
  final double opacity;
  final Color tint;
  final BorderRadius borderRadius;
  final EdgeInsetsGeometry padding;
  final Widget child;
  final double borderOpacity;
  final double borderWidth;
  final List<BoxShadow> boxShadow;

  // Controls blur strategy
  final GlassBlurMode blurMode;
  // Controls quality strategy (user choice only)
  final GlassQualityMode qualityMode;
  // Hint from callers (dragging/resizing/scrolling/animating)
  final bool isInteracting;
  // Allow callers to disable shadows completely
  final bool disableShadows;

  const GlassContainer({
    super.key,
    required this.blur,
    required this.opacity,
    required this.tint,
    required this.borderRadius,
    required this.child,
    this.padding = EdgeInsets.zero,
    this.borderOpacity = 0.18,
    this.borderWidth = 1,
    this.boxShadow = const [
      BoxShadow(
        color: Color(0x40000000),
        blurRadius: 18,
        offset: Offset(0, 10),
      ),
    ],
    this.blurMode = GlassBlurMode.auto,
    this.qualityMode = GlassQualityMode.auto,
    this.isInteracting = false,
    this.disableShadows = false,
  });

  // âœ… FIXED: Always use user's exact settings - NO performance overrides
  GlassQualityMode get resolvedQualityMode {
    // User explicitly chose a quality level
    if (qualityMode != GlassQualityMode.auto) return qualityMode;
    
    // Always use high quality unless user specifically chose lower
    return GlassQualityMode.high;
  }

  // âœ… FIXED: Use EXACT user blur value - no clamping/reduction
  double get effectiveBlur => blur.clamp(0.0, 40.0);

  // âœ… FIXED: Use EXACT user opacity value - no clamping/reduction  
  double get effectiveOpacity => opacity.clamp(0.0, 1.0);

  // âœ… FIXED: Always use full shadows - no performance reduction
  List<BoxShadow> get effectiveShadows {
    if (disableShadows) return const [];
    return boxShadow;
  }

  // âœ… FIXED: Simplified backdrop filter logic - respect user blurMode only
  bool get shouldUseBackdropFilter {
    if (effectiveBlur == 0) return false;
    
    switch (blurMode) {
      case GlassBlurMode.none:
        return false;
      case GlassBlurMode.perWidget:
        return true;
      case GlassBlurMode.auto:
        // Always use backdrop filter if user set blur > 0
        return true;
    }
  }

  @override
  Widget build(BuildContext context) {
    final blurSigma = effectiveBlur.clamp(0.0, 30.0);
    final a = effectiveOpacity;
    
    // Tint fill
    final fill = tint.withOpacity(a);
    
    // Full border (no performance reduction)
    final effBorderOpacity = borderOpacity.clamp(0.0, 1.0);
    final effBorderWidth = borderWidth;

    final decoration = BoxDecoration(
      color: fill,
      borderRadius: borderRadius,
      border: Border.all(
        color: Colors.white.withOpacity(effBorderOpacity),
        width: effBorderWidth,
      ),
      boxShadow: effectiveShadows,
    );

    final body = Container(
      decoration: decoration,
      padding: padding,
      child: child,
    );

    // Fast path: no BackdropFilter
    if (!shouldUseBackdropFilter) {
      return body;
    }

    // High quality: per-widget BackdropFilter
    return ClipRRect(
      borderRadius: borderRadius,
      child: BackdropFilter(
        filter: ImageFilter.blur(
          sigmaX: blurSigma,
          sigmaY: blurSigma,
        ),
        child: body,
      ),
    );
  }
}

================================================================================

// File: lib\core\performance_state.dart
/// Shared singleton to track app warm-up and performance state
class PerformanceState {
  PerformanceState._();
  static final PerformanceState instance = PerformanceState._();

  /// Set to true when WorkspaceShell has warmed up and is stable
  bool isWarmupStable = false;
  
  /// Optional: track current FPS for logging
  double? currentFps;
  
  /// Reset state (e.g., on hot reload)
  void reset() {
    isWarmupStable = false;
    currentFps = null;
  }
}

================================================================================

// File: lib\core\permissions_cache.dart
import 'package:flutter/material.dart';

class PermissionsCache extends ChangeNotifier {
  static final PermissionsCache instance = PermissionsCache._();
  PermissionsCache._();

  Set<String>? _cachedWidgetIds;
  String? _cachedUserId;
  DateTime? _cacheTime;

  static const _cacheValidDuration = Duration(minutes: 5);

  bool get hasCache => _cachedWidgetIds != null && _isValid;

  bool get _isValid {
    if (_cacheTime == null) return false;
    return DateTime.now().difference(_cacheTime!) < _cacheValidDuration;
  }

  /// Return cached permissions for [userId] if they are still valid,
  /// otherwise null.
  Set<String>? getCachedPermissions(String userId) {
    if (_cachedUserId != userId) return null;
    if (!_isValid) return null;
    return _cachedWidgetIds;
  }

  /// Store permissions for [userId] in memory cache for a short duration.
  void setCachedPermissions(String userId, Set<String> widgetIds) {
    _cachedUserId = userId;
    _cachedWidgetIds = widgetIds;
    _cacheTime = DateTime.now();

    debugPrint(
      '[PermissionsCache] âœ… Cached ${widgetIds.length} permissions for user $userId',
    );
    notifyListeners();
  }

  void clearCache() {
    _cachedWidgetIds = null;
    _cachedUserId = null;
    _cacheTime = null;
    debugPrint('[PermissionsCache] ğŸ—‘ï¸ Cache cleared');
    notifyListeners();
  }
}

================================================================================

// File: lib\core\wallpaper_service.dart
import 'dart:async';
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

class WallpaperService extends ChangeNotifier {
  static final WallpaperService instance = WallpaperService._();
  WallpaperService._();

  static const prefsWallpaperKey = 'wallpaper_path';
  static const prefsGlobalOpacityKey = 'global_widget_opacity';
  static const prefsGlobalBlurKey = 'global_widget_blur';

  String? wallpaperPath;
  double globalGlassOpacity = 0.12;
  double globalGlassBlur = 16.0;
  bool isLoaded = false;

  ui.Image? _cachedDecodedImage;
  ImageProvider? _cachedImageProvider;
  DateTime _lastNotify = DateTime.fromMillisecondsSinceEpoch(0);

  /// Load settings from cache (called once at startup)
  Future<void> loadSettings() async {
    if (isLoaded) return;

    final prefs = await SharedPreferences.getInstance();
    wallpaperPath = prefs.getString(prefsWallpaperKey);
    globalGlassOpacity = prefs.getDouble(prefsGlobalOpacityKey) ?? 0.12;
    globalGlassBlur = prefs.getDouble(prefsGlobalBlurKey) ?? 16.0;

    debugPrint('ğŸ’ GLASS: Loaded from cache â†’ blur=$globalGlassBlur, opacity=$globalGlassOpacity');

    if (wallpaperPath != null && File(wallpaperPath!).existsSync()) {
      await _precacheWallpaper();
    } else {
      wallpaperPath = null;
    }

    isLoaded = true;
    _notifyNow();
  }

  /// Save ALL settings (wallpaper + glass)
  Future<void> saveSettings() async {
    final prefs = await SharedPreferences.getInstance();

    if (wallpaperPath != null) {
      await prefs.setString(prefsWallpaperKey, wallpaperPath!);
    } else {
      await prefs.remove(prefsWallpaperKey);
    }

    await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);
    await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);

    debugPrint('ğŸ’¾ GLASS: Full settings saved â†’ blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    _notifyNow();
  }

  /// FIXED: Blur setter with AWAITED save
  void setGlassBlur(double blur) {
    final oldBlur = globalGlassBlur;
    final clampedBlur = blur.clamp(0.0, 40.0);

    // Block performance overrides that reset to 0.0
    if (clampedBlur == 0.0 && oldBlur > 5.0) {
      debugPrint('ğŸ›¡ï¸ GLASS PROTECTED: Blocked blur=0.0, keeping $oldBlur (throttledNotify)');
      return; // BLOCK IT!
    }

    globalGlassBlur = clampedBlur;
    debugPrint('ğŸ’ GLASS: Blur â†’ $globalGlassBlur');
    _throttledNotify();
    
    // FIXED: Now properly awaited via scheduleMicrotask
    scheduleMicrotask(() => _saveGlassSettingsOnly());
  }

  /// FIXED: Opacity setter with AWAITED save
  void setGlassOpacity(double opacity) {
    final oldOpacity = globalGlassOpacity;
    final clampedOpacity = opacity.clamp(0.02, 0.40);

    // Block performance overrides that reset to 0.04
    if (clampedOpacity < 0.05 && oldOpacity > 0.10) {
      debugPrint('ğŸ›¡ï¸ GLASS PROTECTED: Blocked opacity=$clampedOpacity, keeping $oldOpacity (throttledNotify)');
      return; // BLOCK IT!
    }

    globalGlassOpacity = clampedOpacity;
    debugPrint('ğŸ’ GLASS: Opacity â†’ $globalGlassOpacity');
    _throttledNotify();
    
    // FIXED: Now properly awaited via scheduleMicrotask
    scheduleMicrotask(() => _saveGlassSettingsOnly());
  }

  /// FIXED: Fast save only glass settings (now with better error handling)
  Future<void> _saveGlassSettingsOnly() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);
      await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);
      debugPrint('âœ… GLASS: Saved to cache â†’ blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    } catch (e) {
      debugPrint('âŒ GLASS: Save failed â†’ $e');
    }
  }

  /// Pick wallpaper
  Future<void> pickWallpaper() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.image,
      allowMultiple: false,
      withData: false,
    );

    final pickedPath = result?.files.single.path;
    if (pickedPath == null) return;

    final normalizedPath = await _copyAndNormalizeWallpaper(pickedPath);
    wallpaperPath = normalizedPath;
    await _precacheWallpaper();
    await saveSettings();
  }

  /// Reset wallpaper
  Future<void> resetWallpaper() async {
    wallpaperPath = null;
    _cachedImageProvider = null;
    _cachedDecodedImage = null;
    await saveSettings();
  }

  void _throttledNotify() {
    final now = DateTime.now();
    if (now.difference(_lastNotify).inMilliseconds < 16) return;
    _lastNotify = now;
    notifyListeners();
  }

  void _notifyNow() {
    _lastNotify = DateTime.now();
    notifyListeners();
  }

  Future<void> _precacheWallpaper() async {
    final path = wallpaperPath;
    if (path == null) return;

    final file = File(path);
    if (!file.existsSync()) {
      wallpaperPath = null;
      _cachedImageProvider = null;
      _cachedDecodedImage = null;
      return;
    }

    try {
      _cachedImageProvider = FileImage(file);
      final imageStream = _cachedImageProvider!.resolve(const ImageConfiguration());
      final completer = Completer<void>();

      late final ImageStreamListener listener;
      listener = ImageStreamListener(
        (ImageInfo info, bool _) {
          _cachedDecodedImage = info.image;
          imageStream.removeListener(listener);
          completer.complete();
        },
        onError: (_, __) {
          imageStream.removeListener(listener);
          _cachedImageProvider = null;
          _cachedDecodedImage = null;
          completer.complete();
        },
      );

      imageStream.addListener(listener);
      await completer.future;
    } catch (e) {
      _cachedImageProvider = null;
      _cachedDecodedImage = null;
    }
  }

  Future<String> _copyAndNormalizeWallpaper(
    String pickedPath, {
    int maxDimension = 2560,
  }) async {
    final appDir = await getApplicationSupportDirectory();
    final wpDir = Directory(p.join(appDir.path, 'wallpapers'));
    if (!await wpDir.exists()) {
      await wpDir.create(recursive: true);
    }

    final cachedPath = p.join(wpDir.path, 'current_wallpaper.png');
    final srcBytes = await File(pickedPath).readAsBytes();

    try {
      final codec = await ui.instantiateImageCodec(srcBytes);
      final frame = await codec.getNextFrame();
      final img = frame.image;

      final srcW = img.width;
      final srcH = img.height;
      final scale = math.min(
        1.0,
        maxDimension / math.max(srcW.toDouble(), srcH.toDouble()),
      );

      final targetW = (srcW * scale).round();
      final targetH = (srcH * scale).round();

      ui.Image outImage = img;
      if (scale < 1.0) {
        codec.dispose();
        final codec2 = await ui.instantiateImageCodec(
          srcBytes,
          targetWidth: targetW,
          targetHeight: targetH,
        );
        final frame2 = await codec2.getNextFrame();
        outImage = frame2.image;
        codec2.dispose();
      } else {
        codec.dispose();
      }

      final byteData = await outImage.toByteData(format: ui.ImageByteFormat.png);
      final pngBytes = byteData?.buffer.asUint8List();

      if (pngBytes == null) {
        await File(pickedPath).copy(cachedPath);
        return cachedPath;
      }

      await File(cachedPath).writeAsBytes(pngBytes, flush: true);

      try {
        outImage.dispose();
      } catch (_) {}

      return cachedPath;
    } catch (_) {
      final ext = p.extension(pickedPath).isNotEmpty ? p.extension(pickedPath) : '.jpg';
      final fallbackPath = p.join(wpDir.path, 'current_wallpaper$ext');
      await File(pickedPath).copy(fallbackPath);
      return fallbackPath;
    }
  }

  BoxDecoration get backgroundDecoration {
    if (_cachedImageProvider != null && _cachedDecodedImage != null) {
      return BoxDecoration(
        image: DecorationImage(
          image: _cachedImageProvider!,
          fit: BoxFit.cover,
        ),
      );
    }

    return const BoxDecoration(
      gradient: LinearGradient(
        begin: Alignment.topCenter,
        end: Alignment.bottomCenter,
        colors: [
          Color(0xFF050716),
          Color(0xFF020308),
        ],
      ),
    );
  }

  /// Legacy method (kept for backward compatibility)
  Future<void> updateGlass({
    required double blur,
    required double opacity,
  }) async {
    globalGlassBlur = blur.clamp(0.0, 30.0);
    globalGlassOpacity = opacity.clamp(0.0, 1.0);

    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);
    await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);

    debugPrint('ğŸ’¾ GLASS: Legacy updateGlass saved â†’ blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    notifyListeners();
  }
}

================================================================================

// File: lib\Developer\developer_dashboard_screen.dart
import 'package:flutter/material.dart';
import 'Metadata/metadata_panel.dart';
import 'Hierarchy/hierarchy_panel.dart';
import 'DynamicForms/dynamic_forms_panel.dart';
import 'UserDatabase/userdatabasepanel.dart'; // NEW IMPORT

class DeveloperDashboardScreen extends StatefulWidget {
  const DeveloperDashboardScreen({super.key});

  @override
  State<DeveloperDashboardScreen> createState() =>
      _DeveloperDashboardScreenState();  // ADD () here
}

class _DeveloperDashboardScreenState extends State<DeveloperDashboardScreen> {
  // 0: User Database, 1: Metadata, 2: Hierarchy, 3: Dynamic Forms
  int selectedIndex = 0; // Starts at User Database

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Row(
        children: [
          // LEFT NAVIGATION
          Container(
            width: 260,
            color: const Color(0xFF0B0B10),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 32),
                const ListTile(
                  leading: Icon(Icons.code, color: Colors.cyan),
                  title: Text(
                    'Developer Console',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                const Divider(color: Colors.white24),
                
                // NAVIGATION ITEMS
                navItem(0, Icons.dns_rounded, 'User Database'), // CHANGED ICON
                navItem(1, Icons.storage_rounded, 'Metadata'),
                navItem(2, Icons.account_tree_rounded, 'Hierarchy'),
                navItem(3, Icons.dynamic_form_rounded, 'Dynamic Forms'),
                
                const Spacer(),
                const Padding(
                  padding: EdgeInsets.all(12.0),
                  child: Text(
                    'Tenant: default_tenant â€¢ Synced',
                    style: TextStyle(color: Colors.grey, fontSize: 12),
                  ),
                ),
              ],
            ),
          ),
          
          // MAIN CONTENT
          Expanded(
            child: Container(
              color: const Color(0xFF050509),
              padding: const EdgeInsets.all(24),
              child: buildSelectedPanel(),
            ),
          ),
        ],
      ),
    );
  }

  // PANEL BUILDER
  Widget buildSelectedPanel() {
    switch (selectedIndex) {
      case 0:
        return const UserDatabasePanel();
      case 1:
        return const MetadataPanel();
      case 2:
        return const HierarchyPanel();
      case 3:
        return const DynamicFormsPanel();
      default:
        return const UserDatabasePanel();
    }
  }

  // NAVIGATION ITEM
  Widget navItem(int index, IconData icon, String label) {
    final selected = selectedIndex == index;
    return ListTile(
      leading: Icon(
        icon,
        color: selected ? Colors.cyan : Colors.grey,
      ),
      title: Text(
        label,
        style: TextStyle(
          color: selected ? Colors.cyan : Colors.grey.shade300,
          fontWeight: selected ? FontWeight.bold : FontWeight.normal,
        ),
      ),
      selected: selected,
      selectedTileColor: const Color(0xFF1A1A25),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: () {
        setState(() {
          selectedIndex = index;
        });
      },
    );
  }
}

================================================================================

// File: lib\Developer\DynamicForms\dynamic_forms_panel.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import 'dynamic_forms_repository.dart';
import 'form_models.dart';

class DynamicFormsPanel extends StatefulWidget {
  const DynamicFormsPanel({super.key});

  @override
  State<DynamicFormsPanel> createState() => _DynamicFormsPanelState();
}

class _DynamicFormsPanelState extends State<DynamicFormsPanel> {
  // Line 11:
  static const String tenantId = 'default_tenant'; // Fixed


  final DynamicFormsRepository _repo = DynamicFormsRepository();

  final List<FormSchemaMeta> _forms = [];
  int _selectedIndex = 0;
  bool _loading = false;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  void _setStatus(String msg, {bool error = false}) {
    setState(() {
      _status = msg;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await _repo.loadForms(tenantId);
      setState(() {
        _forms
          ..clear()
          ..addAll(list);
        _selectedIndex = 0;
      });
      _setStatus('Loaded ${_forms.length} form(s)');
    } catch (e) {
      _setStatus('Failed to load forms: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final selectedForm = _forms.isEmpty ? null : _forms[_selectedIndex];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Dynamic Forms Engine â€“ Preview',
          style: TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Runtime renderer for formSchemas metadata (system + custom forms).',
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Row(
            children: [
              // LEFT: Form list
              SizedBox(
                width: 260,
                child: Card(
                  color: const Color(0xFF111118),
                  child: _forms.isEmpty
                      ? const Center(
                          child: Text(
                            'No forms yet.',
                            style: TextStyle(color: Colors.white70),
                          ),
                        )
                      : ListView.builder(
                          itemCount: _forms.length,
                          itemBuilder: (context, index) {
                            final f = _forms[index];
                            final selected = index == _selectedIndex;
                            return ListTile(
                              selected: selected,
                              selectedTileColor: const Color(0xFF1A1A25),
                              title: Text(
                                f.formId,
                                style: TextStyle(
                                  color: selected
                                      ? Colors.cyan
                                      : Colors.white,
                                  fontWeight: selected
                                      ? FontWeight.bold
                                      : FontWeight.normal,
                                ),
                              ),
                              subtitle: Text(
                                f.name,
                                style: const TextStyle(
                                    color: Colors.grey, fontSize: 12),
                              ),
                              onTap: () =>
                                  setState(() => _selectedIndex = index),
                            );
                          },
                        ),
                ),
              ),
              const SizedBox(width: 12),
              // RIGHT: Form preview
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: selectedForm == null
                        ? const Center(
                            child: Text(
                              'No form selected.',
                              style: TextStyle(color: Colors.white70),
                            ),
                          )
                        : _DynamicFormRenderer(
                            tenantId: tenantId,
                            form: selectedForm,
                            onSubmit: (payload) async {
                              // hook for real backend later
                              debugPrint(
                                  'Dynamic form "${selectedForm.formId}" submitted: $payload');
                            },
                          ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

/* ------------------------ Runtime form renderer ------------------------ */

class _DynamicFormRenderer extends StatefulWidget {
  final String tenantId;
  final FormSchemaMeta form;
  final Future<void> Function(Map<String, dynamic> values)? onSubmit;

  const _DynamicFormRenderer({
    required this.tenantId,
    required this.form,
    this.onSubmit,
  });

  @override
  State<_DynamicFormRenderer> createState() => _DynamicFormRendererState();
}

class _DynamicFormRendererState extends State<_DynamicFormRenderer> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, dynamic> _values = {};
  final Map<String, bool> _checkboxValues = {};
  final Map<String, String?> _dropdownValues = {};
  final Map<String, List<DropdownMenuItem<String>>> _dropdownItems = {};
  final Map<String, bool> _loadingDropdown = {};

  @override
  void initState() {
    super.initState();
    for (final field in widget.form.fields) {
      if (field.type == 'checkbox') {
        _checkboxValues[field.id] = false;
      } else if (field.type == 'dropdown') {
        _dropdownValues[field.id] =
            field.options.isNotEmpty ? field.options.first : null;
        _loadDropdownOptions(field);
      } else {
        _controllers[field.id] = TextEditingController();
      }
    }
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _loadDropdownOptions(FormFieldMeta field) async {
    if (field.dataSource != 'firestore' ||
        field.collection == null ||
        field.displayField == null ||
        field.valueField == null) {
      // static options
      _dropdownItems[field.id] = field.options
          .map((o) => DropdownMenuItem(value: o, child: Text(o)))
          .toList();
      setState(() {});
      return;
    }

    setState(() => _loadingDropdown[field.id] = true);
    try {
      final snap = await FirebaseFirestore.instance
          .collection('tenants/${widget.tenantId}/${field.collection}')
          .get();

      final items = snap.docs.map((doc) {
        final data = doc.data();
        final value = data[field.valueField] ?? doc.id;
        final label = data[field.displayField] ?? value.toString();
        return DropdownMenuItem<String>(
          value: value.toString(),
          child: Text(label.toString()),
        );
      }).toList();

      _dropdownItems[field.id] = items;
      if (_dropdownValues[field.id] == null && items.isNotEmpty) {
        _dropdownValues[field.id] = items.first.value;
      }
    } finally {
      setState(() => _loadingDropdown[field.id] = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (widget.form.fields.isEmpty) {
      return const Center(
        child: Text(
          'This form has no fields.',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    return Form(
      key: _formKey,
      child: ListView(
        children: [
          Text(
            widget.form.name,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          if (widget.form.description.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(
              widget.form.description,
              style: const TextStyle(color: Colors.white70),
            ),
          ],
          const SizedBox(height: 16),
          ...widget.form.fields.map(_buildField),
          const SizedBox(height: 24),
          SizedBox(
            height: 48,
            child: FilledButton(
              onPressed: _onSubmit,
              child: const Text('Submit (debug)'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildField(FormFieldMeta field) {
    switch (field.type) {
      case 'email':
      case 'text':
      case 'password':
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: TextFormField(
            controller: _controllers[field.id],
            obscureText: field.type == 'password',
            decoration: InputDecoration(
              labelText: field.label,
              floatingLabelBehavior: FloatingLabelBehavior.auto,
            ),
            validator: (v) => _runValidation(field, v?.trim() ?? ''),
          ),
        );
      case 'dropdown':
        final loading = _loadingDropdown[field.id] ?? false;
        final items = _dropdownItems[field.id] ??
            field.options
                .map(
                  (o) => DropdownMenuItem(
                    value: o,
                    child: Text(o),
                  ),
                )
                .toList();

        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: DropdownButtonFormField<String>(
            value: _dropdownValues[field.id],
            decoration: InputDecoration(
              labelText: field.label,
              floatingLabelBehavior: FloatingLabelBehavior.auto,
            ),
            dropdownColor: const Color(0xFF111118),
            items: items,
            validator: (v) {
              if (field.required && (v == null || v.isEmpty)) {
                return '${field.label} is required';
              }
              return null;
            },
            onChanged: loading
                ? null
                : (v) {
                    setState(() => _dropdownValues[field.id] = v);
                  },
          ),
        );
      case 'checkbox':
        return Padding(
          padding: const EdgeInsets.only(bottom: 8.0),
          child: CheckboxListTile(
            value: _checkboxValues[field.id] ?? false,
            onChanged: (v) {
              setState(() => _checkboxValues[field.id] = v ?? false);
            },
            title: Text(
              field.label,
              style: const TextStyle(color: Colors.white),
            ),
            controlAffinity: ListTileControlAffinity.leading,
            contentPadding: EdgeInsets.zero,
          ),
        );
      case 'date':
        return _DateField(
          label: field.label,
          required: field.required,
          onChanged: (value) => _values[field.id] = value,
        );
      default:
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: Text(
            'Unsupported field type: ${field.type}',
            style: const TextStyle(color: Colors.redAccent),
          ),
        );
    }
  }

  String? _runValidation(FormFieldMeta field, String value) {
    if (field.required && value.isEmpty) {
      return '${field.label} is required';
    }
    if (field.type == 'email' && value.isNotEmpty) {
      final ok =
          RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value);
      if (!ok) return 'Invalid email';
    }
    if (field.validation != null && value.isNotEmpty) {
      final re = RegExp(field.validation!);
      if (!re.hasMatch(value)) {
        return 'Invalid ${field.label}';
      }
    }
    return null;
  }

  Future<void> _onSubmit() async {
    if (!_formKey.currentState!.validate()) return;

    for (final entry in _controllers.entries) {
      _values[entry.key] = entry.value.text.trim();
    }
    for (final entry in _checkboxValues.entries) {
      _values[entry.key] = entry.value;
    }
    for (final entry in _dropdownValues.entries) {
      _values[entry.key] = entry.value;
    }

    if (widget.onSubmit != null) {
      await widget.onSubmit!(_values);
    } else {
      debugPrint(
          'Dynamic form "${widget.form.formId}" submitted: $_values');
      ScaffoldMessenger.of(_formKey.currentContext!).showSnackBar(
        const SnackBar(
          content:
              Text('Form submitted â€“ see debug console for payload'),
        ),
      );
    }
  }
}

/* ----------------------------- Helper widgets ---------------------------- */

class _DateField extends StatefulWidget {
  final String label;
  final bool required;
  final ValueChanged<DateTime?> onChanged;

  const _DateField({
    required this.label,
    required this.required,
    required this.onChanged,
  });

  @override
  State<_DateField> createState() => _DateFieldState();
}

class _DateFieldState extends State<_DateField> {
  DateTime? _value;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: InkWell(
        onTap: _pickDate,
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: widget.label,
          ),
          child: Text(
            _value == null
                ? 'Select date'
                : '${_value!.year}-${_value!.month.toString().padLeft(2, '0')}-${_value!.day.toString().padLeft(2, '0')}',
            style: const TextStyle(color: Colors.white),
          ),
        ),
      ),
    );
  }

  Future<void> _pickDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _value ?? now,
      firstDate: DateTime(now.year - 5),
      lastDate: DateTime(now.year + 5),
    );
    if (picked != null) {
      setState(() => _value = picked);
      widget.onChanged(picked);
    }
  }
}

================================================================================

// File: lib\Developer\DynamicForms\dynamic_forms_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';

import 'form_models.dart';

class DynamicFormsRepository {
  final FirebaseFirestore _db;

  DynamicFormsRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;

  Future<List<FormSchemaMeta>> loadForms(String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .get();

    final List<FormSchemaMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final forms =
          (data['forms'] ?? <String, dynamic>{}) as Map<String, dynamic>;

      for (final entry in forms.entries) {
        final m = entry.value as Map<String, dynamic>;
        result.add(FormSchemaMeta.fromFirestore(entry.key, m));
      }
    }

    if (result.isEmpty) {
      result.add(FormSchemaMeta.defaultUserRegistration());
    }

    return result;
  }
}

================================================================================

// File: lib\Developer\DynamicForms\form_models.dart
import 'dart:convert';

/* High-level form definition */

class FormSchemaMeta {
  String formId;
  String name;
  String description;
  List<FormFieldMeta> fields;

  FormSchemaMeta({
    required this.formId,
    required this.name,
    required this.description,
    required this.fields,
  });

  factory FormSchemaMeta.fromFirestore(
      String id, Map<String, dynamic> map) {
    final schema = map['schema'] ?? {};
    final fieldsJson = (schema['fields'] ?? []) as List<dynamic>;

    return FormSchemaMeta(
      formId: id,
      name: map['name'] ?? id,
      description: map['description'] ?? '',
      fields: fieldsJson
          .map((e) => FormFieldMeta.fromMap(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toFirestore() {
    final schema = {
      'formId': formId,
      'version': 1,
      'fields': fields.map((f) => f.toMap()).toList(),
    };

    return {
      'name': name,
      'description': description,
      'schema': schema,
    };
  }

  static FormSchemaMeta defaultUserRegistration() {
    return FormSchemaMeta(
      formId: 'user_registration',
      name: 'User Registration Form',
      description: 'New user signup with designation + department',
      fields: [
        FormFieldMeta(
          id: 'fullName',
          type: 'text',
          label: 'Full Name',
          required: true,
          validation: r'^[a-zA-Z\s]{3,50}$',
        ),
        FormFieldMeta(
          id: 'email',
          type: 'email',
          label: 'Email Address',
          required: true,
          validation: r'^[^@]+@[^@]+\.[^@]+$',
        ),
      ],
    );
  }
}

/* Per-field metadata */

class FormFieldMeta {
  String id;
  String type;              // text, email, dropdown, checkbox, date, etc.
  String label;
  bool required;
  List<String> options;     // for static dropdowns

  // Dynamic data source (for designation / department pickers, etc.)
  String? dataSource;       // e.g. "firestore"
  String? collection;       // collection path under tenant (e.g. "designations")
  String? displayField;     // field used for display text
  String? valueField;       // field used as stored value

  // Schema-driven validation (regex)
  String? validation;

  FormFieldMeta({
    required this.id,
    required this.type,
    required this.label,
    this.required = false,
    List<String>? options,
    this.dataSource,
    this.collection,
    this.displayField,
    this.valueField,
    this.validation,
  }) : options = options ?? [];

  factory FormFieldMeta.fromMap(Map<String, dynamic> map) {
    return FormFieldMeta(
      id: map['id'] ?? '',
      type: map['type'] ?? 'text',
      label: map['label'] ?? '',
      required: map['required'] ?? false,
      options: List<String>.from(map['options'] ?? const []),
      dataSource: map['dataSource'],
      collection: map['collection'],
      displayField: map['displayField'],
      valueField: map['valueField'],
      validation: map['validation'],
    );
  }

  Map<String, dynamic> toMap() {
    final data = <String, dynamic>{
      'id': id,
      'type': type,
      'label': label,
      'required': required,
    };
    if (options.isNotEmpty) data['options'] = options;
    if (dataSource != null) data['dataSource'] = dataSource;
    if (collection != null) data['collection'] = collection;
    if (displayField != null) data['displayField'] = displayField;
    if (valueField != null) data['valueField'] = valueField;
    if (validation != null) data['validation'] = validation;
    return data;
  }
}

================================================================================

// File: lib\Developer\Hierarchy\hierarchy_panel.dart
import 'package:flutter/material.dart';

import 'hierarchy_repository.dart';
import 'org_node_model.dart';

class HierarchyPanel extends StatefulWidget {
  const HierarchyPanel({super.key});

  @override
  State<HierarchyPanel> createState() => _HierarchyPanelState();
}

class _HierarchyPanelState extends State<HierarchyPanel> {
  // Single fixed tenant
  static const String tenantId = HierarchyRepository.tenantId;

  final HierarchyRepository _repo = HierarchyRepository();
  final List<OrgNodeMeta> _nodes = [];

  bool _loading = false;
  bool _saving = false;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  String? _selectedNodeId;

  OrgNodeMeta? get _selectedNode {
    try {
      return _nodes.firstWhere((n) => n.id == _selectedNodeId);
    } catch (_) {
      return null;
    }
  }

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await _repo.loadHierarchy();
      setState(() {
        _nodes
          ..clear()
          ..addAll(list);
        _selectedNodeId = _nodes.isEmpty ? null : _nodes.first.id;
      });
      _setStatus('Hierarchy loaded (${_nodes.length} nodes)');
    } catch (e) {
      _setStatus('Failed to load hierarchy: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  void _setStatus(String msg, {bool error = false}) {
    setState(() {
      _status = msg;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await _repo.saveHierarchy(_nodes);
      _setStatus('Hierarchy saved for tenant $tenantId');
    } catch (e) {
      _setStatus('Failed to save hierarchy: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  /// Generate node id from name:
  /// 1. lowercase
  /// 2. only letters / digits / space / - / _
  /// 3. spaces and - to _
  String _generateIdFromName(String rawName) {
    final lower = rawName.toLowerCase();
    final buffer = StringBuffer();
    for (final ch in lower.runes) {
      final c = String.fromCharCode(ch);
      final isAlphaNum =
          (c.codeUnitAt(0) >= 97 && c.codeUnitAt(0) <= 122) || // a-z
          (c.codeUnitAt(0) >= 48 && c.codeUnitAt(0) <= 57); // 0-9
      if (isAlphaNum) {
        buffer.write(c);
      } else if (c == ' ' || c == '-' || c == '_') {
        buffer.write('_');
      }
      // other characters are skipped (not allowed)
    }
    var id = buffer.toString();
    id = id.replaceAll(RegExp('_+'), '_').trim();
    if (id.startsWith('_')) id = id.substring(1);
    if (id.endsWith('_')) id = id.substring(0, id.length - 1);
    if (id.isEmpty) {
      id = 'node_${DateTime.now().millisecondsSinceEpoch}';
    }
    return id;
  }

  /// Name validation: only letters, digits, space, - and _.
  String? _validateName(String value) {
    if (value.trim().isEmpty) {
      return 'Name is required';
    }
    final regex = RegExp(r'^[a-zA-Z0-9 _-]+$');
    if (!regex.hasMatch(value)) {
      return 'Only letters, numbers, space, - and _ are allowed';
    }
    return null;
  }

  void _addNode({String? parentId}) {
    final nameController = TextEditingController();
    final typeController = TextEditingController(text: 'organization');
    final levelController = TextEditingController();
    final managerIdController = TextEditingController();
    final designationController = TextEditingController();
    bool isActive = true;

    // compute default level from parent
    int computedLevel = 0;
    if (parentId != null && _nodes.isNotEmpty) {
      final parent = _nodes.firstWhere((n) => n.id == parentId);
      computedLevel = parent.level + 1;
    }
    levelController.text = computedLevel.toString();

    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: const Text(
              'Add Node',
              style: TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 460,
              child: Form(
                key: formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Name (only editable field for id generation)
                    TextFormField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name (e.g. Automation Testing Team)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                      validator: (v) => _validateName(v ?? ''),
                    ),
                    const SizedBox(height: 12),

                    // Parent info (read-only)
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        'Parent: ${parentId ?? '(root node)'}',
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 12,
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),

                    // Type
                    TextFormField(
                      controller: typeController,
                      decoration: const InputDecoration(
                        labelText:
                            'Type (e.g. organization, department, team)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Level
                    TextFormField(
                      controller: levelController,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: 'Level (0 = root)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Manager ID
                    TextFormField(
                      controller: managerIdController,
                      decoration: const InputDecoration(
                        labelText: 'Manager ID (optional)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Designation IDs
                    TextFormField(
                      controller: designationController,
                      decoration: const InputDecoration(
                        labelText:
                            'Designation IDs (comma-separated, e.g. ceo,cto)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Active
                    SwitchListTile(
                      value: isActive,
                      onChanged: (v) =>
                          setDialogState(() => isActive = v),
                      title: const Text(
                        'Active',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (!formKey.currentState!.validate()) return;

                  final rawName = nameController.text.trim();
                  final id = _generateIdFromName(rawName);

                  final level =
                      int.tryParse(levelController.text.trim()) ??
                          computedLevel;

                  final node = OrgNodeMeta(
                    id: id,
                    name: rawName,
                    parentId: parentId,
                    type: typeController.text.trim().isEmpty
                        ? 'organization'
                        : typeController.text.trim(),
                    level: level,
                    managerId:
                        managerIdController.text.trim().isEmpty
                            ? null
                            : managerIdController.text.trim(),
                    designationIds:
                        _splitCsv(designationController.text),
                    isActive: isActive,
                  );

                  setState(() {
                    _nodes.add(node);
                    _selectedNodeId = id;
                  });

                  Navigator.pop(context);
                },
                child: const Text('Add'),
              ),
            ],
          );
        },
      ),
    );
  }

  void _editSelectedNode() {
    final node = _selectedNode;
    if (node == null) return;

  final nameController = TextEditingController(text: node.name);
  final typeController = TextEditingController(text: node.type);
  final managerIdController =
      TextEditingController(text: node.managerId ?? '');
  final designationController =
      TextEditingController(text: node.designationIds.join(', '));

    bool isActive = node.isActive;

    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: const Text(
              'Edit Node',
              style: TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 420,
              child: Form(
                key: formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextFormField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                      validator: (v) => _validateName(v ?? ''),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: typeController,
                      decoration: const InputDecoration(
                        labelText: 'Type',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: managerIdController,
                      decoration: const InputDecoration(
                        labelText: 'Manager ID',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: designationController,
                      decoration: const InputDecoration(
                        labelText:
                            'Designation IDs (comma-separated)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    SwitchListTile(
                      value: isActive,
                      onChanged: (v) =>
                          setDialogState(() => isActive = v),
                      title: const Text(
                        'Active',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (!formKey.currentState!.validate()) return;

                  setState(() {
                    node.name = nameController.text.trim();
                    node.type = typeController.text.trim().isEmpty
                        ? 'organization'
                        : typeController.text.trim();
                    node.managerId =
                        managerIdController.text.trim().isEmpty
                            ? null
                            : managerIdController.text.trim();
                    node.designationIds =
                        _splitCsv(designationController.text);
                    node.isActive = isActive;
                  });
                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  void _deleteSelectedNode() {
    final node = _selectedNode;
    if (node == null) return;

    final roots = _nodes.where((n) => n.parentId == null).toList();
    if (roots.length == 1 && node.parentId == null) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          backgroundColor: const Color(0xFF111118),
          title: const Text(
            'Cannot Delete Last Root Node',
            style: TextStyle(color: Colors.redAccent),
          ),
          content: const Text(
            'The hierarchy must have at least one root node. '
            'Please add another root node before deleting this one.',
            style: TextStyle(color: Colors.white70),
          ),
          actions: [
            FilledButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('OK'),
            ),
          ],
        ),
      );
      return;
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Text(
          'Delete Node?',
          style: TextStyle(color: Colors.orange),
        ),
        content: Text(
          'Delete "${node.name}" and all its children? '
          'This action cannot be undone.',
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Colors.redAccent,
            ),
            onPressed: () {
              Navigator.pop(context);
              _performDelete(node);
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _performDelete(OrgNodeMeta node) {
    final toRemove = <String>{node.id};
    bool changed;

    do {
      changed = false;
      for (final n in _nodes.toList()) {
        if (n.parentId != null && toRemove.contains(n.parentId)) {
          if (toRemove.add(n.id)) changed = true;
        }
      }
    } while (changed);

    setState(() {
      _nodes.removeWhere((n) => toRemove.contains(n.id));
      if (_nodes.isEmpty || toRemove.contains(_selectedNodeId)) {
        _selectedNodeId = _nodes.isEmpty ? null : _nodes.first.id;
      }
    });

    _setStatus('Deleted ${toRemove.length} node(s)');
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Organization Hierarchy Builder',
          style: TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Define org tree used for approvals, reporting, and dynamic queries.',
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Row(
            children: [
              SizedBox(
                width: 280,
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: _buildTreeView(),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: _buildDetails(),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTreeView() {
    if (_nodes.isEmpty) {
      return Column(
        children: [
          OutlinedButton.icon(
            onPressed: () => _addNode(parentId: null),
            icon: const Icon(Icons.add_box_outlined),
            label: const Text('Add Root'),
          ),
          const Expanded(
            child: Center(
              child: Text(
                'No nodes yet.\nCreate a root node.',
                style: TextStyle(color: Colors.white70),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ],
      );
    }

    final roots = _nodes.where((n) => n.parentId == null).toList()
      ..sort((a, b) => a.name.compareTo(b.name));

    List<Widget> buildChildren(String parentId, int indent) {
      final children =
          _nodes.where((n) => n.parentId == parentId).toList()
            ..sort((a, b) => a.name.compareTo(b.name));

      return children
          .map(
            (child) => Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _treeTile(child, indent.toDouble()),
                ...buildChildren(child.id, indent + 16),
              ],
            ),
          )
          .toList();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        OutlinedButton.icon(
          onPressed: () => _addNode(parentId: null),
          icon: const Icon(Icons.add_box_outlined),
          label: const Text('Add Root'),
        ),
        const SizedBox(height: 8),
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: roots
                  .map(
                    (root) => Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _treeTile(root, 0),
                        ...buildChildren(root.id, 16),
                      ],
                    ),
                  )
                  .toList(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _treeTile(OrgNodeMeta node, double indent) {
  final selected = node.id == _selectedNodeId;
  final Color connectorColor =
      node.isActive ? Colors.cyan : Colors.grey; // same as icon

  return GestureDetector(
    onTap: () => setState(() => _selectedNodeId = node.id),
    child: Container(
      margin: const EdgeInsets.symmetric(vertical: 2),
      padding: const EdgeInsets.only(right: 8, top: 2, bottom: 2),
      decoration: BoxDecoration(
        color: selected ? const Color(0xFF1A1A25) : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // connector column
          SizedBox(
            width: indent,
            child: Align(
              alignment: Alignment.topRight,
              child: Container(
                width: 1.5,
                height: 26, // length of the vertical line
                color: node.parentId == null
                    ? Colors.transparent // no line for root
                    : connectorColor.withOpacity(0.7),
              ),
            ),
          ),
          const SizedBox(width: 4),

          // icon + label
          Icon(
            node.parentId == null
                ? Icons.account_tree_rounded
                : Icons.subdirectory_arrow_right_rounded,
            size: 18,
            color: connectorColor,
          ),
          const SizedBox(width: 6),
          Expanded(
            child: Text(
              node.name,
              style: TextStyle(
                color: node.isActive ? Colors.white : Colors.grey,
                fontWeight:
                    selected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    ),
  );
}


  Widget _buildDetails() {
    final node = _selectedNode;

    if (node == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, size: 64, color: Colors.grey[600]),
            const SizedBox(height: 16),
            const Text(
              'Select a node to view or edit details.',
              style: TextStyle(color: Colors.white70, fontSize: 16),
            ),
          ],
        ),
      );
    }

    // READ-ONLY view; editing only via dialog button
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Text(
                'Node Details',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.edit, color: Colors.cyan),
                onPressed: _editSelectedNode,
                tooltip: 'Edit Node',
              ),
              IconButton(
                icon: const Icon(Icons.delete, color: Colors.redAccent),
                onPressed: _deleteSelectedNode,
                tooltip: 'Delete Node',
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Name
          Text(
            'Name',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.name,
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Type
          Text(
            'Type',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.type,
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Manager ID
          Text(
            'Manager ID',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.managerId ?? '-',
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Designation IDs
          Text(
            'Designation IDs',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.designationIds.join(', '),
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Active
          Text(
            'Active',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(
                node.isActive ? Icons.check_circle : Icons.cancel,
                color: node.isActive ? Colors.greenAccent : Colors.redAccent,
                size: 18,
              ),
              const SizedBox(width: 6),
              Text(
                node.isActive ? 'Yes' : 'No',
                style:
                    const TextStyle(color: Colors.white, fontSize: 14),
              ),
            ],
          ),
          const SizedBox(height: 24),

          const Divider(color: Colors.white24),
          const SizedBox(height: 8),
          Text(
            'Node ID: ${node.id}',
            style: TextStyle(color: Colors.grey[600], fontSize: 12),
          ),
          Text(
            'Level: ${node.level}',
            style: TextStyle(color: Colors.grey[600], fontSize: 12),
          ),
          if (node.parentId != null)
            Text(
              'Parent ID: ${node.parentId}',
              style: TextStyle(color: Colors.grey[600], fontSize: 12),
            ),
          const SizedBox(height: 16),
          const Text(
            'Add Child Node',
            style: TextStyle(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          OutlinedButton.icon(
            onPressed: () => _addNode(parentId: node.id),
            icon: const Icon(Icons.add),
            label: const Text('Add Child'),
          ),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\Developer\Hierarchy\hierarchy_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'org_node_model.dart';

class HierarchyRepository {
  final FirebaseFirestore _db;

  HierarchyRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;

  static const String tenantId = 'default_tenant';

  Future<List<OrgNodeMeta>> loadHierarchy() async {
    // 1. Load all docs without Firestore orderBy â†’ no composite index needed
    final snap = await _db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes')
        .get();

    // 2. Map to models
    final nodes = snap.docs
        .map((doc) => OrgNodeMeta.fromMap(doc.id, doc.data()))
        .toList();

    // 3. Apply same ordering in Dart: first by level, then by name
    nodes.sort((a, b) {
      final levelCmp = a.level.compareTo(b.level);
      if (levelCmp != 0) return levelCmp;
      return a.name.compareTo(b.name);
    });

    return nodes;
  }

  Future<void> saveHierarchy(List<OrgNodeMeta> nodes) async {
    final batch = _db.batch();
    final coll = _db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes');

    final existing = await coll.get();
    for (final doc in existing.docs) {
      batch.delete(doc.reference);
    }

    for (final node in nodes) {
      final ref = coll.doc(node.id);
      batch.set(ref, node.toMap());
    }

    await batch.commit();
  }
}

================================================================================

// File: lib\Developer\Hierarchy\org_node_model.dart
class OrgNodeMeta {
  String id;
  String name;
  String? parentId;
  String type;            // organization, department, team, etc.
  int level;              // depth in tree (0 = root)
  String? managerId;      // optional manager user id
  List<String> designationIds;
  bool isActive;

  OrgNodeMeta({
    required this.id,
    required this.name,
    required this.parentId,
    required this.type,
    required this.level,
    required this.managerId,
    required this.designationIds,
    required this.isActive,
  });

  factory OrgNodeMeta.fromMap(String id, Map<String, dynamic> map) {
    return OrgNodeMeta(
      id: id,
      name: map['name'] ?? id,
      parentId: map['parentId'],
      type: map['type'] ?? 'organization',
      level: (map['level'] ?? 0) as int,
      managerId: map['managerId'],
      designationIds: List<String>.from(map['designationIds'] ?? const []),
      isActive: map['isActive'] ?? true,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'parentId': parentId,
      'type': type,
      'level': level,
      'managerId': managerId,
      'designationIds': designationIds,
      'isActive': isActive,
    };
  }

  OrgNodeMeta copyWith({
    String? id,
    String? name,
    String? parentId,
    String? type,
    int? level,
    String? managerId,
    List<String>? designationIds,
    bool? isActive,
  }) {
    return OrgNodeMeta(
      id: id ?? this.id,
      name: name ?? this.name,
      parentId: parentId ?? this.parentId,
      type: type ?? this.type,
      level: level ?? this.level,
      managerId: managerId ?? this.managerId,
      designationIds: designationIds ?? this.designationIds,
      isActive: isActive ?? this.isActive,
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\metadata_panel.dart
import 'package:flutter/material.dart';

import 'metadata_repository.dart';
import 'designation/designation_tab.dart';
import 'role_permission/role_permission_tab.dart';
import 'form_schema/form_schema_tab.dart';

enum MetaType { designations, rolePermissions, formSchemas }

class MetadataPanel extends StatefulWidget {
  const MetadataPanel({super.key});

  @override
  State<MetadataPanel> createState() => _MetadataPanelState();
}

class _MetadataPanelState extends State<MetadataPanel> {
  // Line 13:
  static const String tenantId = 'default_tenant'; // Fixed


  final MetadataRepository _repo = MetadataRepository(); // â† no const

  MetaType _selectedType = MetaType.designations;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  void _setStatus(String message, {bool error = false}) {
    setState(() {
      _status = message;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  @override
  Widget build(BuildContext context) {
    final title = switch (_selectedType) {
      MetaType.designations => 'Metadata Engine â€“ Designations',
      MetaType.rolePermissions => 'Metadata Engine â€“ Role Permissions',
      MetaType.formSchemas => 'Metadata Engine â€“ Form Schemas',
    };

    final subtitle = switch (_selectedType) {
      MetaType.designations =>
          'Manage designation hierarchy, permissions and screen access without editing JSON.',
      MetaType.rolePermissions => 'Map roles to permission lists used by RBAC.',
      MetaType.formSchemas =>
          'Manage system/custom forms and their JSON schemas.',
    };

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          subtitle,
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            DropdownButton<MetaType>(
              value: _selectedType,
              dropdownColor: const Color(0xFF111118),
              onChanged: (v) {
                if (v == null) return;
                setState(() => _selectedType = v);
              },
              items: const [
                DropdownMenuItem(
                  value: MetaType.designations,
                  child: Text('Designations'),
                ),
                DropdownMenuItem(
                  value: MetaType.rolePermissions,
                  child: Text('Role Permissions'),
                ),
                DropdownMenuItem(
                  value: MetaType.formSchemas,
                  child: Text('Form Schemas'),
                ),
              ],
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Card(
            color: const Color(0xFF111118),
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: switch (_selectedType) {
                MetaType.designations => DesignationTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
                MetaType.rolePermissions => RolePermissionTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
                MetaType.formSchemas => FormSchemaTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
              },
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\metadata_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import 'designation/designation_model.dart';
import 'role_permission/role_permission_model.dart';
import 'form_schema/form_schema_model.dart';

class MetadataRepository {
  final FirebaseFirestore _db;

  MetadataRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;
  /* ------------------------------ Designations ----------------------------- */

  Future<List<DesignationMeta>> loadDesignations(String tenantId) async {
  try {
    // FIXED: Correct path structure
    final snap = await _db
        .collection('tenants')
        .doc(tenantId)
        .collection('metadata')
        .doc('designations')
        .get();

    final List<DesignationMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      
      // FIXED: Check if 'designations' key exists
      if (data.containsKey('designations')) {
        final map = data['designations'] as Map<String, dynamic>;
        
        for (final entry in map.entries) {
          result.add(DesignationMeta.fromMap(entry.key, entry.value as Map<String, dynamic>));
        }
      }
    }

    // Seed default if empty
    if (result.isEmpty) {
      result.add(
        DesignationMeta(
          id: 'developer',
          name: 'Developer',
          hierarchyLevel: 1,
          reportsTo: const [],
          permissions: const ['all'],
          screenAccess: const ['developer'],
          requiresApproval: false,
          isRoot: true,
        ),
      );
      
      // AUTO-SAVE the seeded designation
      await saveDesignations(tenantId, result);
    }

    return result;
  } catch (e) {
    debugPrint('âŒ Error loading designations: $e');
    return [];
  }
}
  

  Future<void> saveDesignations(
      String tenantId, List<DesignationMeta> list) async {
    final data = {
      'designations': {for (final d in list) d.id: d.toMap()},
    };

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('designations')
        .set(data);
  }

  /* --------------------------- Role Permissions --------------------------- */

  Future<List<RolePermissionMeta>> loadRolePermissions(
      String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('rolePermissions')
        .get();

    final List<RolePermissionMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final map =
          (data['roles'] ?? <String, dynamic>{}) as Map<String, dynamic>;
      for (final entry in map.entries) {
        result.add(RolePermissionMeta.fromMap(entry.key, entry.value));
      }
    }

    if (result.isEmpty) {
      result.add(RolePermissionMeta(roleId: 'developer_root', permissions: ['*']));
    }

    return result;
  }

  Future<void> saveRolePermissions(
      String tenantId, List<RolePermissionMeta> list) async {
    final data = {
      'roles': {for (final r in list) r.roleId: r.toMap()},
    };

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('rolePermissions')
        .set(data);
  }

  /* ------------------------------ Form Schemas ---------------------------- */

  Future<List<FormSchemaMeta>> loadFormSchemas(String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .get();

    final List<FormSchemaMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final forms =
          (data['forms'] ?? <String, dynamic>{}) as Map<String, dynamic>;

      for (final entry in forms.entries) {
        final m = entry.value as Map<String, dynamic>;
        result.add(FormSchemaMeta.fromFirestore(entry.key, m));
      }
    }

    if (result.isEmpty) {
      // seed with a default user registration form
      result.add(FormSchemaMeta.defaultUserRegistration());
    }

    return result;
  }

  Future<void> saveFormSchemas(
      String tenantId, List<FormSchemaMeta> list) async {
    final forms = <String, dynamic>{};

    for (final f in list) {
      forms[f.formId] = f.toFirestore();
    }

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .set({'forms': forms});
  }
}

================================================================================

// File: lib\Developer\Metadata\designation\designation_model.dart
class DesignationMeta {
  String id;
  String name;
  int hierarchyLevel;
  List<String> reportsTo;
  List<String> permissions;
  List<String> screenAccess;
  bool requiresApproval;
  bool isRoot;

  DesignationMeta({
    required this.id,
    required this.name,
    required this.hierarchyLevel,
    required this.reportsTo,
    required this.permissions,
    required this.screenAccess,
    required this.requiresApproval,
    required this.isRoot,
  });

  factory DesignationMeta.fromMap(String id, Map<String, dynamic> map) {
    return DesignationMeta(
      id: id,
      name: map['name'] ?? '',
      hierarchyLevel: (map['hierarchy_level'] ?? 0) as int,
      reportsTo: List<String>.from(map['reports_to'] ?? const []),
      permissions: List<String>.from(map['permissions'] ?? const []),
      screenAccess: List<String>.from(map['screen_access'] ?? const []),
      requiresApproval: map['requires_approval'] ?? false,
      isRoot: map['is_root'] ?? false,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'hierarchy_level': hierarchyLevel,
      'reports_to': reportsTo,
      'permissions': permissions,
      'screen_access': screenAccess,
      'requires_approval': requiresApproval,
      'is_root': isRoot,
    };
  }
}

================================================================================

// File: lib\Developer\Metadata\designation\designation_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'designation_model.dart';

class DesignationTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const DesignationTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<DesignationTab> createState() => _DesignationTabState();
}

class _DesignationTabState extends State<DesignationTab> {
  final List<DesignationMeta> _designations = [];
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
  setState(() => _loading = true);
  
  try {
    debugPrint('ğŸ”„ Loading designations for tenant: ${widget.tenantId}');
    
    final list = await widget.repo.loadDesignations(widget.tenantId);
    
    debugPrint('âœ… Loaded ${list.length} designations:');
    for (final d in list) {
      debugPrint('   - ${d.id}: ${d.name} (level ${d.hierarchyLevel})');
    }
    
    setState(() {
      _designations
        ..clear()
        ..addAll(list);
    });
    
    widget.setStatus('${list.length} Designations loaded', error: false);
  } catch (e, stackTrace) {
    debugPrint('âŒ Error loading designations: $e');
    debugPrint('Stack trace: $stackTrace');
    widget.setStatus('Failed to load designations: $e', error: true);
  } finally {
    setState(() => _loading = false);
  }
}


  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveDesignations(widget.tenantId, _designations);
      widget.setStatus('Designations saved');
    } catch (e) {
      widget.setStatus('Failed to save designations: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _openDialog({DesignationMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.id ?? '');
    final nameController = TextEditingController(text: existing?.name ?? '');
    final levelController =
        TextEditingController(text: (existing?.hierarchyLevel ?? 1).toString());
    final reportsToController =
        TextEditingController(text: (existing?.reportsTo ?? []).join(', '));
    final permissionsController =
        TextEditingController(text: (existing?.permissions ?? []).join(', '));
    final screensController =
        TextEditingController(text: (existing?.screenAccess ?? []).join(', '));
    bool requiresApproval = existing?.requiresApproval ?? false;
    bool isRoot = existing?.isRoot ?? false;

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: Text(
              isNew ? 'Add Designation' : 'Edit Designation',
              style: const TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 480,
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    // ID
                    TextField(
                      controller: idController,
                      enabled: isNew,
                      decoration: const InputDecoration(
                        labelText: 'ID (e.g. developer)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Name
                    TextField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Hierarchy level
                    TextField(
                      controller: levelController,
                      decoration: const InputDecoration(
                        labelText: 'Hierarchy Level',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      keyboardType: TextInputType.number,
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Reports to
                    TextField(
                      controller: reportsToController,
                      decoration: const InputDecoration(
                        labelText: 'Reports To (comma-separated IDs)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Permissions
                    TextField(
                      controller: permissionsController,
                      decoration: const InputDecoration(
                        labelText: 'Permissions (comma-separated)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Screen access
                    TextField(
                      controller: screensController,
                      decoration: const InputDecoration(
                        labelText:
                            'Screen Access (comma-separated, e.g. developer, admin)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Switches
                    SwitchListTile(
                      value: requiresApproval,
                      onChanged: (v) =>
                          setDialogState(() => requiresApproval = v),
                      title: const Text(
                        'Requires Approval',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                    SwitchListTile(
                      value: isRoot,
                      onChanged: (v) => setDialogState(() => isRoot = v),
                      title: const Text(
                        'Root Access (Full System Control)',
                        style: TextStyle(color: Colors.white),
                      ),
                      subtitle: const Text(
                        'Root designations can manage all tenants, metadata and workflows.',
                        style: TextStyle(color: Colors.grey),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  final id = idController.text.trim();
                  if (id.isEmpty) return;

                  final designation = DesignationMeta(
                    id: id,
                    name: nameController.text.trim(),
                    hierarchyLevel:
                        int.tryParse(levelController.text.trim()) ?? 1,
                    reportsTo: _splitCsv(reportsToController.text),
                    permissions: _splitCsv(permissionsController.text),
                    screenAccess: _splitCsv(screensController.text),
                    requiresApproval: requiresApproval,
                    isRoot: isRoot,
                  );

                  setState(() {
                    if (isNew) {
                      _designations.add(designation);
                    } else {
                      final index =
                          _designations.indexWhere((element) => element.id == id);
                      if (index != -1) {
                        _designations[index] = designation;
                      }
                    }
                  });

                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () => _openDialog(),
              icon: const Icon(Icons.add),
              label: const Text('Add Designation'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('ID')),
                DataColumn(label: Text('Name')),
                DataColumn(label: Text('Level')),
                DataColumn(label: Text('Screens')),
                DataColumn(label: Text('Root')),
                DataColumn(label: Text('Requires Approval')),
                DataColumn(label: Text('Actions')),
              ],
              rows: _designations.map((d) {
                return DataRow(
                  cells: [
                    DataCell(Text(d.id)),
                    DataCell(Text(d.name)),
                    DataCell(Text(d.hierarchyLevel.toString())),
                    DataCell(Text(d.screenAccess.join(', '))),
                    DataCell(
                      Icon(
                        d.isRoot
                            ? Icons.stars
                            : Icons.remove_circle_outline,
                        color:
                            d.isRoot ? Colors.purpleAccent : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Icon(
                        d.requiresApproval
                            ? Icons.check_circle
                            : Icons.cancel,
                        color: d.requiresApproval
                            ? Colors.orange
                            : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () => _openDialog(existing: d),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                _designations
                                    .removeWhere((x) => x.id == d.id);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\form_schema\form_schema_model.dart
import 'dart:convert';

/* High-level form definition */

class FormSchemaMeta {
  String formId;
  String name;
  String description;
  List<FormFieldMeta> fields;

  FormSchemaMeta({
    required this.formId,
    required this.name,
    required this.description,
    required this.fields,
  });

  factory FormSchemaMeta.fromFirestore(
      String id, Map<String, dynamic> map) {
    final schema = map['schema'] ?? {};
    final fieldsJson = (schema['fields'] ?? []) as List<dynamic>;

    return FormSchemaMeta(
      formId: id,
      name: map['name'] ?? id,
      description: map['description'] ?? '',
      fields: fieldsJson
          .map((e) => FormFieldMeta.fromMap(e as Map<String, dynamic>))
          .toList(),
    );
  }

  /// Convert back to Firestore document structure:
  /// { name, description, schema: { formId, version, fields: [...] } }
  Map<String, dynamic> toFirestore() {
    final schema = {
      'formId': formId,
      'version': 1,
      'fields': fields.map((f) => f.toMap()).toList(),
    };

    return {
      'name': name,
      'description': description,
      'schema': schema,
    };
  }

  static FormSchemaMeta defaultUserRegistration() {
    return FormSchemaMeta(
      formId: 'user_registration',
      name: 'User Registration Form',
      description: 'New user signup with designation + department',
      fields: [
        FormFieldMeta(
          id: 'fullName',
          type: 'text',
          label: 'Full Name',
          required: true,
        ),
        FormFieldMeta(
          id: 'email',
          type: 'email',
          label: 'Email Address',
          required: true,
        ),
      ],
    );
  }
}

/* Per-field metadata â€“ this is what the UI edits */

class FormFieldMeta {
  String id;
  String type; // text, email, password, dropdown, checkbox, date, etc.[file:2]
  String label;
  bool required;
  List<String> options; // used when type == dropdown (static options)

  FormFieldMeta({
    required this.id,
    required this.type,
    required this.label,
    this.required = false,
    List<String>? options,
  }) : options = options ?? [];

  factory FormFieldMeta.fromMap(Map<String, dynamic> map) {
    return FormFieldMeta(
      id: map['id'] ?? '',
      type: map['type'] ?? 'text',
      label: map['label'] ?? '',
      required: map['required'] ?? false,
      options: List<String>.from(map['options'] ?? const []),
    );
  }

  Map<String, dynamic> toMap() {
    final data = <String, dynamic>{
      'id': id,
      'type': type,
      'label': label,
      'required': required,
    };
    if (options.isNotEmpty) {
      data['options'] = options;
    }
    return data;
  }
}

================================================================================

// File: lib\Developer\Metadata\form_schema\form_schema_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'form_schema_model.dart';

class FormSchemaTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const FormSchemaTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<FormSchemaTab> createState() => _FormSchemaTabState();
}

class _FormSchemaTabState extends State<FormSchemaTab> {
  final List<FormSchemaMeta> _forms = [];
  int _selectedIndex = 0;
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await widget.repo.loadFormSchemas(widget.tenantId);
      setState(() {
        _forms
          ..clear()
          ..addAll(list);
        _selectedIndex = _forms.isEmpty ? 0 : 0;
      });
      widget.setStatus('Form schemas loaded');
    } catch (e) {
      widget.setStatus('Failed to load form schemas: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveFormSchemas(widget.tenantId, _forms);
      widget.setStatus('Form schemas saved');
    } catch (e) {
      widget.setStatus('Failed to save form schemas: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _createForm() {
    final idController = TextEditingController();
    final nameController = TextEditingController();
    final descController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Text(
          'Create New Form',
          style: TextStyle(color: Colors.white),
        ),
        content: SizedBox(
          width: 420,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: idController,
                decoration: const InputDecoration(labelText: 'Form ID'),
                style: const TextStyle(color: Colors.white),
              ),
              TextField(
                controller: nameController,
                decoration: const InputDecoration(labelText: 'Name'),
                style: const TextStyle(color: Colors.white),
              ),
              TextField(
                controller: descController,
                decoration:
                    const InputDecoration(labelText: 'Description'),
                style: const TextStyle(color: Colors.white),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              final id = idController.text.trim();
              if (id.isEmpty) return;

              setState(() {
                _forms.add(
                  FormSchemaMeta(
                    formId: id,
                    name: nameController.text.trim().isEmpty
                        ? id
                        : nameController.text.trim(),
                    description: descController.text.trim(),
                    fields: [
                      // start with one text field as template
                      FormFieldMeta(
                        id: 'field1',
                        type: 'text',
                        label: 'Field 1',
                        required: false,
                      ),
                    ],
                  ),
                );
                _selectedIndex = _forms.length - 1;
              });

              Navigator.pop(context);
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  void _openFieldDialog(FormSchemaMeta form, {FormFieldMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.id ?? '');
    final labelController = TextEditingController(text: existing?.label ?? '');
    String type = existing?.type ?? 'text';
    bool required = existing?.required ?? false;
    final optionsController =
        TextEditingController(text: (existing?.options ?? []).join(', '));

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: Text(
              isNew ? 'Add Field' : 'Edit Field',
              style: const TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 420,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextField(
                    controller: idController,
                    enabled: isNew,
                    decoration: const InputDecoration(
                      labelText: 'Field ID (e.g. fullName)',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    style: const TextStyle(color: Colors.white),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: labelController,
                    decoration: const InputDecoration(
                      labelText: 'Label',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    style: const TextStyle(color: Colors.white),
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: type,
                    dropdownColor: const Color(0xFF111118),
                    decoration: const InputDecoration(
                      labelText: 'Field Type',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'text',
                        child: Text('Text'),
                      ),
                      DropdownMenuItem(
                        value: 'email',
                        child: Text('Email'),
                      ),
                      DropdownMenuItem(
                        value: 'password',
                        child: Text('Password'),
                      ),
                      DropdownMenuItem(
                        value: 'dropdown',
                        child: Text('Dropdown (static)'),
                      ),
                      DropdownMenuItem(
                        value: 'checkbox',
                        child: Text('Checkbox'),
                      ),
                      DropdownMenuItem(
                        value: 'date',
                        child: Text('Date'),
                      ),
                    ],
                    onChanged: (v) =>
                        setDialogState(() => type = v ?? 'text'),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    value: required,
                    onChanged: (v) =>
                        setDialogState(() => required = v),
                    title: const Text(
                      'Required',
                      style: TextStyle(color: Colors.white),
                    ),
                    contentPadding: EdgeInsets.zero,
                  ),
                  if (type == 'dropdown') ...[
                    const SizedBox(height: 8),
                    TextField(
                      controller: optionsController,
                      decoration: const InputDecoration(
                        labelText:
                            'Options (comma-separated, for dropdown)',
                        floatingLabelBehavior:
                            FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                  ],
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  final id = idController.text.trim();
                  if (id.isEmpty) return;

                  final field = FormFieldMeta(
                    id: id,
                    type: type,
                    label: labelController.text.trim().isEmpty
                        ? id
                        : labelController.text.trim(),
                    required: required,
                    options: _splitCsv(optionsController.text),
                  );

                  setState(() {
                    if (isNew) {
                      form.fields.add(field);
                    } else {
                      final idx = form.fields
                          .indexWhere((element) => element.id == id);
                      if (idx != -1) form.fields[idx] = field;
                    }
                  });

                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    final hasForms = _forms.isNotEmpty;

    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: _createForm,
              icon: const Icon(Icons.add),
              label: const Text('Create Form'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: hasForms
              ? Row(
                  children: [
                    // LEFT: form list
                    SizedBox(
                      width: 260,
                      child: ListView.builder(
                        itemCount: _forms.length,
                        itemBuilder: (context, index) {
                          final f = _forms[index];
                          final selected = index == _selectedIndex;
                          return ListTile(
                            selected: selected,
                            selectedTileColor:
                                const Color(0xFF1A1A25),
                            title: Text(
                              f.formId,
                              style: TextStyle(
                                color: selected
                                    ? Colors.cyan
                                    : Colors.white,
                                fontWeight: selected
                                    ? FontWeight.bold
                                    : FontWeight.normal,
                              ),
                            ),
                            subtitle: Text(
                              f.name,
                              style: const TextStyle(
                                  color: Colors.grey, fontSize: 12),
                            ),
                            trailing: IconButton(
                              icon: const Icon(Icons.delete,
                                  size: 18,
                                  color: Colors.redAccent),
                              onPressed: () {
                                setState(() {
                                  _forms.removeAt(index);
                                  if (_selectedIndex >=
                                      _forms.length) {
                                    _selectedIndex =
                                        (_forms.length - 1)
                                            .clamp(0, 999);
                                  }
                                });
                              },
                            ),
                            onTap: () =>
                                setState(() => _selectedIndex = index),
                          );
                        },
                      ),
                    ),
                    const SizedBox(width: 12),

                    // RIGHT: form editor (name + description + fields table)
                    Expanded(
                      child: _buildFormEditor(_forms[_selectedIndex]),
                    ),
                  ],
                )
              : const Center(
                  child: Text(
                    'No forms defined yet.',
                    style: TextStyle(color: Colors.white70),
                  ),
                ),
        ),
      ],
    );
  }

  Widget _buildFormEditor(FormSchemaMeta form) {
    final nameController = TextEditingController(text: form.name);
    final descController =
        TextEditingController(text: form.description);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Editing form: ${form.formId}',
          style: const TextStyle(color: Colors.white, fontSize: 16),
        ),
        const SizedBox(height: 8),
        TextField(
          controller: nameController,
          decoration: const InputDecoration(labelText: 'Name'),
          style: const TextStyle(color: Colors.white),
          onChanged: (v) => form.name = v,
        ),
        const SizedBox(height: 8),
        TextField(
          controller: descController,
          decoration: const InputDecoration(labelText: 'Description'),
          style: const TextStyle(color: Colors.white),
          onChanged: (v) => form.description = v,
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            const Text(
              'Fields',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            const Spacer(),
            OutlinedButton.icon(
              onPressed: () => _openFieldDialog(form),
              icon: const Icon(Icons.add),
              label: const Text('Add Field'),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('ID')),
                DataColumn(label: Text('Label')),
                DataColumn(label: Text('Type')),
                DataColumn(label: Text('Required')),
                DataColumn(label: Text('Options')),
                DataColumn(label: Text('Actions')),
              ],
              rows: form.fields.map((f) {
                return DataRow(
                  cells: [
                    DataCell(Text(f.id)),
                    DataCell(Text(f.label)),
                    DataCell(Text(f.type)),
                    DataCell(
                      Icon(
                        f.required
                            ? Icons.check_circle
                            : Icons.cancel,
                        color: f.required
                            ? Colors.orange
                            : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Text(
                        f.options.isEmpty
                            ? 'â€”'
                            : f.options.join(', '),
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () =>
                                _openFieldDialog(form, existing: f),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                form.fields
                                    .removeWhere((x) => x.id == f.id);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\role_permission\role_permission_model.dart
class RolePermissionMeta {
  String roleId;
  List<String> permissions;
  String description;

  RolePermissionMeta({
    required this.roleId,
    required this.permissions,
    this.description = '',
  });

  factory RolePermissionMeta.fromMap(String id, Map<String, dynamic> map) {
    return RolePermissionMeta(
      roleId: id,
      permissions: List<String>.from(map['permissions'] ?? const []),
      description: map['description'] ?? '',
    );
  }

  Map<String, dynamic> toMap() => {
        'permissions': permissions,
        'description': description,
      };
}

================================================================================

// File: lib\Developer\Metadata\role_permission\role_permission_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'role_permission_model.dart';

class RolePermissionTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const RolePermissionTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<RolePermissionTab> createState() => _RolePermissionTabState();
}

class _RolePermissionTabState extends State<RolePermissionTab> {
  final List<RolePermissionMeta> _roles = [];
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await widget.repo.loadRolePermissions(widget.tenantId);
      setState(() {
        _roles
          ..clear()
          ..addAll(list);
      });
      widget.setStatus('Role permissions loaded');
    } catch (e) {
      widget.setStatus('Failed to load role permissions: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveRolePermissions(widget.tenantId, _roles);
      widget.setStatus('Role permissions saved');
    } catch (e) {
      widget.setStatus('Failed to save role permissions: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _openDialog({RolePermissionMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.roleId ?? '');
    final permsController =
        TextEditingController(text: (existing?.permissions ?? []).join(', '));
    final descController =
        TextEditingController(text: existing?.description ?? '');

    // Pre-fill description for well-known roles if creating new.[file:2]
    void seedDefaultDescription(String roleId) {
      if (existing != null) return;
      switch (roleId) {
        case 'developer':
        case 'developer_root':
          descController.text =
              'Can manage all metadata, organizations, workflows; root access.';
          break;
        case 'admin':
          descController.text =
              'Can manage users, forms, workflows inside assigned org.';
          break;
        case 'manager':
          descController.text =
              'Can create/assign tasks, approve within hierarchy, view team.';
          break;
        case 'employee':
          descController.text =
              'Can view and complete assigned tasks, request approvals.';
          break;
      }
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: Text(
          isNew ? 'Add Role' : 'Edit Role',
          style: const TextStyle(color: Colors.white),
        ),
        content: SizedBox(
          width: 460,
          child: SingleChildScrollView(
            child: Column(
              children: [
                TextField(
                  controller: idController,
                  enabled: isNew,
                  decoration: const InputDecoration(
                    labelText: 'Role ID (e.g. developer, admin)',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  style: const TextStyle(color: Colors.white),
                  onChanged: (v) => seedDefaultDescription(v.trim()),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: permsController,
                  decoration: const InputDecoration(
                    labelText: 'Permissions (comma-separated)',
                    hintText:
                        'create_org, manage_metadata, approve_tasks, view_reports',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  style: const TextStyle(color: Colors.white),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: descController,
                  decoration: const InputDecoration(
                    labelText: 'Description (what this role can do)',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  maxLines: 3,
                  style: const TextStyle(color: Colors.white),
                ),
              ],
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              final id = idController.text.trim();
              if (id.isEmpty) return;

              final meta = RolePermissionMeta(
                roleId: id,
                permissions: _splitCsv(permsController.text),
                description: descController.text.trim(),
              );

              setState(() {
                if (isNew) {
                  _roles.add(meta);
                } else {
                  final idx =
                      _roles.indexWhere((element) => element.roleId == id);
                  if (idx != -1) _roles[idx] = meta;
                }
              });

              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () => _openDialog(),
              icon: const Icon(Icons.add),
              label: const Text('Add Role'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('Role ID')),
                DataColumn(label: Text('Permissions')),
                DataColumn(label: Text('Description')),
                DataColumn(label: Text('Actions')),
              ],
              rows: _roles.map((r) {
                return DataRow(
                  cells: [
                    DataCell(Text(r.roleId)),
                    DataCell(Text(r.permissions.join(', '))),
                    DataCell(
                      Tooltip(
                        message: r.description,
                        child: Text(
                          r.description.isEmpty
                              ? 'â€”'
                              : (r.description.length > 40
                                  ? '${r.description.substring(0, 40)}â€¦'
                                  : r.description),
                        ),
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () => _openDialog(existing: r),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                _roles.removeWhere(
                                    (x) => x.roleId == r.roleId);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabasemodel.dart
// lib/Screen/Developer/UserDatabase/userdatabasemodel.dart

class CSVUserData {
  String email;
  String password;
  String fullName;
  String nodeId;
  int level;
  String designation;
  String employeeType; // New 7th Column

  CSVUserData({
    required this.email,
    required this.password,
    required this.fullName,
    required this.nodeId,
    required this.level,
    required this.designation,
    required this.employeeType,
  });

  factory CSVUserData.fromCSVRow(List<String> row) {
    // Now requires 7 columns
    if (row.length < 7) {
      throw Exception('CSV row must have 7 columns: email, password, fullName, nodeId, level, designation, employeeType');
    }
    return CSVUserData(
      email: row[0].trim(),
      password: row[1].trim(),
      fullName: row[2].trim(),
      nodeId: row[3].trim(),
      level: int.tryParse(row[4].trim()) ?? 0,
      designation: row[5].trim(),
      employeeType: row[6].trim(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'email': email,
      'password': password,
      'fullName': fullName,
      'nodeId': nodeId,
      'level': level,
      'designation': designation,
      'employeeType': employeeType,
    };
  }
}

/// Helper class to store Old vs New values for UI display
class UserDiff {
  final String email;
  final Map<String, Map<String, dynamic>> changes; // Key: fieldName, Value: {'old': ..., 'new': ...}

  UserDiff({required this.email, required this.changes});
}

class ValidationResult {
  bool isValid;
  List<String> errors;
  List<String> warnings;
  List<String> validNodeIds;
  List<String> invalidNodeIds;
  
  // Lists for processing
  List<CSVUserData> newUsers;
  List<CSVUserData> usersToUpdate;
  List<CSVUserData> authConflicts;
  List<UserDiff> diffs; // Specific changes for the UI

  ValidationResult({
    required this.isValid,
    required this.errors,
    required this.warnings,
    required this.validNodeIds,
    required this.invalidNodeIds,
    required this.newUsers,
    required this.usersToUpdate,
    required this.diffs,
    required this.authConflicts
  });
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabasepanel.dart
// lib/Screen/Developer/UserDatabase/userdatabasepanel.dart

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:csv/csv.dart';
import 'dart:io';
import 'userdatabaserepository.dart';
import 'userdatabasemodel.dart';

class UserDatabasePanel extends StatefulWidget {
  const UserDatabasePanel({super.key});

  @override
  State<UserDatabasePanel> createState() => _UserDatabasePanelState();
}

class _UserDatabasePanelState extends State<UserDatabasePanel> {
  // Ensure this matches your Firestore structure exactly
  static const String tenantId = 'default_tenant'; 
  final UserDatabaseRepository repo = UserDatabaseRepository();

  List<Map<String, dynamic>> hierarchyNodes = [];
  String? selectedNodeId;
  List<Map<String, dynamic>> nodeUsers = [];
  bool loading = false;
  String? status;
  Color statusColor = Colors.greenAccent;

  @override
  void initState() {
    super.initState();
    print("--- UI DEBUG: Init State - Loading Hierarchy for $tenantId ---");
    loadHierarchy();
  }

  Future<void> loadHierarchy() async {
    setState(() => loading = true);
    try {
      final nodes = await repo.loadHierarchyWithUserCounts(tenantId);
      print("--- UI DEBUG: Hierarchy Loaded - ${nodes.length} nodes found ---");
      setState(() {
        hierarchyNodes = nodes;
        status = 'Loaded ${nodes.length} nodes';
        statusColor = Colors.greenAccent;
      });
    } catch (e) {
      print("--- UI DEBUG: Hierarchy Error: $e ---");
      setState(() {
        status = 'Error: $e';
        statusColor = Colors.redAccent;
      });
    } finally {
      setState(() => loading = false);
    }
  }

  Future<void> loadNodeUsers(String nodeId) async {
    print("--- UI DEBUG: Loading Users for Node ID: $nodeId ---");
    setState(() => loading = true);
    try {
      final users = await repo.loadUsersByNode(tenantId, nodeId);
      print("--- UI DEBUG: Node Users Loaded - ${users.length} users found ---");
      setState(() {
        selectedNodeId = nodeId;
        nodeUsers = users;
        status = 'Loaded ${users.length} users';
        statusColor = Colors.greenAccent;
      });
    } catch (e) {
      print("--- UI DEBUG: Node User Error: $e ---");
      setState(() {
        status = 'Error: $e';
        statusColor = Colors.redAccent;
      });
    } finally {
      setState(() => loading = false);
    }
  }

  Future<void> pickAndUploadCSV() async {
    try {
      print("--- UI DEBUG: STARTING CSV PICK ---");
      
      // Pick CSV file
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['csv'],
        withData: true,
      );

      if (result == null || result.files.isEmpty) {
        print("--- UI DEBUG: File Picker Cancelled ---");
        return;
      }

      final csvData = result.files.first.bytes;
      if (csvData == null) {
        print("--- UI DEBUG: Failed to read bytes from file ---");
        showError('Failed to read file');
        return;
      }

      // Parse CSV
      final csvString = String.fromCharCodes(csvData);
      print("--- UI DEBUG: CSV Raw String Length: ${csvString.length} ---");
      
      final List<List<dynamic>> csvTable =
          const CsvToListConverter().convert(csvString);

      print("--- UI DEBUG: CSV Parsed Rows: ${csvTable.length} ---");

      if (csvTable.isEmpty || csvTable.length < 2) {
        showError('CSV file is empty or has no data rows');
        return;
      }

      // Skip header row and parse
      final List<CSVUserData> users = [];
      for (int i = 1; i < csvTable.length; i++) {
        try {
          final row = csvTable[i].map((e) => e.toString()).toList();
          if (row.every((e) => e.trim().isEmpty)) continue; // Skip empty lines
          users.add(CSVUserData.fromCSVRow(row));
        } catch (e) {
          print("--- UI DEBUG: Error parsing row ${i + 1}: $e ---");
          showError('Error parsing row ${i + 1}: $e');
          return;
        }
      }

      print("--- UI DEBUG: Successfully parsed ${users.length} User Objects ---");
      if (users.isNotEmpty) {
        print("--- UI DEBUG: Sample User 1 Email: ${users.first.email} ---");
        print("--- UI DEBUG: Sample User 1 Node: ${users.first.nodeId} ---");
      }

      if (users.isEmpty) {
        showError('No valid users found in CSV');
        return;
      }

      // Validate CSV data
      setState(() {
        loading = true;
        status = 'Validating ${users.length} users...';
      });

      print("--- UI DEBUG: Calling Repo validateCSVData ---");
      final validation = await repo.validateCSVData(tenantId, users);

      print("--- UI DEBUG: VALIDATION RETURNED ---");
      print("   > IsValid: ${validation.isValid}");
      print("   > New Users: ${validation.newUsers.length}");
      print("   > Updates: ${validation.usersToUpdate.length}");
      print("   > Diffs Found: ${validation.diffs.length}");
      print("   > Errors: ${validation.errors.length}");

      setState(() => loading = false);

      if (!validation.isValid) {
        showValidationErrorDialog(validation);
        return;
      }

      // Show the Diff Review Dialog instead of simple confirmation
      showDiffReviewDialog(validation);

    } catch (e) {
      print("--- UI DEBUG: FATAL EXCEPTION IN PICKER: $e ---");
      showError('Failed to process CSV: $e');
    }
  }

  void showValidationErrorDialog(ValidationResult validation) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Row(
          children: [
            Icon(Icons.error_outline, color: Colors.redAccent),
            SizedBox(width: 12),
            Text('CSV Validation Failed', style: TextStyle(color: Colors.white)),
          ],
        ),
        content: SizedBox(
          width: 600,
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Found ${validation.errors.length} errors:',
                  style: const TextStyle(
                    color: Colors.redAccent,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 12),
                ...validation.errors.map(
                  (error) => Padding(
                    padding: const EdgeInsets.only(bottom: 8.0),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text('â€¢ ', style: TextStyle(color: Colors.red)),
                        Expanded(
                          child: Text(
                            error,
                            style: const TextStyle(color: Colors.white70),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (validation.warnings.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  Text(
                    '${validation.warnings.length} warnings:',
                    style: const TextStyle(
                      color: Colors.orangeAccent,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  ...validation.warnings.take(5).map(
                    (warning) => Padding(
                      padding: const EdgeInsets.only(bottom: 8.0),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text('âš  ',
                              style: TextStyle(color: Colors.orange)),
                          Expanded(
                            child: Text(
                              warning,
                              style: const TextStyle(color: Colors.white70),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (validation.warnings.length > 5)
                     Padding(
                       padding: const EdgeInsets.only(left: 20),
                       child: Text(
                         '...and ${validation.warnings.length - 5} more warnings',
                         style: const TextStyle(color: Colors.white30, fontStyle: FontStyle.italic),
                       ),
                     )
                ],
              ],
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close', style: TextStyle(color: Colors.cyan)),
          ),
        ],
      ),
    );
  }

  void showDiffReviewDialog(ValidationResult validation) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => DiffReviewDialog(
        validation: validation,
        onConfirm: () {
          Navigator.pop(context);
          // Only import NEW and UPDATES. Skip Conflicts.
          importUsers([...validation.newUsers, ...validation.usersToUpdate]);
        },
      ),
    );
  }

  Future<void> importUsers(List<CSVUserData> users) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => ImportProgressDialog(
        tenantId: tenantId,
        users: users,
        repo: repo,
        onComplete: () {
          print("--- UI DEBUG: Import Completed, Refreshing Data ---");
          loadHierarchy();
          if (selectedNodeId != null) {
            loadNodeUsers(selectedNodeId!);
          }
        },
      ),
    );
  }

  void showError(String message) {
    setState(() {
      status = message;
      statusColor = Colors.redAccent;
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.redAccent,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header
        Row(
          children: [
            const Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'User Database',
                    style: TextStyle(
                      fontSize: 24,
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    'Import users (New or Update) via CSV',
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            ),
            // Upload button on top right
            FilledButton.icon(
              onPressed: loading ? null : pickAndUploadCSV,
              icon: const Icon(Icons.upload_file),
              label: const Text('Upload CSV'),
              style: FilledButton.styleFrom(
                backgroundColor: Colors.cyan,
                foregroundColor: Colors.black,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),

        // Status bar
        if (status != null)
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: statusColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: statusColor.withOpacity(0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.info_outline, color: statusColor, size: 16),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    status!,
                    style: TextStyle(color: statusColor, fontSize: 12),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close, size: 16),
                  onPressed: () => setState(() => status = null),
                  color: statusColor,
                ),
              ],
            ),
          ),
        const SizedBox(height: 16),

        // Main content
        Expanded(
          child: Row(
            children: [
              // Left: Hierarchy tree
              SizedBox(
                width: 320,
                child: Card(
                  color: const Color(0xFF111118),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Row(
                          children: [
                            const Text(
                              'Organization Hierarchy',
                              style: TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                                fontSize: 16,
                              ),
                            ),
                            const Spacer(),
                            IconButton(
                              icon: const Icon(Icons.refresh, size: 18),
                              onPressed: loading ? null : loadHierarchy,
                              color: Colors.cyan,
                            ),
                          ],
                        ),
                      ),
                      const Divider(color: Colors.white12, height: 1),
                      Expanded(
                        child: loading && hierarchyNodes.isEmpty
                            ? const Center(
                                child: CircularProgressIndicator(
                                  color: Colors.cyan,
                                ),
                              )
                            : hierarchyNodes.isEmpty
                                ? const Center(
                                    child: Text(
                                      'No nodes found',
                                      style:
                                          TextStyle(color: Colors.white70),
                                    ),
                                  )
                                : ListView.builder(
                                    itemCount: hierarchyNodes.length,
                                    itemBuilder: (context, index) {
                                      final node = hierarchyNodes[index];
                                      final isSelected =
                                          selectedNodeId == node['id'];
                                      return ListTile(
                                        selected: isSelected,
                                        selectedTileColor:
                                            const Color(0xFF1A1A25),
                                        leading: Icon(
                                          Icons.account_tree_rounded,
                                          color: isSelected
                                              ? Colors.cyan
                                              : Colors.grey,
                                          size: 20,
                                        ),
                                        title: Text(
                                          node['name'] ?? 'Unknown',
                                          style: TextStyle(
                                            color: isSelected
                                                ? Colors.cyan
                                                : Colors.white,
                                            fontWeight: isSelected
                                                ? FontWeight.bold
                                                : FontWeight.normal,
                                          ),
                                        ),
                                        subtitle: Text(
                                          'Level ${node['level']} â€¢ ${node['userCount'] ?? 0} users',
                                          style: const TextStyle(
                                            color: Colors.white54,
                                            fontSize: 11,
                                          ),
                                        ),
                                        onTap: () =>
                                            loadNodeUsers(node['id']),
                                      );
                                    },
                                  ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(width: 16),

              // Right: Node users
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Text(
                          selectedNodeId == null
                              ? 'Select a node to view users'
                              : 'Users in ${hierarchyNodes.firstWhere(
                                  (n) => n['id'] == selectedNodeId,
                                  orElse: () => {'name': 'Node'},
                                )['name']}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                            fontSize: 16,
                          ),
                        ),
                      ),
                      const Divider(color: Colors.white12, height: 1),
                      Expanded(
                        child: selectedNodeId == null
                            ? const Center(
                                child: Column(
                                  mainAxisAlignment:
                                      MainAxisAlignment.center,
                                  children: [
                                    Icon(
                                      Icons.arrow_back,
                                      size: 48,
                                      color: Colors.white24,
                                    ),
                                    SizedBox(height: 16),
                                    Text(
                                      'Click a node on the left',
                                      style:
                                          TextStyle(color: Colors.white54),
                                    ),
                                  ],
                                ),
                              )
                            : loading
                                ? const Center(
                                    child: CircularProgressIndicator(
                                      color: Colors.cyan,
                                    ),
                                  )
                                : nodeUsers.isEmpty
                                    ? const Center(
                                        child: Text(
                                          'No users in this node',
                                          style: TextStyle(
                                              color: Colors.white70),
                                        ),
                                      )
                                    : ListView.separated(
                                        itemCount: nodeUsers.length,
                                        separatorBuilder: (_, __) =>
                                            const Divider(
                                                color: Colors.white12),
                                        itemBuilder: (context, index) {
                                          final user = nodeUsers[index];
                                          final profile =
                                              user['profiledata']
                                                      as Map? ??
                                                  {};

                                          return ListTile(
                                            leading: CircleAvatar(
                                              backgroundColor: Colors.cyan
                                                  .withOpacity(0.2),
                                              child: Text(
                                                (profile['fullName'] ??
                                                        'U')
                                                    .toString()[0]
                                                    .toUpperCase(),
                                                style: const TextStyle(
                                                  color: Colors.cyan,
                                                ),
                                              ),
                                            ),
                                            title: Text(
                                              profile['fullName'] ??
                                                  'Unknown',
                                              style: const TextStyle(
                                                color: Colors.white,
                                              ),
                                            ),
                                            subtitle: Column(
                                              crossAxisAlignment:
                                                  CrossAxisAlignment
                                                      .start,
                                              mainAxisSize:
                                                  MainAxisSize.min,
                                              children: [
                                                if ((user['designation'] ??
                                                            '')
                                                        .toString()
                                                        .isNotEmpty)
                                                  Text(
                                                    '${user['designation']} â€¢ ${user['employeeType'] ?? 'N/A'}',
                                                    style:
                                                        const TextStyle(
                                                      color:
                                                          Colors.white70,
                                                      fontSize: 12,
                                                    ),
                                                  ),
                                                Text(
                                                  profile['email'] ?? '',
                                                  style:
                                                      const TextStyle(
                                                    color: Colors.white70,
                                                    fontSize: 12,
                                                  ),
                                                ),
                                              ],
                                            ),
                                            trailing: Container(
                                              padding:
                                                  const EdgeInsets
                                                      .symmetric(
                                                horizontal: 8,
                                                vertical: 4,
                                              ),
                                              decoration: BoxDecoration(
                                                color: Colors.greenAccent
                                                    .withOpacity(0.2),
                                                borderRadius:
                                                    BorderRadius.circular(
                                                        12),
                                              ),
                                              child: Text(
                                                user['status'] ??
                                                    'active',
                                                style:
                                                    const TextStyle(
                                                  color:
                                                      Colors.greenAccent,
                                                  fontSize: 11,
                                                ),
                                              ),
                                            ),
                                          );
                                        },
                                      ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// -----------------------------------------------------------------------------
// NEW WIDGETS START HERE
// -----------------------------------------------------------------------------

class DiffReviewDialog extends StatefulWidget {
  final ValidationResult validation;
  final VoidCallback onConfirm;

  const DiffReviewDialog({
    super.key,
    required this.validation,
    required this.onConfirm,
  });

  @override
  State<DiffReviewDialog> createState() => _DiffReviewDialogState();
}

class _DiffReviewDialogState extends State<DiffReviewDialog> {
  String searchQuery = "";

  @override
  Widget build(BuildContext context) {
    // 1. Filter Lists based on Search Query
    final filteredDiffs = widget.validation.diffs
        .where((d) => d.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    final filteredConflicts = widget.validation.authConflicts
        .where((u) => u.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    final filteredNewUsers = widget.validation.newUsers
        .where((u) => u.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    return AlertDialog(
      backgroundColor: const Color(0xFF111118),
      title: const Row(
        children: [
          Icon(Icons.rate_review, color: Colors.cyan),
          SizedBox(width: 12),
          Text('Review Import Data', style: TextStyle(color: Colors.white)),
        ],
      ),
      content: SizedBox(
        width: 600,
        height: 500,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 2. Summary Stats Badge Row
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  _statBadge(
                      'Total',
                      widget.validation.newUsers.length +
                          widget.validation.usersToUpdate.length +
                          widget.validation.authConflicts.length,
                      Colors.white),
                  const SizedBox(width: 8),
                  _statBadge('New', widget.validation.newUsers.length,
                      Colors.greenAccent),
                  const SizedBox(width: 8),
                  _statBadge('Updates', widget.validation.usersToUpdate.length,
                      Colors.orangeAccent),
                  const SizedBox(width: 8),
                  _statBadge('Conflicts', widget.validation.authConflicts.length,
                      Colors.redAccent),
                ],
              ),
            ),
            const SizedBox(height: 16),

            // 3. Search Bar
            TextField(
              style: const TextStyle(color: Colors.white),
              decoration: InputDecoration(
                filled: true,
                fillColor: Colors.white.withOpacity(0.05),
                hintText: 'Search by email...',
                hintStyle: const TextStyle(color: Colors.white30),
                prefixIcon: const Icon(Icons.search, color: Colors.cyan),
                border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide.none),
                contentPadding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              ),
              onChanged: (val) => setState(() => searchQuery = val),
            ),
            const SizedBox(height: 16),

            // 4. Scrollable Content List
            Expanded(
              child: ListView(
                children: [
                  // --- SECTION: CONFLICTS (Red) ---
                  if (filteredConflicts.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("âš  Auth Conflicts (Skipped)",
                          style: TextStyle(
                              color: Colors.redAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    ...filteredConflicts.map((u) => Container(
                          margin: const EdgeInsets.only(bottom: 4),
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 8),
                          decoration: BoxDecoration(
                              color: Colors.redAccent.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(
                                  color: Colors.redAccent.withOpacity(0.3))),
                          child: Row(
                            children: [
                              const Icon(Icons.warning_amber_rounded,
                                  color: Colors.redAccent, size: 16),
                              const SizedBox(width: 8),
                              Expanded(
                                  child: Text(u.email,
                                      style: const TextStyle(
                                          color: Colors.white70))),
                              const Text("Exists in Auth only",
                                  style: TextStyle(
                                      color: Colors.white30, fontSize: 10)),
                            ],
                          ),
                        )),
                    const SizedBox(height: 16),
                  ],

                  // --- SECTION: UPDATES (Orange) ---
                  if (filteredDiffs.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("Updates",
                          style: TextStyle(
                              color: Colors.orangeAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    ...filteredDiffs.map((diff) => Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.05),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                                color: Colors.orangeAccent.withOpacity(0.3)),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  const Icon(Icons.edit,
                                      color: Colors.orangeAccent, size: 14),
                                  const SizedBox(width: 8),
                                  Text(diff.email,
                                      style: const TextStyle(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold)),
                                ],
                              ),
                              const Divider(color: Colors.white10),
                              ...diff.changes.entries.map((e) => Padding(
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 2.0),
                                    child: Row(
                                      children: [
                                        Text('${e.key}: ',
                                            style: const TextStyle(
                                                color: Colors.white54,
                                                fontSize: 12)),
                                        Text('${e.value['old']}',
                                            style: const TextStyle(
                                                color: Colors.redAccent,
                                                decoration:
                                                    TextDecoration.lineThrough,
                                                fontSize: 12)),
                                        const Padding(
                                          padding: EdgeInsets.symmetric(
                                              horizontal: 4),
                                          child: Icon(Icons.arrow_right_alt,
                                              color: Colors.white30, size: 14),
                                        ),
                                        Text('${e.value['new']}',
                                            style: const TextStyle(
                                                color: Colors.greenAccent,
                                                fontWeight: FontWeight.bold,
                                                fontSize: 12)),
                                      ],
                                    ),
                                  )),
                            ],
                          ),
                        )),
                    const SizedBox(height: 16),
                  ],

                  // --- SECTION: NEW USERS (Green) ---
                  if (filteredNewUsers.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("New Users",
                          style: TextStyle(
                              color: Colors.greenAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.greenAccent.withOpacity(0.05),
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                            color: Colors.greenAccent.withOpacity(0.2)),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          if (searchQuery.isEmpty)
                            Padding(
                              padding: const EdgeInsets.all(8.0),
                              child: Text(
                                  "Ready to create ${filteredNewUsers.length} new users.",
                                  style: const TextStyle(color: Colors.white70)),
                            ),
                          // List individual new users
                          ...filteredNewUsers.map((u) => Padding(
                                padding: const EdgeInsets.symmetric(
                                    vertical: 4, horizontal: 8),
                                child: Row(
                                  children: [
                                    const Icon(Icons.add_circle_outline,
                                        color: Colors.greenAccent, size: 14),
                                    const SizedBox(width: 8),
                                    Text(u.email,
                                        style: const TextStyle(
                                            color: Colors.white60,
                                            fontSize: 12)),
                                  ],
                                ),
                              )),
                        ],
                      ),
                    ),
                  ],

                  // Empty State
                  if (filteredConflicts.isEmpty &&
                      filteredDiffs.isEmpty &&
                      filteredNewUsers.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(32.0),
                        child: Text("No matches found.",
                            style: TextStyle(color: Colors.white30)),
                      ),
                    )
                ],
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel', style: TextStyle(color: Colors.white54)),
        ),
        FilledButton.icon(
          onPressed: widget.onConfirm,
          icon: const Icon(Icons.check, size: 18),
          label: const Text('Confirm & Sync'),
          style: FilledButton.styleFrom(
              backgroundColor: Colors.cyan, foregroundColor: Colors.black),
        ),
      ],
    );
  }

  Widget _statBadge(String label, int count, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: color.withOpacity(0.3))),
      child: Row(
        children: [
          Icon(Icons.circle, size: 8, color: color),
          const SizedBox(width: 8),
          Text('$label: $count',
              style: TextStyle(
                  color: color, fontWeight: FontWeight.bold, fontSize: 12)),
        ],
      ),
    );
  }
}

class ImportProgressDialog extends StatefulWidget {
  final String tenantId;
  final List<CSVUserData> users;
  final UserDatabaseRepository repo;
  final VoidCallback onComplete;

  const ImportProgressDialog({
    super.key,
    required this.tenantId,
    required this.users,
    required this.repo,
    required this.onComplete,
  });

  @override
  State<ImportProgressDialog> createState() => _ImportProgressDialogState();
}

class _ImportProgressDialogState extends State<ImportProgressDialog> {
  int current = 0;
  int total = 0;
  String message = '';
  bool isComplete = false;
  Map<String, dynamic>? result;

  @override
  void initState() {
    super.initState();
    total = widget.users.length;
    startImport();
  }

  Future<void> startImport() async {
    final res = await widget.repo.importUsers(
      widget.tenantId,
      widget.users,
      (curr, tot, msg) {
        setState(() {
          current = curr;
          total = tot;
          message = msg;
        });
      },
    );

    setState(() {
      isComplete = true;
      result = res;
    });
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: const Color(0xFF111118),
      title: Row(
        children: [
          if (!isComplete)
            const SizedBox(
              width: 24,
              height: 24,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: Colors.cyan,
              ),
            )
          else
            const Icon(Icons.check_circle, color: Colors.greenAccent),
          const SizedBox(width: 12),
          Text(
            isComplete ? 'Import Complete' : 'Importing Users...',
            style: const TextStyle(color: Colors.white),
          ),
        ],
      ),
      content: SizedBox(
        width: 400,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (!isComplete) ...[
              LinearProgressIndicator(
                value: total > 0 ? current / total : 0,
                backgroundColor: Colors.white12,
                color: Colors.cyan,
              ),
              const SizedBox(height: 16),
              Text(
                'Progress: $current / $total',
                style: const TextStyle(color: Colors.white70),
              ),
              const SizedBox(height: 8),
              Text(
                message,
                style: const TextStyle(
                  color: Colors.white54,
                  fontSize: 12,
                ),
              ),
            ] else ...[
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.greenAccent.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'âœ“ Successfully imported: ${result!['success']}',
                      style: const TextStyle(
                        color: Colors.greenAccent,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    if (result!['failed'] > 0) ...[
                      const SizedBox(height: 8),
                      Text(
                        'âœ— Failed: ${result!['failed']}',
                        style: const TextStyle(color: Colors.redAccent),
                      ),
                    ],
                  ],
                ),
              ),
              if (result!['failedUsers'].isNotEmpty) ...[
                const SizedBox(height: 16),
                const Text(
                  'Failed users:',
                  style: TextStyle(
                    color: Colors.redAccent,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                SizedBox(
                  height: 150,
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children:
                          (result!['failedUsers'] as List<String>).map(
                        (e) {
                          return Padding(
                            padding:
                                const EdgeInsets.only(bottom: 4.0),
                            child: Text(
                              'â€¢ $e',
                              style: const TextStyle(
                                color: Colors.white70,
                                fontSize: 11,
                              ),
                            ),
                          );
                        },
                      ).toList(),
                    ),
                  ),
                ),
              ],
            ],
          ],
        ),
      ),
      actions: [
        if (isComplete)
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              widget.onComplete();
            },
            child: const Text('Close'),
          ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabaserepository.dart
// lib/Screen/Developer/UserDatabase/userdatabaserepository.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'userdatabasemodel.dart';

class UserDatabaseRepository {
  final FirebaseFirestore db;
  final FirebaseAuth auth = FirebaseAuth.instance;
  static const int RATE_LIMIT_DELAY_MS = 200; // Delay between operations

  UserDatabaseRepository({FirebaseFirestore? db})
      : db = db ?? FirebaseFirestore.instance;

  /// Validate CSV and separate New Users from Updates with Diff logic
  Future<ValidationResult> validateCSVData(
    String tenantId,
    List<CSVUserData> users,
  ) async {
    print("--- DEBUG: STARTING VALIDATION ---");
    
    List<String> errors = [];
    List<String> warnings = [];
    Set<String> validNodeIds = {};
    Set<String> invalidNodeIds = {};

    List<CSVUserData> newUsers = [];
    List<CSVUserData> usersToUpdate = [];
    List<CSVUserData> authConflicts = [];
    List<UserDiff> diffs = [];

    // 1. ---------- LOAD NODES ----------
    final nodesPath = 'tenants/$tenantId/organizations/hierarchy/nodes';
    final nodesSnap = await db.collection(nodesPath).get();
    final existingNodeIds = nodesSnap.docs.map((doc) => doc.id).toSet();

    // 2. ---------- LOAD EXISTING USERS (FETCH ALL STRATEGY) ----------
    Map<String, Map<String, dynamic>> existingFirestoreUsers = {};
    final userPath = 'tenants/$tenantId/users';
    
    print("DEBUG: Fetching ALL users to normalize email case...");
    final allUsersSnap = await db.collection(userPath).get();

    for (var doc in allUsersSnap.docs) {
      final data = doc.data();
      dynamic emailRaw = data['profiledata'] != null 
          ? (data['profiledata'] as Map)['email'] 
          : null;

      if (emailRaw != null) {
        String emailKey = emailRaw.toString().trim().toLowerCase();
        existingFirestoreUsers[emailKey] = {'id': doc.id, ...data};
      }
    }
    
    // 3. ---------- PROCESS CSV ROWS ----------
    Set<String> processedEmails = {};

    for (int i = 0; i < users.length; i++) {
      final user = users[i];
      final rowNum = i + 2;
      final emailLower = user.email.trim().toLowerCase();

      if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(user.email)) {
        errors.add('Row $rowNum: Invalid email - ${user.email}');
        continue;
      }

      if (processedEmails.contains(emailLower)) {
        warnings.add('Row $rowNum: Duplicate skipped - ${user.email}');
        continue;
      }
      processedEmails.add(emailLower);

      if (user.nodeId.isEmpty) errors.add('Row $rowNum: Node ID required');
      else if (existingNodeIds.contains(user.nodeId)) validNodeIds.add(user.nodeId);
      else {
        invalidNodeIds.add(user.nodeId);
        errors.add('Row $rowNum: Invalid Node ID "${user.nodeId}"');
      }

      if (errors.any((e) => e.startsWith('Row $rowNum'))) continue;

      // 4. ---------- COMPARE ----------
      if (existingFirestoreUsers.containsKey(emailLower)) {
        // UPDATE CASE
        final existing = existingFirestoreUsers[emailLower]!;
        Map<String, Map<String, dynamic>> fieldChanges = {};

        void checkChange(String field, dynamic newVal, dynamic oldVal) {
          if (newVal.toString() != oldVal.toString()) {
            fieldChanges[field] = {'old': oldVal, 'new': newVal};
          }
        }

        checkChange('fullName', user.fullName, existing['profiledata']?['fullName'] ?? '');
        checkChange('designation', user.designation, existing['designation'] ?? '');
        checkChange('employeeType', user.employeeType, existing['employeeType'] ?? ''); // New Field
        checkChange('nodeId', user.nodeId, existing['nodeId'] ?? '');
        checkChange('level', user.level, existing['level'] ?? 0);

        if (fieldChanges.isNotEmpty) {
          usersToUpdate.add(user);
          diffs.add(UserDiff(email: user.email, changes: fieldChanges));
        } else {
          warnings.add('${user.email} is up to date.');
        }
      } else {
        // NEW CASE
        try {
          final methods = await auth.fetchSignInMethodsForEmail(user.email);
          if (methods.isNotEmpty) {
            authConflicts.add(user);
            warnings.add('User ${user.email} exists in Auth but not DB.');
          } else {
            newUsers.add(user);
          }
        } catch (e) {
          newUsers.add(user); 
        }
      }
    }

    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
      validNodeIds: validNodeIds.toList(),
      invalidNodeIds: invalidNodeIds.toList(),
      newUsers: newUsers,
      usersToUpdate: usersToUpdate,
      authConflicts: authConflicts,
      diffs: diffs,
    );
  }

  /// IMPORT OR UPDATE USERS 
  /// FIXED: Now uses pre-fetched Map to ensure Case-Insensitive matching works
  Future<Map<String, dynamic>> importUsers(
    String tenantId,
    List<CSVUserData> users,
    Function(int current, int total, String message) progressCallback,
  ) async {
    int successCount = 0;
    int failureCount = 0;
    List<String> failedUsers = [];

    // ---------------------------------------------------------
    // STEP 1: PRE-FETCH EXISTING USERS TO MAP (THE FIX)
    // ---------------------------------------------------------
    // We must build the same map as validation to find the Doc IDs
    // regardless of whether the email is stored as "Sanjay" or "sanjay".
    Map<String, String> emailToDocIdMap = {};
    
    try {
      final userPath = 'tenants/$tenantId/users';
      final allUsersSnap = await db.collection(userPath).get();
      
      for (var doc in allUsersSnap.docs) {
        final data = doc.data();
        dynamic emailRaw = data['profiledata'] != null 
            ? (data['profiledata'] as Map)['email'] 
            : null;
        if (emailRaw != null) {
          // KEY = Lowercase Email, VALUE = Document ID
          emailToDocIdMap[emailRaw.toString().trim().toLowerCase()] = doc.id;
        }
      }
      print("DEBUG: Import Loop - Mapped ${emailToDocIdMap.length} existing users for lookup.");
    } catch (e) {
      print("DEBUG: Error mapping existing users: $e");
    }

    // ---------------------------------------------------------
    // STEP 2: PROCESS USERS
    // ---------------------------------------------------------
    for (int i = 0; i < users.length; i++) {
      final user = users[i];
      final emailLower = user.email.trim().toLowerCase();
      
      progressCallback(i + 1, users.length, 'Syncing ${user.email}...');

      if (i > 0 && i % 10 == 0) await Future.delayed(const Duration(milliseconds: RATE_LIMIT_DELAY_MS));

      try {
        // CHECK MAP INSTEAD OF QUERYING DB AGAIN
        if (emailToDocIdMap.containsKey(emailLower)) {
          // ============================================
          // UPDATE EXISTING USER
          // ============================================
          final docId = emailToDocIdMap[emailLower]!;
          
          print("DEBUG: Updating existing user $docId (${user.email})");
          
          await db.collection('tenants/$tenantId/users').doc(docId).update({
            'profiledata.fullName': user.fullName,
            'designation': user.designation,
            'employeeType': user.employeeType, // This will now correctly update
            'nodeId': user.nodeId,
            'level': user.level,
            // DO NOT update status or password here
          });
          
          successCount++;
        } else {
          // ============================================
          // CREATE NEW USER
          // ============================================
          print("DEBUG: Creating NEW user (${user.email})");
          
          UserCredential? credential;
          try {
            credential = await FirebaseAuth.instance.createUserWithEmailAndPassword(
              email: user.email,
              password: user.password,
            );

            final userId = credential.user!.uid;
            await db.collection('tenants/$tenantId/users').doc(userId).set({
              'profiledata': {
                'email': user.email,
                'fullName': user.fullName,
              },
              'designation': user.designation,
              'employeeType': user.employeeType, // New Field
              'status': 'active',
              'createdat': FieldValue.serverTimestamp(),
              'nodeId': user.nodeId,
              'level': user.level,
              'importedFromCSV': true,
            });
            successCount++;

          } on FirebaseAuthException catch (e) {
            if (e.code == 'email-already-in-use') {
              failureCount++;
              failedUsers.add('${user.email}: Exists in Auth but missing in DB (Conflict)');
            } else {
              rethrow;
            }
          }
        }
      } catch (e) {
        failureCount++;
        failedUsers.add('${user.email}: $e');
        print("DEBUG: Error processing ${user.email}: $e");
      }
    }

    return {
      'success': successCount,
      'failed': failureCount,
      'failedUsers': failedUsers,
    };
  }

  /// Load users for a node from tenants/{tenantId}/users
  Future<List<Map<String, dynamic>>> loadUsersByNode(
    String tenantId,
    String nodeId,
  ) async {
    final snap = await db
        .collection('tenants/$tenantId/users')
        .where('nodeId', isEqualTo: nodeId)
        .orderBy('createdat', descending: true)
        .get();

    return snap.docs.map((d) => {'id': d.id, ...d.data()}).toList();
  }

  /// Load hierarchy nodes with user counts from tenants/{tenantId}/users
  Future<List<Map<String, dynamic>>> loadHierarchyWithUserCounts(
    String tenantId,
  ) async {
    final nodesSnap = await db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes')
        .get();

    List<Map<String, dynamic>> nodesWithCounts = [];

    for (final nodeDoc in nodesSnap.docs) {
      final nodeId = nodeDoc.id;
      final usersSnap = await db
          .collection('tenants/$tenantId/users')
          .where('nodeId', isEqualTo: nodeId)
          .count()
          .get();

      nodesWithCounts.add({
        'id': nodeId,
        ...nodeDoc.data(),
        'userCount': usersSnap.count ?? 0,
      });
    }

    nodesWithCounts.sort((a, b) {
      final levelCmp = (a['level'] as int).compareTo(b['level'] as int);
      if (levelCmp != 0) return levelCmp;
      return (a['name'] as String).compareTo(b['name'] as String);
    });

    return nodesWithCounts;
  }
}

================================================================================

// File: lib\dynamic_screen\dashboardpanel.dart
import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import 'model/floating_widget.dart';
import 'widget_factory.dart';
import 'model/screen_grid.dart';

Widget buildGridWidget({
  required ScreenGridWidgetSpan item,
  required double cellW,
  required double cellH,
  required double maxW,
  required double maxH,
  required double initialLeft,
  required double initialTop,
  required double initialWidthPx,
  required double initialHeightPx,
  required double globalBlur,
  required double globalOpacity,
  required Color globalTint,
  required VoidCallback onSnap,
}) {
  return FreeDragResizeItem(
    key: ValueKey(item.widgetId),
    item: item,
    gridColumns: 24,
    gridRows: 14,
    cellW: cellW,
    cellH: cellH,
    maxW: maxW,
    maxH: maxH,
    initialLeft: initialLeft,
    initialTop: initialTop,
    initialWidthPx: initialWidthPx,
    initialHeightPx: initialHeightPx,
    globalBlur: globalBlur,
    globalOpacity: globalOpacity,
    globalTint: globalTint,
    onSnap: onSnap,
  );
}

/// Draggable + resizable wrapper used by the dashboard grid.
class FreeDragResizeItem extends StatefulWidget {
  final ScreenGridWidgetSpan item;
  final int gridColumns;
  final int gridRows;

  final double cellW;
  final double cellH;
  final double maxW;
  final double maxH;

  final double initialLeft;
  final double initialTop;
  final double initialWidthPx;
  final double initialHeightPx;

  final double globalBlur;
  final double globalOpacity;
  final Color globalTint;
  final VoidCallback onSnap;

  const FreeDragResizeItem({
    super.key,
    required this.item,
    required this.gridColumns,
    required this.gridRows,
    required this.cellW,
    required this.cellH,
    required this.maxW,
    required this.maxH,
    required this.initialLeft,
    required this.initialTop,
    required this.initialWidthPx,
    required this.initialHeightPx,
    required this.globalBlur,
    required this.globalOpacity,
    required this.globalTint,
    required this.onSnap,
  });

  @override
  State<FreeDragResizeItem> createState() => _FreeDragResizeItemState();
}

class _FreeDragResizeItemState extends State<FreeDragResizeItem> {
  late double left;
  late double top;
  late double widthPx;
  late double heightPx;

  Offset? dragLastGlobal;
  Offset? resizeLastGlobal;

  // ğŸ”¥ FIX: Cache widget content to avoid rebuilding on every frame
  Widget? _cachedContent;
  String? _cachedWidgetId;

  bool get isInteracting => dragLastGlobal != null || resizeLastGlobal != null;

  @override
  void initState() {
    super.initState();
    left = widget.initialLeft;
    top = widget.initialTop;
    widthPx = widget.initialWidthPx;
    heightPx = widget.initialHeightPx;
    
    // Cache the widget content
    _buildCachedContent();
  }

  @override
  void didUpdateWidget(covariant FreeDragResizeItem oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // Rebuild cached content if widget ID changed
    if (oldWidget.item.widgetId != widget.item.widgetId) {
      _buildCachedContent();
    }
    
    if (!isInteracting) {
      left = (widget.item.col * widget.cellW).clamp(0.0, widget.maxW - widget.cellW);
      top = (widget.item.row * widget.cellH).clamp(0.0, widget.maxH - widget.cellH);
      widthPx = (widget.item.colSpan * widget.cellW)
          .clamp(widget.cellW * 2, widget.maxW);
      heightPx = (widget.item.rowSpan * widget.cellH)
          .clamp(widget.cellH * 2, widget.maxH);
    }
  }

  // ğŸ”¥ FIX: Build and cache widget content once
  void _buildCachedContent() {
    _cachedWidgetId = widget.item.widgetId;
    _cachedContent = RepaintBoundary(
      child: DynamicWidgetFactory.create(widget.item.widgetId),
    );
  }

  void snapToGridAndPersist() {
    int col = (left / widget.cellW).round();
    int row = (top / widget.cellH).round();
    int colSpan = (widthPx / widget.cellW).round();
    int rowSpan = (heightPx / widget.cellH).round();

    colSpan = colSpan.clamp(2, widget.gridColumns);
    rowSpan = rowSpan.clamp(2, widget.gridRows);

    col = col.clamp(0, widget.gridColumns - colSpan);
    row = row.clamp(0, widget.gridRows - rowSpan);

    widget.item
      ..col = col
      ..row = row
      ..colSpan = colSpan
      ..rowSpan = rowSpan;

    setState(() {
      left = col * widget.cellW;
      top = row * widget.cellH;
      widthPx = colSpan * widget.cellW;
      heightPx = rowSpan * widget.cellH;
    });

    widget.onSnap();
  }

  @override
  Widget build(BuildContext context) {
    // ğŸ”¥ FIX: Use cached content instead of rebuilding every frame
    final content = _cachedContent ?? const SizedBox.shrink();

    // ğŸ”¥ FIX: Reduce blur during interaction for better performance
    final effectiveBlur = isInteracting 
        ? (widget.globalBlur * 0.5).clamp(0.0, 8.0)  // Half blur when dragging
        : widget.globalBlur;

    final glassCard = GlassContainer(
      blur: effectiveBlur,
      opacity: widget.globalOpacity,
      tint: widget.globalTint,
      borderRadius: BorderRadius.circular(24),
      child: content,
    );

    const hitHandleSize = 24.0;

    return Positioned(
      left: left.clamp(0.0, widget.maxW - widthPx),
      top: top.clamp(0.0, widget.maxH - heightPx),
      width: widthPx.clamp(widget.cellW * 2, widget.maxW),
      height: heightPx.clamp(widget.cellH * 2, widget.maxH),
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onPanStart: (details) {
          final local = details.localPosition;
          final isResize =
              local.dx > widthPx - hitHandleSize && local.dy > heightPx - hitHandleSize;
          
          setState(() {
            if (isResize) {
              resizeLastGlobal = details.globalPosition;
            } else {
              dragLastGlobal = details.globalPosition;
            }
          });
        },
        onPanUpdate: (details) {
          setState(() {
            if (resizeLastGlobal != null) {
              final delta = details.globalPosition - resizeLastGlobal!;
              widthPx = (widthPx + delta.dx)
                  .clamp(widget.cellW * 2, widget.maxW - left);
              heightPx = (heightPx + delta.dy)
                  .clamp(widget.cellH * 2, widget.maxH - top);
              resizeLastGlobal = details.globalPosition;
            } else if (dragLastGlobal != null) {
              final delta = details.globalPosition - dragLastGlobal!;
              left = (left + delta.dx).clamp(0.0, widget.maxW - widthPx);
              top = (top + delta.dy).clamp(0.0, widget.maxH - heightPx);
              dragLastGlobal = details.globalPosition;
            }
          });
        },
        onPanEnd: (_) {
          setState(() {
            dragLastGlobal = null;
            resizeLastGlobal = null;
          });
          snapToGridAndPersist();
        },
        onPanCancel: () {
          setState(() {
            dragLastGlobal = null;
            resizeLastGlobal = null;
          });
          snapToGridAndPersist();
        },
        child: Stack(
          children: [
            // ğŸ”¥ FIX: Isolate glass card repaints
            Positioned.fill(
              child: RepaintBoundary(
                child: glassCard,
              ),
            ),
            
            // Resize handle
            if (!isInteracting || resizeLastGlobal != null)
              Positioned(
                right: 4,
                bottom: 4,
                child: _ResizeHandle(
                  isActive: resizeLastGlobal != null,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

// ğŸ”¥ FIX: Extract resize handle to prevent rebuilds
class _ResizeHandle extends StatelessWidget {
  final bool isActive;

  const _ResizeHandle({required this.isActive});

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      cursor: SystemMouseCursors.resizeDownRight,
      child: Container(
        width: 24.0,
        height: 24.0,
        alignment: Alignment.bottomRight,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          width: isActive ? 16 : 14,
          height: isActive ? 16 : 14,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(4),
            color: isActive ? Colors.cyanAccent : Colors.cyanAccent.withOpacity(0.8),
            boxShadow: isActive
                ? [
                    BoxShadow(
                      color: Colors.cyanAccent.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 2,
                    ),
                  ]
                : null,
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_drawer.dart
import 'package:flutter/material.dart';

import 'repository/dashboard_repository.dart';

class DashboardDrawer extends StatelessWidget {
  final Set<String> allowedWidgetIds;
  final List items;
  // No toggle callback any more.

  const DashboardDrawer({
    super.key,
    required this.allowedWidgetIds,
    required this.items,
  });

  @override
  Widget build(BuildContext context) {
    // If you still want to hide the drawer when only login is allowed, keep this.
    if (allowedWidgetIds.length == 1 && allowedWidgetIds.contains('login')) {
      return const SizedBox.shrink();
    }

    final repo = DashboardRepository();
    final allWidgets = repo.getWidgets();

    return Positioned(
      left: 16,
      top: 64,
      bottom: 16,
      child: MouseRegion(
        opaque: false,
        child: Align(
          alignment: Alignment.topLeft,
          child: Container(
            width: 220,
            decoration: BoxDecoration(
              color: const Color(0xCC05040A),
              borderRadius: BorderRadius.circular(18),
              border: Border.all(color: Colors.white10),
            ),
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 10),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Widgets',
                  style: TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.w600,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 8),
                Expanded(
                  child: ListView(
                    children: [
                      for (final w in allWidgets)
                        ListTile(
                          dense: true,
                          contentPadding: EdgeInsets.zero,
                          leading: const Icon(
                            Icons.widgets,
                            size: 18,
                            color: Colors.cyanAccent,
                          ),
                          title: Text(
                            w.name,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 13,
                            ),
                          ),
                          // No switch / tap handler; purely informational.
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_grid.dart
// lib/dynamic_screen/dashboard_grid.dart
import 'package:flutter/material.dart';

import '../core/wallpaper_service.dart';
import 'model/screen_grid.dart';
import 'widgets/widgets.dart';

class DashboardGrid extends StatelessWidget {
  final ScreenGridConfig grid;
  final List<ScreenGridWidgetSpan> items;
  final VoidCallback onSnap;

  // NEW: glass settings for widgets
  final double globalBlur;
  final double globalOpacity;

  const DashboardGrid({
    super.key,
    required this.grid,
    required this.items,
    required this.onSnap,
    required this.globalBlur,
    required this.globalOpacity,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final cellW = constraints.maxWidth / grid.columns;
        final cellH = constraints.maxHeight / grid.rows;

        // No blur/opacity logic here; only pass through.
        const globalTint = Color(0xFFFFFFFF);

        return ClipRect(
          child: Stack(
            clipBehavior: Clip.hardEdge,
            children: [
              for (final item in items)
                buildGridWidget(
                  item: item,
                  cellW: cellW,
                  cellH: cellH,
                  maxW: constraints.maxWidth,
                  maxH: constraints.maxHeight,
                  initialLeft: cellW * item.col,
                  initialTop: cellH * item.row,
                  initialWidthPx: cellW * item.colSpan,
                  initialHeightPx: cellH * item.rowSpan,
                  globalBlur: globalBlur,
                  globalOpacity: globalOpacity,
                  globalTint: globalTint,
                  onSnap: onSnap,
                ),
            ],
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_layout_persistence.dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'model/screen_grid.dart';

class DashboardLayoutPersistence {
  static Future<void> loadLayout({
    required String prefsKey,
    required void Function(List<ScreenGridWidgetSpan>) onLoaded,
    required List<ScreenGridWidgetSpan> Function() defaultItemsBuilder,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(prefsKey);
    if (jsonString == null) {
      debugPrint('[LAYOUT] No saved layout, using defaults');
      onLoaded(defaultItemsBuilder());
      return;
    }

    try {
      final List<dynamic> decoded = jsonDecode(jsonString) as List<dynamic>;
      final loaded = decoded.map((e) {
        final m = e as Map<String, dynamic>;
        return ScreenGridWidgetSpan(
          widgetId: m['id'] as String,
          col: m['col'] as int,
          row: m['row'] as int,
          colSpan: m['colSpan'] as int,
          rowSpan: m['rowSpan'] as int,
        );
      }).toList();
      debugPrint('[LAYOUT] Loaded ${loaded.length} items');
      onLoaded(loaded);
    } catch (e) {
      debugPrint('[LAYOUT] Failed to parse layout: $e');
      onLoaded(defaultItemsBuilder());
    }
  }

  static Future<void> saveLayout({
    required String prefsKey,
    required List<ScreenGridWidgetSpan> items,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final data = items
        .map((w) => {
              'id': w.widgetId,
              'col': w.col,
              'row': w.row,
              'colSpan': w.colSpan,
              'rowSpan': w.rowSpan,
            })
        .toList();
    await prefs.setString(prefsKey, jsonEncode(data));
    debugPrint('[LAYOUT] Saved layout with ${items.length} items');
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_permissions.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

class DashboardPermissions {
  static const String _tenantId = 'default_tenant';

  /// Pure helper â€“ no setState/mounted/allowedWidgetIds inside this file.
  /// It only logs and then calls [onAllowedWidgetIds].
  static Future<void> loadUserPermissions({
    required BuildContext context,
    required String userId,
    required void Function(Set<String> allowedWidgetIds) onAllowedWidgetIds,
  }) async {
    debugPrint('[PERM] ---- loadUserPermissions START ----');
    debugPrint('[PERM] userId=$userId');

    try {
      // 1) Load user doc
      final userDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(_tenantId)
          .collection('users')
          .doc(userId)
          .get();

      debugPrint('[PERM] userDoc.exists = ${userDoc.exists}');
      if (!userDoc.exists) {
        debugPrint('[PERM] user doc missing -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final data = userDoc.data() as Map<String, dynamic>;
      debugPrint('[PERM] userDoc.data = $data');

      final designation = data['designation'] as String?;
      debugPrint('[PERM] designation = $designation');

      if (designation == null || designation.trim().isEmpty) {
        debugPrint('[PERM] designation null/empty -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      // 2) Load designation metadata
      final metaDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(_tenantId)
          .collection('metadata')
          .doc('designations')
          .get();

      debugPrint('[PERM] metaDoc.exists = ${metaDoc.exists}');
      if (!metaDoc.exists) {
        debugPrint('[PERM] designations meta missing -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final meta = metaDoc.data() as Map<String, dynamic>;
      debugPrint('[PERM] meta keys = ${meta.keys.toList()}');

      final allDesignations =
          meta['designations'] as Map<String, dynamic>? ?? {};
      debugPrint(
          '[PERM] allDesignations keys = ${allDesignations.keys.toList()}');

      final designationData =
          allDesignations[designation] as Map<String, dynamic>?;
      debugPrint('[PERM] designationData = $designationData');

      if (designationData == null) {
        debugPrint(
            '[PERM] designation $designation not found -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final permissionsRaw =
          (designationData['permissions'] as List<dynamic>? ?? []);
      final permissions =
          permissionsRaw.map((e) => e.toString()).toSet();
      debugPrint('[PERM] permissions = $permissions');

      // 3) Map permissions to widget ids
      final allowed = <String>{};
      if (permissions.contains('create_task') ||
          permissions.contains('createtask')) {
        allowed.add('createtask');
      }
      if (permissions.contains('view_assigned_tasks') ||
          permissions.contains('viewassignedtasks')) {
        allowed.add('viewassignedtasks');
      }
      if (permissions.contains('view_all_tasks') ||
          permissions.contains('viewalltasks')) {
        allowed.add('viewalltasks');
      }
      if (permissions.contains('complete_task') ||
          permissions.contains('completetask')) {
        allowed.add('completetask');
      }

      debugPrint('[PERM] allowedWidgetIds computed = $allowed');

      onAllowedWidgetIds(allowed.isEmpty ? {'login'} : allowed);

      debugPrint('[PERM] ---- loadUserPermissions END OK ----');
    } catch (e, st) {
      debugPrint('[PERM] Permission load error: $e');
      debugPrint('[PERM] Stack: $st');
      // Do NOT auto sign-out during debugging; just fall back to login view.
      onAllowedWidgetIds({'login'});
    }
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_screen.dart
import 'dart:async';
import 'dart:math' as math;

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:walld_flutter/dynamic_screen/dashboard_layout_persistence.dart';
import 'package:walld_flutter/dynamic_screen/model/screen_grid.dart';

import '../core/wallpaper_service.dart';
import 'dashboard_grid.dart';
import 'widget_manifest.dart';

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({super.key});

  @override
  State<DashboardScreen> createState() => DashboardScreenState();
}

class DashboardScreenState extends State<DashboardScreen> {
  // DEBUG: Track instances to find duplicates
  static int _instanceCounter = 0;
  final int _instanceNumber;
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString();

  DashboardScreenState() : _instanceNumber = ++_instanceCounter {
    debugPrint('ğŸ”· DashboardScreen INSTANCE #$_instanceNumber CREATED (ID: $_instanceId)');
  }

  // Grid
  static const ScreenGridConfig grid = ScreenGridConfig(columns: 24, rows: 14);

  // ------------------------------------------------------------
  // EASY KNOBS (change only these)
  // ------------------------------------------------------------

  /// Scale factor for ALL default widgets (only affects "defaultItemsForAllowed",
  /// i.e., first-run / no saved layout yet).
  static const double defaultWidgetScale = 0.75;

  /// Default widget base size in grid units (before scale).
  static const int baseColSpan = 7;
  static const int baseRowSpan = 4;

  /// Default start position (X/Y) in grid units for the first widget.
  static const int defaultStartCol = 0; // X
  static const int defaultStartRow = 0; // Y

  /// Login widget defaults (separate knobs).
  static const int loginCol = 6;
  static const int loginRow = 3;
  static const int loginColSpan = 12;
  static const int loginRowSpan = 8;

  int get defaultColSpan =>
      math.max(2, (baseColSpan * defaultWidgetScale).round());

  int get defaultRowSpan =>
      math.max(2, (baseRowSpan * defaultWidgetScale).round());

  // ------------------------------------------------------------

  bool loading = true;
  String? error;
  Set<String> allowedWidgetIds = const {'login'};
  final List<ScreenGridWidgetSpan> items = [];

  StreamSubscription<User?>? authSubscription;
  String get userId => FirebaseAuth.instance.currentUser?.uid ?? 'anon';
  String get layoutPrefsKey => 'dashboard_layout_v1_$userId';

  @override
  void initState() {
    super.initState();
    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - initState() - Setting up auth listener');

    authSubscription = FirebaseAuth.instance.authStateChanges().listen((user) {
      debugPrint('ğŸ”· DashboardScreen #$_instanceNumber AUTH CHANGED: user=${user?.uid}');

      if (user == null) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - User logged out, showing login only');
        showLoginOnly();
      } else {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - User logged in, calling bootstrap()');
        unawaited(bootstrap());
      }
    });

    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Initial bootstrap call');
    unawaited(bootstrap());
  }

  @override
  void dispose() {
    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber DISPOSED');
    authSubscription?.cancel();
    super.dispose();
  }

  void showLoginOnly() {
    setState(() {
      loading = false;
      error = null;
      allowedWidgetIds = const {'login'};
      items
        ..clear()
        ..add(
          ScreenGridWidgetSpan(
            widgetId: 'login',
            col: loginCol,
            row: loginRow,
            colSpan: loginColSpan,
            rowSpan: loginRowSpan,
          ),
        );
    });
  }

  Future<void> bootstrap() async {
    debugPrint('ğŸ”·ğŸ”·ğŸ”· BOOTSTRAP START - DashboardScreen #$_instanceNumber');

    setState(() {
      loading = true;
      error = null;
    });

    try {
      // 1. Get all widgets from manifest
      allowedWidgetIds = widgetManifest.map((w) => w['id'] as String).toSet();

      // 2. Load layout from persistence
      await DashboardLayoutPersistence.loadLayout(
        prefsKey: layoutPrefsKey,
        onLoaded: (loaded) {
          debugPrint(
            'ğŸ”· DashboardScreen #$_instanceNumber - Layout loaded from disk: ${loaded.length} widgets',
          );
          items
            ..clear()
            ..addAll(filterToAllowed(loaded));
        },
        defaultItemsBuilder: defaultItemsForAllowed,
      );

      // 3. Fallback if empty
      if (items.isEmpty) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Layout empty, using defaults');
        items.addAll(defaultItemsForAllowed());
      }

      if (!mounted) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Widget not mounted after bootstrap, aborting');
        return;
      }

      setState(() => loading = false);

      debugPrint('ğŸ”·ğŸ”·ğŸ”· BOOTSTRAP END - DashboardScreen #$_instanceNumber - ${items.length} widgets loaded');
    } catch (e) {
      debugPrint('âŒ DashboardScreen #$_instanceNumber - Bootstrap error: $e');
      if (!mounted) return;
      setState(() {
        loading = false;
        error = e.toString();
      });
    }
  }

  List<ScreenGridWidgetSpan> filterToAllowed(List<ScreenGridWidgetSpan> input) {
    return input.where((w) => allowedWidgetIds.contains(w.widgetId)).toList();
  }

  List<ScreenGridWidgetSpan> defaultItemsForAllowed() {
    // Login-only case
    if (allowedWidgetIds.length == 1 && allowedWidgetIds.contains('login')) {
      return [
        ScreenGridWidgetSpan(
          widgetId: 'login',
          col: loginCol,
          row: loginRow,
          colSpan: loginColSpan,
          rowSpan: loginRowSpan,
        ),
      ];
    }

    final ids = allowedWidgetIds.where((id) => id != 'login').toList();
    if (ids.isEmpty) {
      return [
        ScreenGridWidgetSpan(
          widgetId: 'login',
          col: loginCol,
          row: loginRow,
          colSpan: loginColSpan,
          rowSpan: loginRowSpan,
        ),
      ];
    }

    // Size knobs (scaled)
    final w = math.min(defaultColSpan, grid.columns);
    final h = math.min(defaultRowSpan, grid.rows);

    // Start position knobs (X/Y)
    int c = defaultStartCol.clamp(0, math.max(0, grid.columns - w));
    int r = defaultStartRow.clamp(0, math.max(0, grid.rows - h));

    final out = <ScreenGridWidgetSpan>[];

    for (final id in ids) {
      out.add(ScreenGridWidgetSpan(
        widgetId: id,
        col: c,
        row: r,
        colSpan: w,
        rowSpan: h,
      ));

      // Next position
      c += w;

      // Wrap to next row
      if (c >= grid.columns || c + w > grid.columns) {
        c = 0;
        r += h;
      }

      // Wrap to top if overflow
      if (r >= grid.rows || r + h > grid.rows) {
        r = 0;
      }
    }

    return out;
  }

  Future<void> saveLayout() async {
    await DashboardLayoutPersistence.saveLayout(
      prefsKey: layoutPrefsKey,
      items: items,
    );
  }

  void onSnap() {
    unawaited(saveLayout());
  }

  @override
  Widget build(BuildContext context) {
    if (loading) {
      return const Center(
        child: SizedBox(
          width: 28,
          height: 28,
          child: CircularProgressIndicator(color: Colors.cyan),
        ),
      );
    }

    if (error != null) {
      return Center(
        child: Text(
          'Dashboard error: $error',
          style: const TextStyle(color: Colors.redAccent),
        ),
      );
    }

    final wallpaper = WallpaperService.instance;

    return AnimatedBuilder(
      animation: wallpaper,
      builder: (context, _) {
        final glassBlur = wallpaper.globalGlassBlur;
        final glassOpacity = wallpaper.globalGlassOpacity;

        return Stack(
          children: [
            // Wallpaper background
            Positioned.fill(
              child: DecoratedBox(
                decoration: wallpaper.backgroundDecoration,
              ),
            ),

            // Foreground widgets (bounded area)
            Positioned.fill(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(18, 70, 18, 18),
                child: RepaintBoundary(
                  child: DashboardGrid(
                    grid: grid,
                    items: items,
                    onSnap: onSnap,
                    globalBlur: glassBlur,
                    globalOpacity: glassOpacity,
                  ),
                ),
              ),
            ),

            // Debug info (optional)
            if (kDebugMode)
              Positioned(
                left: 12,
                bottom: 10,
                child: IgnorePointer(
                  child: Text(
                    'Widgets: ${items.length} | Allowed: ${allowedWidgetIds.length} | '
                    'Instance: $_instanceNumber | '
                    'DefaultSpan: ${defaultColSpan}x${defaultRowSpan} | '
                    'Start: ${defaultStartCol},${defaultStartRow} | '
                    'Scale: $defaultWidgetScale',
                    style: const TextStyle(
                      color: Colors.white54,
                      fontSize: 11,
                      fontFamily: 'monospace',
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets.dart
export 'widgets/create_task_widget.dart';
export 'widgets/view_assigned_tasks_widget.dart';
export 'widgets/complete_task_widget.dart';
export 'widgets/view_all_tasks_widget.dart';

================================================================================

// File: lib\dynamic_screen\widget_factory.dart
import 'package:flutter/material.dart';
import 'widgets/login_widget.dart';
import 'widgets/create_task_widget.dart';
import 'widgets/view_assigned_tasks_widget.dart';
import 'widgets/view_all_tasks_widget.dart';
import 'widgets/complete_task_widget.dart';

class DynamicWidgetFactory {
  static Widget create(String widgetId) {
    // 1. Normalize the ID: remove underscores and make lowercase
    // This ensures 'create_task' and 'createtask' both work.
    final normalizedId = widgetId.toLowerCase().replaceAll('_', '');

    switch (normalizedId) {
      case 'login':
        return const LoginWidget();
        
      case 'createtask':
        return const CreateTaskWidget();
        
      case 'viewassignedtasks':
        return const ViewAssignedTasksWidget();
        
      case 'viewalltasks':
        return const ViewAllTasksWidget();
        
      case 'completetask':
        return const CompleteTaskWidget();

      default:
        // This handles the "Widget Not Found" error gracefully
        return _buildNotFoundWidget(widgetId);
    }
  }

  static Widget _buildNotFoundWidget(String id) {
    return Container(
      color: Colors.red.withOpacity(0.1),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.broken_image_outlined, color: Colors.red, size: 32),
            const SizedBox(height: 8),
            Text(
              'Unknown Widget\n"$id"',
              textAlign: TextAlign.center,
              style: const TextStyle(color: Colors.red, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widget_manifest.dart
// lib/dynamic_screen/widget_manifest.dart
final List<Map<String, dynamic>> widgetManifest = [
  {
    'id': 'login',
    'name': 'Login',
  },
  {
    'id': 'create_task',
    'name': 'Create Task',
  },
  {
    'id': 'view_assigned_tasks',
    'name': 'View Assigned Tasks',
  },
  {
    'id': 'view_all_tasks',
    'name': 'View All Tasks',
  },
  {
    'id': 'complete_task',
    'name': 'Complete Task',
  },
];

================================================================================

// File: lib\dynamic_screen\model\floating_widget.dart
// lib/dynamic_screen/model/floating_widget.dart
class FloatingWidgetItem {
  final String widgetId;
  double x;      // left position in pixels
  double y;      // top position in pixels
  double width;  // widget width in pixels
  double height; // widget height in pixels

  FloatingWidgetItem({
    required this.widgetId,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });
}

================================================================================

// File: lib\dynamic_screen\model\grid_layout.dart
class GridLayoutConfig {
  final int columns;
  final double rowHeight; // logical pixels per grid row

  const GridLayoutConfig({
    this.columns = 120,
    this.rowHeight = 700,
  });
}

class WidgetGridItem {
  final String widgetId;
  int col;      // 0-based column index
  int row;      // 0-based row index
  int colSpan;  // number of columns spanned
  int rowSpan;  // number of rows spanned

  WidgetGridItem({
    required this.widgetId,
    required this.col,
    required this.row,
    required this.colSpan,
    required this.rowSpan,
  });
}

================================================================================

// File: lib\dynamic_screen\model\screen_grid.dart
class ScreenGridConfig {
  final int columns;
  final int rows;

  const ScreenGridConfig({
    this.columns = 240,
    this.rows = 140,
  });
}

class ScreenGridWidgetSpan {
  final String widgetId;
  int col;      // 0-based column index
  int row;      // 0-based row index
  int colSpan;  // how many screen columns this widget uses
  int rowSpan;  // how many screen rows this widget uses

  ScreenGridWidgetSpan({
    required this.widgetId,
    required this.col,
    required this.row,
    required this.colSpan,
    required this.rowSpan,
  });
}

================================================================================

// File: lib\dynamic_screen\model\task_form_models.dart
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum TaskFieldType { text, dropdown, date }

TaskFieldType _parseFieldType(String raw) {
  switch (raw) {
    case 'dropdown':
      return TaskFieldType.dropdown;
    case 'date':
      return TaskFieldType.date;
    case 'text':
    default:
      return TaskFieldType.text;
  }
}

class TaskFormFieldConfig {
  final String id;
  final String label;
  final bool required;
  final TaskFieldType type;
  final List<String> options;

  TaskFormFieldConfig({
    required this.id,
    required this.label,
    required this.required,
    required this.type,
    this.options = const [],
  });

  factory TaskFormFieldConfig.fromMap(Map<String, dynamic> map) {
    return TaskFormFieldConfig(
      id: map['id'] as String,
      label: (map['label'] as String?) ?? map['id'] as String,
      required: (map['required'] as bool?) ?? false,
      type: _parseFieldType(map['type'] as String? ?? 'text'),
      options: (map['options'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          const [],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'label': label,
      'required': required,
      'type': switch (type) {
        TaskFieldType.text => 'text',
        TaskFieldType.dropdown => 'dropdown',
        TaskFieldType.date => 'date',
      },
      'options': options,
    };
  }
}

class TaskFormDefinition {
  final String name;
  final String description;
  final List<TaskFormFieldConfig> fields;

  TaskFormDefinition({
    required this.name,
    required this.description,
    required this.fields,
  });

  factory TaskFormDefinition.fromDoc(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>? ?? {};
    final schema = data['schema'] as Map<String, dynamic>? ?? {};
    final List<dynamic> rawFields = schema['fields'] as List<dynamic>? ?? [];
    final fields = rawFields
        .map((f) => TaskFormFieldConfig.fromMap(f as Map<String, dynamic>))
        .toList();

    return TaskFormDefinition(
      name: data['name'] as String? ?? 'Create Task',
      description:
          data['description'] as String? ?? 'Form to create and assign tasks',
      fields: fields,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'description': description,
      'schema': {
        'fields': fields.map((f) => f.toMap()).toList(),
      },
    };
  }

  factory TaskFormDefinition.fromCacheJson(String json) {
    final data = jsonDecode(json) as Map<String, dynamic>;
    final schema = data['schema'] as Map<String, dynamic>? ?? {};
    final List<dynamic> rawFields = schema['fields'] as List<dynamic>? ?? [];
    final fields = rawFields
        .map((f) => TaskFormFieldConfig.fromMap(f as Map<String, dynamic>))
        .toList();

    return TaskFormDefinition(
      name: data['name'] as String? ?? 'Create Task',
      description:
          data['description'] as String? ?? 'Form to create and assign tasks',
      fields: fields,
    );
  }
}

class TaskFormRepository {
  static const _prefsFormKey = 'cached_task_creation_form';

  final String tenantId;

  TaskFormRepository({required this.tenantId});

  Future<TaskFormDefinition> loadCreateTaskFormOnce() async {
    final prefs = await SharedPreferences.getInstance();
    final cached = prefs.getString(_prefsFormKey);
    if (cached != null) {
      return TaskFormDefinition.fromCacheJson(cached);
    }

    final docRef = FirebaseFirestore.instance
        .collection('tenants')
        .doc(tenantId)
        .collection('forms')
        .doc('task_creation');

    final snap = await docRef.get();
    final def = TaskFormDefinition.fromDoc(snap);

    await prefs.setString(_prefsFormKey, jsonEncode(def.toMap()));
    return def;
  }

  Future<void> createTask({
    required String createdBy,
    required Map<String, dynamic> values,
  }) async {
    final tasksCol = FirebaseFirestore.instance
        .collection('tenants')
        .doc(tenantId)
        .collection('tasks');

    final now = DateTime.now();
    final core = <String, dynamic>{
      'title': values['title'] ?? '',
      'description': values['description'] ?? '',
      'status': 'PENDING',
      'createdby': createdBy,
      'createdat': now.toIso8601String(),
      'updatedat': now.toIso8601String(),
    };

    if (values['dueDate'] != null && values['dueDate'] is DateTime) {
      core['duedate'] = (values['dueDate'] as DateTime).toIso8601String();
    }

    final custom = Map<String, dynamic>.from(values)
      ..remove('title')
      ..remove('description')
      ..remove('dueDate');

    if (custom.isNotEmpty) {
      core['custom_fields'] = custom;
    }

    await tasksCol.add(core);
  }
}

================================================================================

// File: lib\dynamic_screen\model\widget.dart
class WidgetModel {
  final String id;
  final String name;

  WidgetModel({required this.id, required this.name});
}

================================================================================

// File: lib\dynamic_screen\repository\dashboard_repository.dart
import '../model/widget.dart';
import '../widget_manifest.dart';

class DashboardRepository {
  List<WidgetModel> getWidgets() {
    return widgetManifest.map((w) => WidgetModel(id: w['id'] as String, name: w['name'] as String)).toList();
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\complete_task_widget.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart'; // adjust package name if different

class CompleteTaskWidget extends StatelessWidget {
  const CompleteTaskWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Glass color derived from global glass opacity
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = (maxW < maxH ? maxW : maxH);
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.05).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.70).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0);

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // <-- uses the local bgColor
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Complete Task',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'Panel to mark tasks as completed demo.',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\create_task_widget.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

/// Simple non-interactive card widget (no create-task logic).
class CreateTaskWidget extends StatelessWidget {
  const CreateTaskWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same as CompleteTaskWidget [file:4]
      builder: (context, _) {
        final ws = WallpaperService.instance; // [file:4]
        // Same glass color as CompleteTaskWidget
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45)); // [file:4]

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH); // [file:3]
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.05).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.70).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:3]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor,
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ), // same decoration as CompleteTaskWidget except min differences [file:4]
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Task Panel',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ), // [file:3]
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'This area can be used to show summary or status of tasks. '
                      'Creation flow has been removed.',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ), // [file:3]
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Static widget',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.cyanAccent.withOpacity(0.85),
                        fontSize: smallFont,
                      ),
                    ),
                  ), // [file:3]
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\login_widget.dart
// lib/dynamicscreen/widgets/loginwidget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../core/wallpaper_service.dart';

class LoginWidget extends StatefulWidget {
  const LoginWidget({super.key});

  @override
  State<LoginWidget> createState() => _LoginWidgetState();
}

class _LoginWidgetState extends State<LoginWidget> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;

  // DEBUG ID to track widget lifecycle
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString().substring(8);

  _LoginWidgetState() {
    debugPrint('ğŸ”‘ LoginWidget CREATED (ID: $_instanceId)');
  }

  @override
  void dispose() {
    debugPrint('ğŸ”‘ LoginWidget DISPOSED (ID: $_instanceId)');
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> signIn() async {
    debugPrint('ğŸ”‘ LoginWidget #$_instanceId - signIn() START');

    if (!(_formKey.currentState?.validate() ?? false)) {
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - Form validation failed');
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - Calling FirebaseAuth.signInWithEmailAndPassword');
      
      final cred = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );
      
      debugPrint('âœ… LoginWidget #$_instanceId - LOGIN SUCCESS: User ${cred.user?.uid}');
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - NOT navigating manually. Waiting for DashboardScreen listener.');
      
      // âœ… FIX CONFIRMED: NO NAVIGATION CODE HERE!
      // DO NOT call Navigator.pushReplacement()
      // The DashboardScreen's authStateChanges listener will handle the transition.

    } on FirebaseAuthException catch (e) {
      debugPrint('âŒ LoginWidget #$_instanceId - Auth Error: ${e.code} - ${e.message}');
      setState(() {
        _errorMessage = _getErrorMessage(e.code);
      });
    } catch (e) {
      debugPrint('âŒ LoginWidget #$_instanceId - Unknown Error: $e');
      setState(() {
        _errorMessage = "Unexpected error. Please try again.";
      });
    } finally {
      if (mounted) {
        debugPrint('ğŸ”‘ LoginWidget #$_instanceId - signIn() FINISHED, resetting loading state');
        setState(() {
          _isLoading = false;
        });
      } else {
         debugPrint('âš ï¸ LoginWidget #$_instanceId - Widget unmounted after signIn, skipping setState');
      }
    }
  }

  String _getErrorMessage(String code) {
    switch (code) {
      case 'user-not-found':
        return 'No account found. Please register first.';
      case 'wrong-password':
        return 'Incorrect password.';
      case 'invalid-email':
        return 'Invalid email format.';
      case 'user-disabled':
        return 'Account disabled. Contact admin.';
      case 'too-many-requests':
        return 'Too many attempts. Try again later.';
      default:
        return 'Login failed. Please try again.';
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;

        // Glass color derived from global glass opacity
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);

            // When the box is short, compress everything a bit
            final double compress =
                shortest < 360 ? 0.85 : (shortest < 420 ? 0.92 : 1.0);

            final double unit = (shortest / 11.0).clamp(10.0, 32.0) * compress;
            final double radius = (unit * 0.9).clamp(12.0, 24.0);
            final double margin = (unit * 0.22).clamp(6.0, 14.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.65 * compress).clamp(8.0, 20.0));

            final double titleFont = (unit * 1.1).clamp(18.0, 26.0);
            final double subtitleFont = (unit * 0.72).clamp(11.0, 16.0);
            final double fieldFont = (unit * 0.80).clamp(12.0, 18.0);
            final double smallFont = (unit * 0.70).clamp(10.0, 14.0);
            final double gap = (unit * 0.40 * compress).clamp(4.0, 12.0);
            final double fieldVerticalPad =
                (unit * 0.30 * compress).clamp(4.0, 8.0);
            final double fieldRadius = (unit * 0.55).clamp(8.0, 14.0);

            // âœ… Wrap in Material + SingleChildScrollView
            return Material(
              type: MaterialType.transparency,
              child: Container(
                margin: EdgeInsets.all(margin),
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: BorderRadius.circular(radius),
                  border: Border.all(color: const Color(0x22FFFFFF)),
                  boxShadow: const [
                    BoxShadow(
                      color: Color(0x33000000),
                      blurRadius: 18,
                      offset: Offset(0, 10),
                    ),
                  ],
                ),
                padding: padding,
                child: SingleChildScrollView(  // âœ… Make scrollable
                  physics: const BouncingScrollPhysics(),
                  child: Form(
                    key: _formKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // Logo
                        const Icon(
                          Icons.image_outlined,
                          color: Colors.cyanAccent,
                          size: 48,
                        ),
                        SizedBox(height: gap),

                        // Title
                        Text(
                          'Wall-D',
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: titleFont,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        SizedBox(height: gap * 0.5),

                        // Subtitle
                        Text(
                          'Sign in with your work account',
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: Colors.white60,
                            fontSize: subtitleFont,
                          ),
                        ),
                        SizedBox(height: gap * 1.5),

                        // Email field
                        TextFormField(
                          controller: _emailController,
                          keyboardType: TextInputType.emailAddress,
                          style: TextStyle(color: Colors.white, fontSize: fieldFont),
                          decoration: InputDecoration(
                            labelText: 'Email',
                            floatingLabelBehavior: FloatingLabelBehavior.auto,
                            labelStyle: const TextStyle(color: Colors.white70),
                            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                            filled: true,
                            fillColor: Colors.white.withOpacity(0.04),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(
                                color: Colors.cyanAccent,
                                width: 2,
                              ),
                            ),
                            contentPadding: EdgeInsets.symmetric(
                              horizontal: unit * 0.5,
                              vertical: fieldVerticalPad,
                            ),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Email required';
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: gap),

                        // Password field
                        TextFormField(
                          controller: _passwordController,
                          obscureText: true,
                          style: TextStyle(color: Colors.white, fontSize: fieldFont),
                          decoration: InputDecoration(
                            labelText: 'Password',
                            floatingLabelBehavior: FloatingLabelBehavior.auto,
                            labelStyle: const TextStyle(color: Colors.white70),
                            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                            filled: true,
                            fillColor: Colors.white.withOpacity(0.04),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(
                                color: Colors.cyanAccent,
                                width: 2,
                              ),
                            ),
                            contentPadding: EdgeInsets.symmetric(
                              horizontal: unit * 0.5,
                              vertical: fieldVerticalPad,
                            ),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Password required';
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: gap),

                        // Error message (optional)
                        if (_errorMessage != null) ...[
                          Container(
                            width: double.infinity,
                            padding: EdgeInsets.all(unit * 0.35),
                            decoration: BoxDecoration(
                              color: Colors.red.shade900,
                              borderRadius: BorderRadius.circular(fieldRadius),
                              border: Border.all(color: Colors.red.shade700),
                            ),
                            child: Row(
                              children: [
                                const Icon(
                                  Icons.error_outline,
                                  color: Colors.redAccent,
                                  size: 16,
                                ),
                                SizedBox(width: unit * 0.3),
                                Expanded(
                                  child: Text(
                                    _errorMessage!,
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: smallFont,
                                    ),
                                    maxLines: 2,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          SizedBox(height: gap),
                        ],

                        // Sign in button
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            onPressed: _isLoading ? null : signIn,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.cyanAccent,
                              foregroundColor: Colors.black,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(fieldRadius),
                              ),
                              padding: EdgeInsets.symmetric(
                                vertical: fieldVerticalPad + 1,
                              ),
                              elevation: 8,
                            ),
                            child: _isLoading
                                ? SizedBox(
                                    height: unit,
                                    width: unit,
                                    child: const CircularProgressIndicator(
                                      color: Colors.black,
                                      strokeWidth: 2,
                                    ),
                                  )
                                : Text(
                                    'Sign In',
                                    style: TextStyle(
                                      fontSize: fieldFont,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                          ),
                        ),
                        SizedBox(height: gap),

                        Text(
                          "You'll see your dashboard after login",
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            fontSize: smallFont,
                            color: Colors.white38,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\view_all_tasks_widget.dart
// lib/dynamic_screen/widgets/view_all_tasks_widget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

class ViewAllTasksWidget extends StatelessWidget {
  const ViewAllTasksWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same reactive glass source [file:9]
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Same glass color formula as CompleteTaskWidget [file:9]
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.00).clamp(12.0, 24.0);
            final double bodyFont = (unit * 0.66).clamp(10.0, 17.0);
            final double smallFont = (unit * 0.55).clamp(9.0, 15.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:8]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // updated to dynamic glass color [file:9]
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'View All Tasks',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'Summary view of all tasks (demo).',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\view_assigned_tasks_widget.dart
// lib/dynamic_screen/widgets/view_assigned_tasks_widget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

class ViewAssignedTasksWidget extends StatelessWidget {
  const ViewAssignedTasksWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same as CompleteTaskWidget [file:11]
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Same glass color formula as CompleteTaskWidget [file:11]
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);
            final double unit = (shortest / 9.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.90).clamp(12.0, 44.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding = EdgeInsets.symmetric(
              horizontal: (unit * 0.90).clamp(10.0, 30.0),
              vertical: (unit * 0.70).clamp(8.0, 24.0),
            );
            final double titleFont = (unit * 1.10).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.72).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:10]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // updated from 0xCC0B0F1C to glass color [file:10][file:11]
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'View Assigned Tasks',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Align(
                      alignment: Alignment.topLeft,
                      child: Text(
                        'Tasks currently assigned to you will appear here (demo).',
                        maxLines: 4,
                        overflow: TextOverflow.ellipsis,
                        style: TextStyle(
                          color: Colors.white70,
                          fontSize: bodyFont,
                          height: 1.2,
                        ),
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\widgets.dart
// lib/dynamic_screen/widgets/widgets.dart
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import '../model/screen_grid.dart';
import '../widget_factory.dart';

/// Used by DashboardGrid to build a draggable/resizable widget tile.
Widget buildGridWidget({
  required ScreenGridWidgetSpan item,
  required double cellW,
  required double cellH,
  required double maxW,
  required double maxH,
  required double initialLeft,
  required double initialTop,
  required double initialWidthPx,
  required double initialHeightPx,
  required double globalBlur,
  required double globalOpacity,
  required Color globalTint,
  required VoidCallback onSnap,
}) {
  return FreeDragResizeItem(
    key: ValueKey(item.widgetId),
    item: item,
    gridColumns: 24,
    gridRows: 14,
    cellW: cellW,
    cellH: cellH,
    maxW: maxW,
    maxH: maxH,
    initialLeft: initialLeft,
    initialTop: initialTop,
    initialWidthPx: initialWidthPx,
    initialHeightPx: initialHeightPx,
    globalBlur: globalBlur,
    globalOpacity: globalOpacity,
    globalTint: globalTint,
    onSnap: onSnap,
  );
}

class _LiveLayout {
  final double left;
  final double top;
  final double width;
  final double height;

  const _LiveLayout({
    required this.left,
    required this.top,
    required this.width,
    required this.height,
  });

  _LiveLayout copyWith({
    double? left,
    double? top,
    double? width,
    double? height,
  }) {
    return _LiveLayout(
      left: left ?? this.left,
      top: top ?? this.top,
      width: width ?? this.width,
      height: height ?? this.height,
    );
  }
}

/// Draggable + resizable wrapper used by the dashboard grid.
///
/// Performance fixes:
/// - No setState() on each pointer update (uses ValueNotifier for layout).
/// - While dragging/resizing, renders a cheap outline placeholder (no blur/shadow).
/// - Cached inner widget content so it does not rebuild while moving.
class FreeDragResizeItem extends StatefulWidget {
  final ScreenGridWidgetSpan item;

  final int gridColumns;
  final int gridRows;

  final double cellW;
  final double cellH;

  final double maxW;
  final double maxH;

  final double initialLeft;
  final double initialTop;
  final double initialWidthPx;
  final double initialHeightPx;

  final double globalBlur;
  final double globalOpacity;
  final Color globalTint;

  final VoidCallback onSnap;

  const FreeDragResizeItem({
    super.key,
    required this.item,
    required this.gridColumns,
    required this.gridRows,
    required this.cellW,
    required this.cellH,
    required this.maxW,
    required this.maxH,
    required this.initialLeft,
    required this.initialTop,
    required this.initialWidthPx,
    required this.initialHeightPx,
    required this.globalBlur,
    required this.globalOpacity,
    required this.globalTint,
    required this.onSnap,
  });

  @override
  State<FreeDragResizeItem> createState() => _FreeDragResizeItemState();
}

class _FreeDragResizeItemState extends State<FreeDragResizeItem> {
  // Cached widget content
  Widget? _cachedContent;
  String? _cachedWidgetId;

  // Live layout updated without setState()
  late final ValueNotifier<_LiveLayout> _layoutVN;

  // Interaction state (dragging/resizing)
  late final ValueNotifier<bool> _interactingVN;

  // Drag state
  Offset? _dragStartGlobal;
  _LiveLayout? _dragStartLayout;

  // Resize state
  Offset? _resizeStartGlobal;
  _LiveLayout? _resizeStartLayout;

  static const double _minSpan = 2; // min 2x2 cells
  static const double _handleSize = 18;

  bool get _isDragging => _dragStartGlobal != null;
  bool get _isResizing => _resizeStartGlobal != null;
  bool get _isInteracting => _isDragging || _isResizing;

  @override
  void initState() {
    super.initState();

    _layoutVN = ValueNotifier<_LiveLayout>(
      _LiveLayout(
        left: widget.initialLeft,
        top: widget.initialTop,
        width: widget.initialWidthPx,
        height: widget.initialHeightPx,
      ),
    );

    _interactingVN = ValueNotifier<bool>(false);

    _buildCachedContent();
  }

  @override
  void didUpdateWidget(covariant FreeDragResizeItem oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.item.widgetId != widget.item.widgetId) {
      _buildCachedContent();
    }

    if (!_isInteracting) {
      _layoutVN.value = _LiveLayout(
        left: (widget.item.col * widget.cellW)
            .clamp(0.0, math.max(0.0, widget.maxW - widget.cellW)),
        top: (widget.item.row * widget.cellH)
            .clamp(0.0, math.max(0.0, widget.maxH - widget.cellH)),
        width: (widget.item.colSpan * widget.cellW)
            .clamp(widget.cellW * _minSpan, widget.maxW),
        height: (widget.item.rowSpan * widget.cellH)
            .clamp(widget.cellH * _minSpan, widget.maxH),
      );
    }
  }

  @override
  void dispose() {
    _layoutVN.dispose();
    _interactingVN.dispose();
    super.dispose();
  }

  void _buildCachedContent() {
    _cachedWidgetId = widget.item.widgetId;
    _cachedContent = RepaintBoundary(
      child: DynamicWidgetFactory.create(widget.item.widgetId),
    );
  }

  double _clampLeft(double left, double width) {
    final maxLeft = math.max(0.0, widget.maxW - width);
    return left.clamp(0.0, maxLeft);
  }

  double _clampTop(double top, double height) {
    final maxTop = math.max(0.0, widget.maxH - height);
    return top.clamp(0.0, maxTop);
  }

  double _clampWidth(double width) {
    final minW = widget.cellW * _minSpan;
    return width.clamp(minW, widget.maxW);
  }

  double _clampHeight(double height) {
    final minH = widget.cellH * _minSpan;
    return height.clamp(minH, widget.maxH);
  }

  void _setInteracting(bool v) {
    if (_interactingVN.value != v) _interactingVN.value = v;
  }

  // Drag handlers
  void _onDragStart(DragStartDetails d) {
    _dragStartGlobal = d.globalPosition;
    _dragStartLayout = _layoutVN.value;
    _setInteracting(true);
  }

  void _onDragUpdate(DragUpdateDetails d) {
    if (_dragStartGlobal == null || _dragStartLayout == null) return;

    final delta = d.globalPosition - _dragStartGlobal!;
    final start = _dragStartLayout!;

    final newLeft = _clampLeft(start.left + delta.dx, start.width);
    final newTop = _clampTop(start.top + delta.dy, start.height);

    _layoutVN.value = start.copyWith(left: newLeft, top: newTop);
  }

  void _onDragEnd([DragEndDetails? _]) {
    _dragStartGlobal = null;
    _dragStartLayout = null;
    _snapToGridAndPersist();
  }

  // Resize handlers
  void _onResizeStart(DragStartDetails d) {
    _resizeStartGlobal = d.globalPosition;
    _resizeStartLayout = _layoutVN.value;
    _setInteracting(true);
  }

  void _onResizeUpdate(DragUpdateDetails d) {
    if (_resizeStartGlobal == null || _resizeStartLayout == null) return;

    final delta = d.globalPosition - _resizeStartGlobal!;
    final start = _resizeStartLayout!;

    final newWidth = _clampWidth(start.width + delta.dx);
    final newHeight = _clampHeight(start.height + delta.dy);

    final newLeft = _clampLeft(start.left, newWidth);
    final newTop = _clampTop(start.top, newHeight);

    _layoutVN.value = start.copyWith(
      left: newLeft,
      top: newTop,
      width: newWidth,
      height: newHeight,
    );
  }

  void _onResizeEnd([DragEndDetails? _]) {
    _resizeStartGlobal = null;
    _resizeStartLayout = null;
    _snapToGridAndPersist();
  }

  void _snapToGridAndPersist() {
    final l = _layoutVN.value;

    int col = (l.left / widget.cellW).round();
    int row = (l.top / widget.cellH).round();
    int colSpan = (l.width / widget.cellW).round();
    int rowSpan = (l.height / widget.cellH).round();

    colSpan = colSpan.clamp(_minSpan.toInt(), widget.gridColumns);
    rowSpan = rowSpan.clamp(_minSpan.toInt(), widget.gridRows);

    col = col.clamp(0, widget.gridColumns - colSpan);
    row = row.clamp(0, widget.gridRows - rowSpan);

    widget.item
      ..col = col
      ..row = row
      ..colSpan = colSpan
      ..rowSpan = rowSpan;

    _layoutVN.value = _LiveLayout(
      left: col * widget.cellW,
      top: row * widget.cellH,
      width: colSpan * widget.cellW,
      height: rowSpan * widget.cellH,
    );

    _setInteracting(false);
    widget.onSnap();
  }

  // Outline-only placeholder used while interacting
  Widget _buildCheapPlaceholder() {
    final borderColor = Colors.cyanAccent.withOpacity(0.55);
    final glowColor = Colors.cyanAccent.withOpacity(0.12);

    return IgnorePointer(
      child: Container(
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(24),
          border: Border.all(color: borderColor, width: 2),
          boxShadow: [
            BoxShadow(
              color: glowColor,
              blurRadius: 10,
              spreadRadius: 1,
            ),
          ],
        ),
        child: const SizedBox.expand(),
      ),
    );
  }

  Widget _buildFullGlassCard(Widget content) {
    // Global blur is applied in WorkspaceShell; disable per-widget blur.
    return GlassContainer(
      blur: widget.globalBlur, 
      opacity: widget.globalOpacity,
      tint: widget.globalTint,
      blurMode: GlassBlurMode.perWidget,  // âœ… Enable blur
      borderRadius: BorderRadius.circular(24),
      qualityMode: GlassQualityMode.auto,
      isInteracting: _isInteracting,
      disableShadows: false,
      padding: EdgeInsets.zero,
      child: content,
    );
  }

  @override
  Widget build(BuildContext context) {
    final content = _cachedContent ?? const SizedBox.shrink();

    // Only this tile rebuilds per tick; expensive inner content is cached.
    return ValueListenableBuilder<_LiveLayout>(
      valueListenable: _layoutVN,
      builder: (context, l, _) {
        return Positioned(
          left: l.left,
          top: l.top,
          width: l.width,
          height: l.height,

          // IMPORTANT: Positioned is the direct child of the Stack in DashboardGrid.
          child: RepaintBoundary(
            child: Stack(
              children: [
                // Card surface: placeholder vs full glass
                Positioned.fill(
                  child: ValueListenableBuilder<bool>(
                    valueListenable: _interactingVN,
                    builder: (context, interacting, __) {
                      if (interacting) {
                        return _buildCheapPlaceholder();
                      }
                      return _buildFullGlassCard(content);
                    },
                  ),
                ),

                // Drag overlay
                Positioned.fill(
                  child: Listener(
                    behavior: HitTestBehavior.translucent,
                    child: GestureDetector(
                      behavior: HitTestBehavior.translucent,
                      onPanStart: _onDragStart,
                      onPanUpdate: _onDragUpdate,
                      onPanEnd: _onDragEnd,
                      child: const SizedBox.expand(),
                    ),
                  ),
                ),

                // Resize handle (bottom-right)
                Positioned(
                  right: 6,
                  bottom: 6,
                  child: Listener(
                    behavior: HitTestBehavior.opaque,
                    child: GestureDetector(
                      onPanStart: _onResizeStart,
                      onPanUpdate: _onResizeUpdate,
                      onPanEnd: _onResizeEnd,
                      child: Container(
                        width: _handleSize,
                        height: _handleSize,
                        decoration: BoxDecoration(
                          color: Colors.white
                              .withOpacity(_isInteracting ? 0.10 : 0.14),
                          borderRadius: BorderRadius.circular(6),
                          border: Border.all(
                            color: Colors.white.withOpacity(0.18),
                            width: 1,
                          ),
                        ),
                        child: Icon(
                          Icons.open_in_full,
                          size: 12,
                          color: Colors.white.withOpacity(0.65),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\task\task_tabs_manifest.dart
import 'package:flutter/material.dart';
import '../core/wallpaper_service.dart'; // NEW IMPORT
import 'pages/create_task_page/create_task_page.dart';
import 'pages/view_all_tasks_page/view_all_tasks_page.dart';
import 'pages/view_assigned_tasks_page/view_assigned_tasks_page.dart';
import 'pages/complete_task_page.dart';

class TaskTabIds {
  static const create = 'create';
  static const viewAll = 'viewall';
  static const viewAssigned = 'viewassigned';
  static const complete = 'complete';
}

class TaskTabDef {
  final String id;
  final String title;
  final IconData icon;
  final WidgetBuilder builder;

  TaskTabDef({
    required this.id,
    required this.title,
    required this.icon,
    required this.builder,
  });
}

final List<TaskTabDef> taskTabs = [
  TaskTabDef(
    id: TaskTabIds.create,
    title: 'Create',
    icon: Icons.add_task_rounded,
    builder: (context) => const CreateTaskPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.viewAssigned,
    title: 'Assigned',
    icon: Icons.assignment_ind_rounded,
    builder: (context) => const ViewAssignedTasksPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.viewAll,
    title: 'All',
    icon: Icons.view_list_rounded,
    builder: (context) => const ViewAllTasksPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.complete,
    title: 'Complete',
    icon: Icons.check_circle_rounded,
    builder: (context) => const CompleteTaskPage(),
  ),
];

/// UPDATED: Now uses WallpaperService instead of local gradient
BoxDecoration backgroundDecoration() {
  return WallpaperService.instance.backgroundDecoration;
}

================================================================================

// File: lib\task\task_workspace.dart
// lib/task/task_workspace.dart

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../core/glass_container.dart';
import '../core/wallpaper_service.dart';

import 'pages/complete_task_page.dart';
import 'pages/create_task_page/create_task_page.dart';
import 'pages/view_all_tasks_page/view_all_tasks_page.dart';
import 'pages/view_assigned_tasks_page/view_assigned_tasks_page.dart';

import 'task_tabs_manifest.dart';
import 'widgets/task_side_panel.dart';

class TaskWorkspace extends StatefulWidget {
  const TaskWorkspace({super.key});

  @override
  State<TaskWorkspace> createState() => TaskWorkspaceState();
}

class TaskWorkspaceState extends State<TaskWorkspace> {
  // Match TaskTabIds from task_tabs_manifest.dart
  String selectedTabId = TaskTabIds.viewAssigned;

  TaskTabDef get _currentTab =>
      taskTabs.firstWhere((t) => t.id == selectedTabId, orElse: () => taskTabs.first);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final double glassBlur = WallpaperService.instance.globalGlassBlur;
        final double glassOpacity = WallpaperService.instance.globalGlassOpacity;

        return Padding(
          padding: const EdgeInsets.fromLTRB(18, 70, 18, 18),
          child: Row(
            children: [
              // LEFT: side panel â€“ API fixed to match TaskSidePanel
              SizedBox(
                width: 240,
                child: TaskSidePanel(
                  selectedTabId: selectedTabId,
                  onSelect: (id) {
                    setState(() {
                      selectedTabId = id;
                    });
                  },
                ),
              ),

              const SizedBox(width: 18),

              // RIGHT: main glass content
              Expanded(
                child: GlassContainer(
                  blur: glassBlur,
                  opacity: glassOpacity,
                  tint: Colors.white,
                  borderRadius: BorderRadius.circular(24),
                  padding: const EdgeInsets.all(24),
                  // OLD:
                  // blurMode: GlassBlurMode.auto,
                  // NEW: force blur for this panel
                  blurMode: GlassBlurMode.perWidget,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Header uses TaskTabDef.title/icon (no .name)
                      Row(
                        children: [
                          Icon(
                            _currentTab.icon,
                            color: Colors.cyan,
                            size: 28,
                          ),
                          const SizedBox(width: 12),
                          Text(
                            _currentTab.title,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const Spacer(),
                          if (kDebugMode)
                            Text(
                              'Blur: ${glassBlur.toStringAsFixed(1)}  |  '
                              'Opacity: ${(glassOpacity * 100).toStringAsFixed(0)}%',
                              style: const TextStyle(
                                color: Colors.white54,
                                fontSize: 12,
                                fontFamily: 'monospace',
                              ),
                            ),
                        ],
                      ),

                      const SizedBox(height: 24),

                      // Body: use builder from TaskTabDef so pages stay singleâ€‘sourced
                      Expanded(
                        child: _currentTab.builder(context),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\task\pages\complete_task_page.dart
import 'package:flutter/material.dart';

class CompleteTaskPage extends StatelessWidget {
  const CompleteTaskPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text('Complete Task (full-screen page placeholder)', style: TextStyle(color: Colors.white70)),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\create_task_page.dart
import 'dart:math' as math;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../Developer/DynamicForms/dynamic_forms_repository.dart';
import '../../../Developer/DynamicForms/form_models.dart';
import 'models/assignment_data.dart';
import 'widgets/task_form_renderer.dart';

class CreateTaskPage extends StatefulWidget {
  const CreateTaskPage({super.key});

  @override
  State<CreateTaskPage> createState() => _CreateTaskPageState();
}

class _CreateTaskPageState extends State<CreateTaskPage> {
  static const String tenantId = 'default_tenant';

  static FormSchemaMeta? _cachedTaskCreationForm;
  static Object? _cachedLoadError;

  final DynamicFormsRepository _repo = DynamicFormsRepository();
  final GlobalKey<TaskFormRendererState> _rendererKey =
      GlobalKey<TaskFormRendererState>();

  FormSchemaMeta? _form;
  bool _loading = true;
  bool _submitting = false;

  @override
  void initState() {
    super.initState();
    if (_cachedTaskCreationForm != null || _cachedLoadError != null) {
      _form = _cachedTaskCreationForm;
      _loading = false;
    } else {
      _loadFormOnce();
    }
  }

  Future<void> _loadFormOnce() async {
    try {
      final forms = await _repo.loadForms(tenantId);
      final found = forms.firstWhere(
        (f) => f.formId == 'task_creation',
        orElse: () => forms.first,
      );
      _cachedTaskCreationForm = found;
      _cachedLoadError = null;
      if (!mounted) return;
      setState(() {
        _form = found;
        _loading = false;
      });
    } catch (e) {
      _cachedLoadError = e;
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _createTaskFromPayload(Map<String, dynamic> values) async {
  final user = FirebaseAuth.instance.currentUser;
  debugPrint('TASK_CREATE: createTaskFromPayload START, values=$values');

  if (user == null) {
    debugPrint('TASK_CREATE: ERROR â€“ user is null (not logged in)');
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('You must be logged in to create a task'),
        backgroundColor: Colors.redAccent,
      ),
    );
    return;
  }

  setState(() => _submitting = true);

  try {
    final now = DateTime.now();
    final tasksCol = FirebaseFirestore.instance
        .collection('tenants')
        .doc(tenantId)
        .collection('tasks');

    debugPrint('TASK_CREATE: tasksCol path = tenants/$tenantId/tasks');

    final renderer = _rendererKey.currentState;
    if (renderer == null) {
      debugPrint('TASK_CREATE: ERROR â€“ rendererKey.currentState is null');
      throw Exception('Form renderer not available');
    }

    final assignmentData = renderer.getAssignmentData();
    debugPrint('TASK_CREATE: assignmentData = $assignmentData');

    if (assignmentData == null || !assignmentData.isValid) {
      debugPrint('TASK_CREATE: ERROR â€“ assignmentData invalid or null');
      throw Exception('Invalid assignment data');
    }

    if (assignmentData.assignmentType == 'subordinateunit') {
  // hierarchy / subordinate unit path
  final headUid =
      assignmentData.nodeToHeadUserMap[assignmentData.selectedNodeId];
  debugPrint(
      'TASK_CREATE: path=subordinateunit, headUid=$headUid, nodeId=${assignmentData.selectedNodeId}');

  await _createSingleTask(
    tasksCol,
    values,
    user.uid,
    now,
    headUid,
    null,
    assignmentData.groupName,
  );
} else if (assignmentData.assignmentType == 'teammember' ||
           assignmentData.assignmentType == 'team_member') {
  // âœ… team member path (both spellings)
  debugPrint(
      'TASK_CREATE: path=team_member, raw selectedUserIds=${assignmentData.selectedUserIds}, lead=${assignmentData.leadMemberId}, group=${assignmentData.groupName}');

  final cleanedUserIds = assignmentData.selectedUserIds
      .where((id) => id != user.uid)
      .toList();

  debugPrint(
      'TASK_CREATE: cleaned selectedUserIds (without self)=$cleanedUserIds');

  if (cleanedUserIds.isEmpty) {
    debugPrint('TASK_CREATE: ERROR â€“ cleanedUserIds is empty');
    throw Exception('You must assign the task to at least one team member');
  }

  await _createTeamMemberTasks(
    tasksCol,
    values,
    user.uid,
    now,
    cleanedUserIds,
    assignmentData.groupName,
    assignmentData.leadMemberId,
  );
} else {
  debugPrint(
      'TASK_CREATE: ERROR â€“ unknown assignmentType=${assignmentData.assignmentType}');
  throw Exception('Unknown assignment type');
}


    debugPrint('TASK_CREATE: SUCCESS â€“ all writes finished');

    if (!mounted) return;

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Tasks created successfully'),
        backgroundColor: Colors.cyan,
      ),
    );

    _rendererKey.currentState?.resetForm();
  } catch (e, st) {
    debugPrint('TASK_CREATE: EXCEPTION $e');
    debugPrint('TASK_CREATE: STACKTRACE $st');

    if (!mounted) return;

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Failed to create task: $e'),
        backgroundColor: Colors.redAccent,
      ),
    );
  } finally {
    if (mounted) {
      setState(() => _submitting = false);
      debugPrint('TASK_CREATE: FINISHED (submitting=false)');
    }
  }
}



  // single-assignee path (subordinate unit)
  Future<void> _createSingleTask(
  CollectionReference tasksCol,
  Map<String, dynamic> values,
  String assignerUid,
  DateTime now,
  String? assignedToUserId,
  String? groupId,
  String? groupName,
) async {
  debugPrint(
      'TASK_CREATE_SINGLE: START assignedTo=$assignedToUserId groupId=$groupId groupName=$groupName');

  final data = <String, dynamic>{
    'title': values['title'] ?? '',
    'description': values['description'] ?? '',
    'status': 'PENDING',
    'assignedby': assignerUid,
    if (assignedToUserId != null) 'assignedto': assignedToUserId,
    'createdat': now.toIso8601String(),
    'updatedat': now.toIso8601String(),
    if (groupId != null) 'groupid': groupId,
    if (groupName != null && groupName.isNotEmpty) 'groupname': groupName,
  };

  final customfields = Map<String, dynamic>.from(values)
    ..remove('title')
    ..remove('description')
    ..remove('assignee');

  final renderer = _rendererKey.currentState;
  final due = renderer?.getSelectedDueDate();
  if (due != null) {
    data['duedate'] = due.toIso8601String();
  }

  if (customfields.isNotEmpty) {
    data['customfields'] = customfields;
  }

  debugPrint('TASK_CREATE_SINGLE: data payload = $data');

  final docRef = await tasksCol.add(data);
  debugPrint(
      'TASK_CREATE_SINGLE: Firestore add OK docId=${docRef.id} assignedTo=$assignedToUserId');
}


  // multi-user path (team members) with lead_member
  Future<void> _createTeamMemberTasks(
  CollectionReference tasksCol,
  Map<String, dynamic> values,
  String assignerUid,
  DateTime now,
  List<String> userIds,
  String? groupName,
  String? leadMemberId,
) async {
  debugPrint(
      'TASK_CREATE_GROUP: START users=$userIds groupName=$groupName lead=$leadMemberId');

  String? groupId;

  if (userIds.length == 1) {
    // Single assignee path
    await _createSingleTask(
      tasksCol,
      values,
      assignerUid,
      now,
      userIds.first,
      null,
      groupName,
    );
    debugPrint('TASK_CREATE_GROUP: Delegated to createSingleTask (1 user)');
    return;
  }

  // Multi-user group path
  try {
    if (groupName != null && groupName.trim().isNotEmpty) {
      final groupDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('taskgroups')
          .add({
        'name': groupName,
        'createdby': assignerUid,
        'createdat': now.toIso8601String(),
        'membercount': userIds.length,
        'members': userIds,
        'leadmember': leadMemberId,
      });

      groupId = groupDoc.id;
      debugPrint('TASK_CREATE_GROUP: group doc created id=$groupId');
    } else {
      debugPrint('TASK_CREATE_GROUP: WARNING â€“ groupName is null/empty');
    }

    final allAssigneesString = userIds.join(',');
    final data = <String, dynamic>{
      'title': values['title'] ?? '',
      'description': values['description'] ?? '',
      'status': 'PENDING',
      'assignedby': assignerUid,
      'assignedto': allAssigneesString,
      'createdat': now.toIso8601String(),
      'updatedat': now.toIso8601String(),
      'groupid': groupId,
      'groupname': groupName,
      'leadmember': leadMemberId,
    };

    final customfields = Map<String, dynamic>.from(values)
      ..remove('title')
      ..remove('description')
      ..remove('assignee');

    final renderer = _rendererKey.currentState;
    final due = renderer?.getSelectedDueDate();
    if (due != null) {
      data['duedate'] = due.toIso8601String();
    }

    if (customfields.isNotEmpty) {
      data['customfields'] = customfields;
    }

    debugPrint('TASK_CREATE_GROUP: task payload = $data');

    final docRef = await tasksCol.add(data);
    debugPrint(
        'TASK_CREATE_GROUP: Firestore add OK docId=${docRef.id} users=$allAssigneesString lead=$leadMemberId');
  } catch (e, st) {
    debugPrint('TASK_CREATE_GROUP: EXCEPTION $e');
    debugPrint('TASK_CREATE_GROUP: STACKTRACE $st');
    rethrow;
  }
}


  Future<void> _onCreatePressed() async {
    final state = _rendererKey.currentState;
    if (state == null) return;

    final payload = await state.submitExternally();
    if (payload == null) return;

    await _createTaskFromPayload(payload);
  }

  @override
  Widget build(BuildContext context) {
    final loadError = _cachedLoadError;

    if (_loading) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
        ),
      );
    }

    if (_form == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.error_outline_rounded,
              color: Colors.redAccent,
              size: 48,
            ),
            const SizedBox(height: 16),
            Text(
              loadError == null
                  ? 'Create Task form config not available.'
                  : 'Failed to load form',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
            if (loadError != null) ...[
              const SizedBox(height: 8),
              Text(
                loadError.toString(),
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 12,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ],
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (_form!.description.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: Text(
              _form!.description,
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 14,
              ),
            ),
          ),
        Expanded(
          child: TaskFormRenderer(
            key: _rendererKey,
            tenantId: tenantId,
            form: _form!,
          ),
        ),
        const SizedBox(height: 16),
        SizedBox(
          width: double.infinity,
          height: 48,
          child: FilledButton.icon(
            onPressed: _submitting ? null : _onCreatePressed,
            icon: _submitting
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation(Colors.black),
                    ),
                  )
                : const Icon(Icons.add_task_rounded),
            label: Text(_submitting ? 'Creatingâ€¦' : 'Create Task'),
          ),
        ),
      ],
    );
  }
  
}

================================================================================

// File: lib\task\pages\create_task_page\mixins\user_data_loader_mixin.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

mixin UserDataLoaderMixin<T extends StatefulWidget> on State<T> {
  int? _currentUserLevel;
  String? _currentUserNodeId;

  int? get currentUserLevel => _currentUserLevel;
  String? get currentUserNodeId => _currentUserNodeId;

  Future<void> loadCurrentUserData(String tenantId) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final userDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('users')
          .doc(user.uid)
          .get();

      if (!userDoc.exists) return;

      final data = userDoc.data();
      if (data == null) return;

      if (mounted) {
        setState(() {
          _currentUserLevel = data['level'] as int?;
          _currentUserNodeId = data['nodeId'] as String?;
        });
      }

      debugPrint(
          'Loaded current user: level=$_currentUserLevel, nodeId=$_currentUserNodeId');
    } catch (e) {
      debugPrint('Error loading current user data: $e');
    }
  }
}

================================================================================

// File: lib\task\pages\create_task_page\models\assignment_data.dart
class AssignmentData {
  final String assignmentType; // 'subordinateunit' or 'team_member'
  final String? selectedNodeId; // for subordinateunit
  final List<String> selectedUserIds; // for team_member
  final String? groupName; // for multi-user team_member
  final String? leadMemberId; // â† NEW: lead member UID for groups
  final Map<String, String> nodeToHeadUserMap; // nodeId -> headUserId mapping

  AssignmentData({
    required this.assignmentType,
    this.selectedNodeId,
    this.selectedUserIds = const [],
    this.groupName,
    this.leadMemberId,
    this.nodeToHeadUserMap = const {},
  });

  bool get isValid {
    if (assignmentType == 'subordinateunit') {
      return selectedNodeId != null && selectedNodeId != 'none';
    } else if (assignmentType == 'team_member') {
      if (selectedUserIds.isEmpty) return false;
      
      // If multiple users, group name AND lead member are required
      if (selectedUserIds.length > 1) {
        return groupName != null && 
               groupName!.trim().isNotEmpty &&
               leadMemberId != null &&
               selectedUserIds.contains(leadMemberId);
      }
      return true;
    }
    return false;
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\assignment_type_selector.dart
import 'package:flutter/material.dart';
import '../../../../core/glass_container.dart';

class AssignmentTypeSelector extends StatelessWidget {
  final String? selectedType;
  final ValueChanged<String?> onChanged;

  const AssignmentTypeSelector({
    super.key,
    required this.selectedType,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final items = [
      const DropdownMenuItem(
        value: 'subordinateunit',
        child: Text(
          'Subordinate Unit (Department/Team)',
          style: TextStyle(color: Colors.white),
        ),
      ),
      const DropdownMenuItem(
        value: 'team_member',
        child: Text(
          'Team Member (Colleague)',
          style: TextStyle(color: Colors.white),
        ),
      ),
    ];

    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: PopupMenuButton<String>(
        color: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(14),
        ),
        offset: const Offset(0, 8),
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: 'Assignment Type',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon: const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
          ),
          child: Text(
            selectedType == 'subordinateunit'
                ? 'Subordinate Unit'
                : selectedType == 'team_member'
                    ? 'Team Member'
                    : 'Select Type',
            style: const TextStyle(color: Colors.white),
          ),
        ),
        itemBuilder: (context) => items
            .map(
              (item) => PopupMenuItem<String>(
                value: item.value,
                padding: EdgeInsets.zero,
                child: GlassContainer(
                  blur: 28,
                  opacity: 0.3,
                  tint: Colors.black,
                  blurMode: GlassBlurMode.perWidget,
                  borderRadius: BorderRadius.circular(10),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: SizedBox(
                    width: 250,
                    child: item.child,
                  ),
                ),
              ),
            )
            .toList(),
        onSelected: onChanged,
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\dynamic_date_field.dart
import 'package:flutter/material.dart';
import '../../../../core/glass_container.dart';

class DynamicDateField extends StatefulWidget {
  final String label;
  final bool required;
  final ValueChanged<DateTime?> onChanged;

  const DynamicDateField({
    super.key,
    required this.label,
    required this.required,
    required this.onChanged,
  });

  @override
  State<DynamicDateField> createState() => _DynamicDateFieldState();
}

class _DynamicDateFieldState extends State<DynamicDateField> {
  DateTime? _value;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: InkWell(
        onTap: _pickDateTime,
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: widget.label,
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon:
                const Icon(Icons.calendar_today, color: Colors.cyanAccent),
          ),
          child: Text(
            _value == null
                ? 'Select date & time'
                : '${_value!.year}-${_value!.month.toString().padLeft(2, '0')}-${_value!.day.toString().padLeft(2, '0')} '
                    '${_value!.hour.toString().padLeft(2, '0')}:${_value!.minute.toString().padLeft(2, '0')}',
            style: const TextStyle(color: Colors.white),
          ),
        ),
      ),
    );
  }

  Future<void> _pickDateTime() async {
    final now = DateTime.now();
    final initial = _value ?? now;

    final pickedDate = await showDatePicker(
      context: context,
      initialDate: initial.isBefore(now) ? now : initial,
      firstDate: now,
      lastDate: DateTime(now.year + 10),
      builder: (context, child) {
        return Theme(
          data: ThemeData.dark().copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Colors.cyanAccent,
              onPrimary: Colors.black,
              surface: Colors.transparent,
              onSurface: Colors.white,
            ),
            dialogBackgroundColor: Colors.transparent,
          ),
          child: _wrapGlass(child!),
        );
      },
    );

    if (pickedDate == null) return;

    final pickedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(initial),
      builder: (context, child) {
        return Theme(
          data: ThemeData.dark().copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Colors.cyanAccent,
              onPrimary: Colors.black,
              surface: Colors.transparent,
              onSurface: Colors.white,
            ),
            dialogBackgroundColor: Colors.transparent,
          ),
          child: _wrapGlass(child!),
        );
      },
    );

    if (pickedTime == null) return;

    final combined = DateTime(
      pickedDate.year,
      pickedDate.month,
      pickedDate.day,
      pickedTime.hour,
      pickedTime.minute,
    );

    final clamped = combined.isBefore(now) ? now : combined;
    setState(() => _value = clamped);
    widget.onChanged(clamped);
  }

  Widget _wrapGlass(Widget child) {
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(
          minWidth: 640,
          maxWidth: 640,
          minHeight: 420,
          maxHeight: 420,
        ),
        child: GlassContainer(
          blur: 40,
          opacity: 0.22,
          tint: Colors.black,
          borderRadius: BorderRadius.circular(22),
          blurMode: GlassBlurMode.perWidget,
          padding: const EdgeInsets.all(8),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(18),
            child: child,
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\task_form_renderer.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import '../../../../Developer/DynamicForms/form_models.dart';
import '../../../../core/glass_container.dart';
import '../mixins/user_data_loader_mixin.dart';
import '../models/assignment_data.dart';
import 'assignment_type_selector.dart';
import 'dynamic_date_field.dart';
import 'team_member_selector.dart';

class TaskFormRenderer extends StatefulWidget {
  final String tenantId;
  final FormSchemaMeta form;

  const TaskFormRenderer({
    super.key,
    required this.tenantId,
    required this.form,
  });

  @override
  State<TaskFormRenderer> createState() => TaskFormRendererState();
}

class TaskFormRendererState extends State<TaskFormRenderer>
    with UserDataLoaderMixin {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, dynamic> _values = {};
  final Map<String, bool> _checkboxValues = {};
  final Map<String, String?> _dropdownValues = {};
  final Map<String, List<DropdownMenuItem<String>>> _dropdownItems = {};
  final Map<String, bool> _loadingDropdown = {};

  // Assignment tracking
  String? _assignmentType;
  String? _selectedNodeId;
  List<String> _selectedUserIds = [];
  String? _groupName;
  String? _leadMemberId; // NEW: selected lead member UID
  Map<String, String> _nodeToHeadUserMap = {};

  DateTime? getSelectedDueDate() {
    final key = firstDateFieldKey;
    if (key == null) return null;
    final v = _values[key];
    return v is DateTime ? v : null;
  }

  String? get firstDateFieldKey {
    for (final f in widget.form.fields) {
      if (f.type == 'date') return f.id;
    }
    return null;
  }

  AssignmentData? getAssignmentData() {
    return AssignmentData(
      assignmentType: _assignmentType ?? '',
      selectedNodeId: _selectedNodeId,
      selectedUserIds: _selectedUserIds,
      groupName: _groupName,
      leadMemberId: _leadMemberId, // NEW
      nodeToHeadUserMap: _nodeToHeadUserMap,
    );
  }

  @override
  void initState() {
    super.initState();
    loadCurrentUserData(widget.tenantId);

    for (final field in widget.form.fields) {
      if (field.type == 'checkbox') {
        _checkboxValues[field.id] = false;
      } else if (field.type == 'dropdown') {
        _dropdownValues[field.id] =
            field.options.isNotEmpty ? field.options.first.toString() : null;
        _loadDropdownOptions(field);
      } else if (field.type == 'date') {
        _values[field.id] = null;
      } else {
        _controllers[field.id] = TextEditingController();
      }
    }
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  void resetForm() {
    _formKey.currentState?.reset();
    for (final c in _controllers.values) {
      c.clear();
    }
    for (final key in _checkboxValues.keys) {
      _checkboxValues[key] = false;
    }
    _assignmentType = null;
    _selectedNodeId = null;
    _selectedUserIds.clear();
    _groupName = null;
    _leadMemberId = null; // NEW
    _values.clear();
    setState(() {});
  }

  Future<void> _loadDropdownOptions(FormFieldMeta field) async {
    // Skip assignTo - custom assignment section handles it
    if (field.id.toLowerCase() == 'assignto' ||
        field.id.toLowerCase() == 'assign_to' ||
        field.label.toLowerCase().contains('assign to')) {
      return;
    }

    final canLoadFromFirestore = field.dataSource == 'firestore' &&
        field.collection != null &&
        field.displayField != null &&
        field.valueField != null;

    if (!canLoadFromFirestore) {
      _dropdownItems[field.id] = field.options
          .map(
            (o) => DropdownMenuItem<String>(
              value: o.toString(),
              child: Text(
                o.toString(),
                style: const TextStyle(color: Colors.white),
              ),
            ),
          )
          .toList();
      if (mounted) setState(() {});
      return;
    }

    if (mounted) setState(() => _loadingDropdown[field.id] = true);

    try {
      final snap = await FirebaseFirestore.instance
          .collection('tenants/${widget.tenantId}/${field.collection}')
          .get();

      final items = snap.docs.map((doc) {
        final data = doc.data();
        final value = data[field.valueField] ?? doc.id;
        final label = data[field.displayField] ?? value.toString();
        return DropdownMenuItem<String>(
          value: value.toString(),
          child: Text(
            label.toString(),
            style: const TextStyle(color: Colors.white),
          ),
        );
      }).toList();

      _dropdownItems[field.id] = items;
      if (_dropdownValues[field.id] == null && items.isNotEmpty) {
        _dropdownValues[field.id] = items.first.value;
      }
    } finally {
      if (mounted) setState(() => _loadingDropdown[field.id] = false);
    }
  }

  Future<void> _loadSubordinateUnits() async {
    if (currentUserLevel == null || currentUserNodeId == null) {
      await loadCurrentUserData(widget.tenantId);
    }

    if (currentUserLevel == null || currentUserNodeId == null) {
      debugPrint('Cannot load subordinate units: user data not available');
      return;
    }

    final targetLevel = currentUserLevel! + 1;

    try {
      final hierarchySnap = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(widget.tenantId)
          .collection('organizations')
          .doc('hierarchy')
          .collection('nodes')
          .where('level', isEqualTo: targetLevel)
          .where('isActive', isEqualTo: true)
          .where('parentId', isEqualTo: currentUserNodeId)
          .get();

      final Map<String, String> nodeToHead = {};
      final List<DropdownMenuItem<String>> items = [];

      for (final nodeDoc in hierarchySnap.docs) {
        final nodeId = nodeDoc.id;
        final nodeData = nodeDoc.data();
        final nodeName = nodeData['name'] as String? ?? nodeId;
        final nodeType = nodeData['type'] as String? ?? 'unit';

        final headSnap = await FirebaseFirestore.instance
            .collection('tenants')
            .doc(widget.tenantId)
            .collection('users')
            .where('nodeId', isEqualTo: nodeId)
            .where('level', isEqualTo: targetLevel)
            .where('employeeType', isEqualTo: 'head')
            .where('status', isEqualTo: 'active')
            .limit(1)
            .get();

        if (headSnap.docs.isNotEmpty) {
          final headUserId = headSnap.docs.first.id;
          nodeToHead[nodeId] = headUserId;

          items.add(
            DropdownMenuItem<String>(
              value: nodeId,
              child: Text(
                '$nodeName - $nodeType',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          );
        }
      }

      if (items.isEmpty) {
        items.add(
          const DropdownMenuItem<String>(
            value: 'none',
            child: Text(
              'No subordinate units found',
              style: TextStyle(color: Colors.white70),
            ),
          ),
        );
      }

      setState(() {
        _nodeToHeadUserMap = nodeToHead;
        _dropdownItems['subordinateunit_selector'] = items;
        if (_selectedNodeId == null && items.isNotEmpty) {
          _selectedNodeId = items.first.value;
        }
      });
    } catch (e) {
      debugPrint('Error loading subordinate units: $e');
    }
  }

  String? _runValidation(FormFieldMeta field, String value) {
    if (field.required && value.isEmpty) {
      return '${field.label} is required';
    }
    if (field.type == 'email' && value.isNotEmpty) {
      final ok = RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value);
      if (!ok) return 'Invalid email';
    }
    if (field.validation != null && value.isNotEmpty) {
      final re = RegExp(field.validation!);
      if (!re.hasMatch(value)) {
        return 'Invalid ${field.label}';
      }
    }
    return null;
  }

  Future<Map<String, dynamic>?> submitExternally() async {
    final ok = _formKey.currentState?.validate() ?? false;
    if (!ok) return null;

    final assignmentData = getAssignmentData();
    if (assignmentData == null || !assignmentData.isValid) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please complete assignment selection'),
          backgroundColor: Colors.redAccent,
        ),
      );
      return null;
    }

    for (final entry in _controllers.entries) {
      _values[entry.key] = entry.value.text.trim();
    }
    for (final entry in _checkboxValues.entries) {
      _values[entry.key] = entry.value;
    }
    for (final entry in _dropdownValues.entries) {
      _values[entry.key] = entry.value;
    }

    for (final field in widget.form.fields) {
      if (field.type == 'date') {
        if (!_values.containsKey(field.id)) {
          _values[field.id] = null;
        }
      }
    }

    return Map.from(_values);
  }

  Widget _buildField(FormFieldMeta field) {
    if (field.id.toLowerCase() == 'assignto' ||
        field.id.toLowerCase() == 'assign_to' ||
        field.label.toLowerCase().contains('assign to')) {
      return const SizedBox.shrink();
    }

    switch (field.type) {
      case 'email':
      case 'text':
      case 'password':
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: TextFormField(
            controller: _controllers[field.id],
            obscureText: field.type == 'password',
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              labelText: field.label,
              labelStyle: const TextStyle(color: Colors.white70),
              floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
              enabledBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.white24),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.cyanAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              errorBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.redAccent),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedErrorBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.redAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              filled: true,
              fillColor: Colors.white.withOpacity(0.04),
            ),
            validator: (v) => _runValidation(field, v?.trim() ?? ''),
          ),
        );

      case 'dropdown':
        final loading = _loadingDropdown[field.id] ?? false;
        final options = _dropdownItems[field.id] ??
            field.options
                .map(
                  (o) => DropdownMenuItem<String>(
                    value: o.toString(),
                    child: Text(o.toString()),
                  ),
                )
                .toList();

        if (loading) {
          return const Padding(
            padding: EdgeInsets.only(bottom: 16.0),
            child: Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          );
        }

        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: PopupMenuButton<String>(
            color: Colors.transparent,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(14),
            ),
            offset: const Offset(0, 8),
            child: InputDecorator(
              decoration: InputDecoration(
                labelText: field.label,
                labelStyle: const TextStyle(color: Colors.white70),
                floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                enabledBorder: OutlineInputBorder(
                  borderSide: const BorderSide(color: Colors.white24),
                  borderRadius: BorderRadius.circular(18),
                ),
                focusedBorder: OutlineInputBorder(
                  borderSide:
                      const BorderSide(color: Colors.cyanAccent, width: 2),
                  borderRadius: BorderRadius.circular(18),
                ),
                filled: true,
                fillColor: Colors.white.withOpacity(0.04),
                suffixIcon:
                    const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
              ),
              child: Text(
                _dropdownValues[field.id] ?? 'Select ${field.label}',
                style: const TextStyle(color: Colors.white),
              ),
            ),
            itemBuilder: (context) => options
                .map(
                  (item) => PopupMenuItem<String>(
                    value: item.value,
                    padding: EdgeInsets.zero,
                    child: GlassContainer(
                      blur: 28,
                      opacity: 0.3,
                      tint: Colors.black,
                      blurMode: GlassBlurMode.perWidget,
                      borderRadius: BorderRadius.circular(10),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 16, vertical: 12),
                      child: SizedBox(
                        width: 200,
                        child: item.child,
                      ),
                    ),
                  ),
                )
                .toList(),
            onSelected: (v) {
              setState(() => _dropdownValues[field.id] = v);
            },
          ),
        );

      case 'checkbox':
        return Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.04),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: Colors.white24),
            ),
            child: CheckboxListTile(
              value: _checkboxValues[field.id] ?? false,
              onChanged: (v) {
                setState(() => _checkboxValues[field.id] = v ?? false);
              },
              title: Text(
                field.label,
                style: const TextStyle(color: Colors.white),
              ),
              activeColor: Colors.cyanAccent,
              checkColor: Colors.black,
              controlAffinity: ListTileControlAffinity.leading,
            ),
          ),
        );

      case 'date':
        return DynamicDateField(
          label: field.label,
          required: field.required,
          onChanged: (value) => _values[field.id] = value,
        );

      default:
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.redAccent.withOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.redAccent),
            ),
            child: Text(
              'Unsupported field type: ${field.type}',
              style: const TextStyle(color: Colors.redAccent),
            ),
          ),
        );
    }
  }

  // helper to get label for selected subordinate node
  String _labelForSelectedNode(List<DropdownMenuItem<String>> items) {
    if (_selectedNodeId == null || _selectedNodeId == 'none') {
      return 'Select Subordinate Unit';
    }

    final item = items.firstWhere(
      (i) => i.value == _selectedNodeId,
      orElse: () => items.first,
    );

    if (item.child is Text) {
      return (item.child as Text).data ?? 'Select Subordinate Unit';
    }
    return 'Select Subordinate Unit';
  }

  Widget _buildSubordinateUnitDropdown() {
    final items = _dropdownItems['subordinateunit_selector'] ?? [];

    if (items.isEmpty) {
      return const Padding(
        padding: EdgeInsets.all(16.0),
        child: Center(
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
          ),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: PopupMenuButton<String>(
        color: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(14),
        ),
        offset: const Offset(0, 8),
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: 'Assign To (Subordinate Unit)',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon:
                const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
          ),
          child: Text(
            _labelForSelectedNode(items),
            style: const TextStyle(color: Colors.white),
          ),
        ),
        itemBuilder: (context) => items
            .map(
              (item) => PopupMenuItem<String>(
                value: item.value,
                padding: EdgeInsets.zero,
                child: GlassContainer(
                  blur: 28,
                  opacity: 0.3,
                  tint: Colors.black,
                  blurMode: GlassBlurMode.perWidget,
                  borderRadius: BorderRadius.circular(10),
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: SizedBox(
                    width: 250,
                    child: item.child,
                  ),
                ),
              ),
            )
            .toList(),
        onSelected: (v) {
          setState(() => _selectedNodeId = v);
        },
      ),
    );
  }

  Widget _buildAssignmentSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 8),
        const Text(
          'Task Assignment',
          style: TextStyle(
            color: Colors.cyanAccent,
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 16),

        AssignmentTypeSelector(
          selectedType: _assignmentType,
          onChanged: (type) {
            setState(() {
              _assignmentType = type;
              _selectedNodeId = null;
              _selectedUserIds.clear();
              _groupName = null;
              _leadMemberId = null; // reset lead
            });

            if (type == 'subordinateunit') {
              _loadSubordinateUnits();
            }
          },
        ),

        if (_assignmentType == 'subordinateunit') ...[
          _buildSubordinateUnitDropdown(),
        ] else if (_assignmentType == 'team_member') ...[
          if (currentUserNodeId != null && currentUserLevel != null) ...[
            TeamMemberSelector(
              tenantId: widget.tenantId,
              currentNodeId: currentUserNodeId!,
              currentLevel: currentUserLevel!,
              selectedUserIds: _selectedUserIds,
              onSelectionChanged: (userIds) {
                setState(() {
                  _selectedUserIds = userIds;
                  if (_leadMemberId != null &&
                      !userIds.contains(_leadMemberId)) {
                    _leadMemberId = null;
                  }
                });
              },
            ),
            const SizedBox(height: 16),

            if (_selectedUserIds.length > 1) ...[
              TextFormField(
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                  labelText: 'Group Name *',
                  labelStyle: const TextStyle(color: Colors.white70),
                  floatingLabelStyle:
                      const TextStyle(color: Colors.cyanAccent),
                  hintText: 'Enter a name for this task group',
                  hintStyle: const TextStyle(color: Colors.white38),
                  enabledBorder: OutlineInputBorder(
                    borderSide: const BorderSide(color: Colors.white24),
                    borderRadius: BorderRadius.circular(18),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderSide:
                        const BorderSide(color: Colors.cyanAccent, width: 2),
                    borderRadius: BorderRadius.circular(18),
                  ),
                  filled: true,
                  fillColor: Colors.white.withOpacity(0.04),
                ),
                validator: (v) {
                  if (_selectedUserIds.length > 1 &&
                      (v == null || v.trim().isEmpty)) {
                    return 'Group name is required for multi-user tasks';
                  }
                  return null;
                },
                onChanged: (value) {
                  _groupName = value.trim();
                },
              ),
              const SizedBox(height: 16),

              _buildLeadMemberDropdown(),

              const SizedBox(height: 8),
              const Text(
                'This task will be assigned to the selected team members as a group. The lead member will coordinate the task.',
                style: TextStyle(
                  color: Colors.white70,
                  fontSize: 12,
                  fontStyle: FontStyle.italic,
                ),
              ),
            ],
          ] else
            const Padding(
              padding: EdgeInsets.all(16.0),
              child: Text(
                'Loading user data...',
                style: TextStyle(color: Colors.white70),
              ),
            ),
        ],
      ],
    );
  }

  // Lead member dropdown built from selected users
  Widget _buildLeadMemberDropdown() {
    return FutureBuilder<List<Map<String, String>>>(
      future: _loadSelectedUserNames(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(8.0),
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          );
        }

        final userOptions = snapshot.data ?? [];
        if (userOptions.isEmpty) {
          return const SizedBox.shrink();
        }

        return PopupMenuButton<String>(
          color: Colors.transparent,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(14),
          ),
          offset: const Offset(0, 8),
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: 'Select Lead Member *',
              labelStyle: const TextStyle(color: Colors.white70),
              floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
              enabledBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.white24),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.cyanAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              errorBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.redAccent),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedErrorBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.redAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              filled: true,
              fillColor: Colors.white.withOpacity(0.04),
              suffixIcon:
                  const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
            ),
            child: Text(
              _leadMemberId != null
                  ? userOptions
                          .firstWhere(
                            (u) => u['uid'] == _leadMemberId,
                            orElse: () => {'name': 'Select Lead Member'},
                          )['name'] ??
                      'Select Lead Member'
                  : 'Select Lead Member',
              style: const TextStyle(color: Colors.white),
            ),
          ),
          itemBuilder: (context) => userOptions
              .map(
                (user) => PopupMenuItem<String>(
                  value: user['uid'],
                  padding: EdgeInsets.zero,
                  child: GlassContainer(
                    blur: 28,
                    opacity: 0.3,
                    tint: Colors.black,
                    blurMode: GlassBlurMode.perWidget,
                    borderRadius: BorderRadius.circular(10),
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16, vertical: 12),
                    child: SizedBox(
                      width: 250,
                      child: Row(
                        children: [
                          const Icon(Icons.star,
                              size: 16, color: Colors.amberAccent),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              user['name'] ?? '',
                              style: const TextStyle(color: Colors.white),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              )
              .toList(),
          onSelected: (uid) {
            setState(() => _leadMemberId = uid);
          },
        );
      },
    );
  }

  
Future<List<Map<String, String>>> _loadSelectedUserNames() async {
  if (_selectedUserIds.isEmpty) return [];

  try {
    final userDocs = await Future.wait(
      _selectedUserIds.map(
        (uid) => FirebaseFirestore.instance
            .collection('tenants')
            .doc(widget.tenantId)
            .collection('users')
            .doc(uid)
            .get(),
      ),
    );

    return userDocs.map((doc) {
      if (!doc.exists) {
        // fallback to UID if doc missing
        return {'uid': doc.id, 'name': doc.id};
      }

      final data = doc.data();
      final fullName = data?['profiledata']?['fullName'] ??
          data?['fullName'] ??
          doc.id;

      return {
        'uid': doc.id,
        'name': fullName.toString(), // âœ… actual name used in UI
      };
    }).toList();
  } catch (e) {
    debugPrint('Error loading user names: $e');
    return [];
  }
}

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: ListView(
        children: [
          ...widget.form.fields.map(_buildField),
          const SizedBox(height: 16),
          _buildAssignmentSection(),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\team_member_selector.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

class TeamMemberSelector extends StatefulWidget {
  final String tenantId;
  final String currentNodeId;
  final int currentLevel;
  final List<String> selectedUserIds;
  final ValueChanged<List<String>> onSelectionChanged;

  const TeamMemberSelector({
    super.key,
    required this.tenantId,
    required this.currentNodeId,
    required this.currentLevel,
    required this.selectedUserIds,
    required this.onSelectionChanged,
  });

  @override
  State<TeamMemberSelector> createState() => _TeamMemberSelectorState();
}

class _TeamMemberSelectorState extends State<TeamMemberSelector> {
  final TextEditingController _searchController = TextEditingController();
  List<Map<String, dynamic>> _allUsers = [];
  List<Map<String, dynamic>> _filteredUsers = [];
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadTeamMembers();
    _searchController.addListener(_filterUsers);
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadTeamMembers() async {
  debugPrint('TEAM_SELECTOR: _loadTeamMembers START '
      'tenant=${widget.tenantId}, node=${widget.currentNodeId}, level=${widget.currentLevel}');
  setState(() => _loading = true);

  try {
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    debugPrint('TEAM_SELECTOR: currentUserId=$currentUserId');

    final usersSnap = await FirebaseFirestore.instance
        .collection('tenants')
        .doc(widget.tenantId)
        .collection('users')
        .get();

    debugPrint('TEAM_SELECTOR: raw user docs count=${usersSnap.docs.length}');

    _allUsers = usersSnap.docs.where((doc) {
      final data = doc.data();
      final nodeId = data['nodeId'];
      final level = data['level'];
      final status = data['status'];

      final include = doc.id != currentUserId &&
          nodeId == widget.currentNodeId &&
          level == widget.currentLevel &&
          status == 'active';

      if (include) {
        debugPrint(
            'TEAM_SELECTOR: include uid=${doc.id}, nodeId=$nodeId, level=$level, status=$status');
      }

      return include;
    }).map((doc) {
      final data = doc.data();
      final uid = doc.id;
      final fullName =
          data['profiledata']?['fullName'] ?? data['fullName'] ?? uid;
      final designation = data['designation'] ?? 'No Designation';

      return {
        'uid': uid,
        'name': fullName,
        'designation': designation,
      };
    }).toList();

    _filteredUsers = List.from(_allUsers);
    debugPrint('TEAM_SELECTOR: filtered users count=${_allUsers.length}');
  } catch (e, st) {
    debugPrint('TEAM_SELECTOR: EXCEPTION $e');
    debugPrint('TEAM_SELECTOR: STACKTRACE $st');
  } finally {
    if (mounted) {
      setState(() => _loading = false);
      debugPrint('TEAM_SELECTOR: _loadTeamMembers FINISHED');
    }
  }
}



  void _filterUsers() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      if (query.isEmpty) {
        _filteredUsers = List.from(_allUsers);
      } else {
        _filteredUsers = _allUsers.where((user) {
          final name = (user['name'] as String).toLowerCase();
          final designation = (user['designation'] as String).toLowerCase();
          return name.contains(query) || designation.contains(query);
        }).toList();
      }
    });
  }

  void _toggleUser(String uid) {
    final newSelection = List<String>.from(widget.selectedUserIds);
    if (newSelection.contains(uid)) {
      newSelection.remove(uid);
    } else {
      newSelection.add(uid);
    }
    widget.onSelectionChanged(newSelection);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Search field
        TextFormField(
          controller: _searchController,
          style: const TextStyle(color: Colors.white),
          decoration: InputDecoration(
            labelText: 'Search Team Members',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            prefixIcon: const Icon(Icons.search, color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
          ),
        ),
        const SizedBox(height: 12),

        // Selected count
        if (widget.selectedUserIds.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Text(
              '${widget.selectedUserIds.length} member(s) selected',
              style: const TextStyle(
                color: Colors.cyanAccent,
                fontSize: 12,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),

        // User list
        if (_loading)
          const Center(
            child: Padding(
              padding: EdgeInsets.all(24.0),
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          )
        else if (_filteredUsers.isEmpty)
          const Padding(
            padding: EdgeInsets.all(24.0),
            child: Center(
              child: Text(
                'No team members found',
                style: TextStyle(color: Colors.white70),
              ),
            ),
          )
        else
          Container(
            constraints: const BoxConstraints(maxHeight: 300),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.04),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: Colors.white24),
            ),
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: _filteredUsers.length,
              itemBuilder: (context, index) {
                final user = _filteredUsers[index];
                final uid = user['uid'] as String;
                final isSelected = widget.selectedUserIds.contains(uid);

                return CheckboxListTile(
                  value: isSelected,
                  onChanged: (_) => _toggleUser(uid),
                  title: Text(
                    user['name'] as String,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  subtitle: Text(
                    user['designation'] as String,
                    style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 12,
                    ),
                  ),
                  activeColor: Colors.cyanAccent,
                  checkColor: Colors.black,
                  controlAffinity: ListTileControlAffinity.leading,
                );
              },
            ),
          ),
      ],
    );
  }
}

================================================================================

// File: lib\task\pages\view_all_tasks_page\view_all_tasks_page.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import 'models/created_task_view_model.dart';
import 'widgets/created_task_list.dart';
import 'widgets/created_task_workspace.dart';

class ViewAllTasksPage extends StatefulWidget {
  const ViewAllTasksPage({super.key});
  static const String tenantId = 'default_tenant';

  @override
  State<ViewAllTasksPage> createState() => _ViewAllTasksPageState();
}

class _ViewAllTasksPageState extends State<ViewAllTasksPage> {
  CreatedTaskViewModel? selectedTask;
  String? errorMessage;

  @override
Widget build(BuildContext context) {
  final user = FirebaseAuth.instance.currentUser;
  if (user == null) {
    return const Center(
      child: Text(
        'You must be logged in',
        style: TextStyle(color: Colors.white),
      ),
    );
  }

  final uid = user.uid;
  
  // Query: WHERE assignedBy == currentUserUid
  final stream = FirebaseFirestore.instance
      .collection('tenants')
      .doc(ViewAllTasksPage.tenantId)
      .collection('tasks')
      .where('assignedby', isEqualTo: uid)
      .orderBy('createdat', descending: true)
      .snapshots();

  return StreamBuilder<QuerySnapshot>(
    stream: stream,
    builder: (context, snapshot) {
      // Handle errors
      if (snapshot.hasError) {
        final errorMessage = snapshot.error.toString();
        
        // Print error details to terminal
        debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        debugPrint('ğŸ”´ FIRESTORE INDEX ERROR');
        debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        debugPrint(errorMessage);
        debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // Extract and print the Firebase Console URL
        final urlMatch = RegExp(r'https://console\.firebase\.google\.com[^\s]+')
            .firstMatch(errorMessage);
        if (urlMatch != null) {
          final indexUrl = urlMatch.group(0);
          debugPrint('');
          debugPrint('ğŸ“Œ CREATE INDEX HERE (Click the link below):');
          debugPrint(indexUrl);
          debugPrint('');
          debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        }
        
        return Center(
          child: Padding(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.error_outline,
                  color: Colors.redAccent,
                  size: 64,
                ),
                const SizedBox(height: 24),
                const Text(
                  'Error loading tasks',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.redAccent.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: Colors.redAccent.withOpacity(0.3),
                    ),
                  ),
                  child: Column(
                    children: [
                      const Text(
                        'This query requires a Firestore index.',
                        style: TextStyle(
                          color: Colors.white70,
                          fontSize: 14,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      const Text(
                        'Check your terminal/console for the index creation link.',
                        style: TextStyle(
                          color: Colors.cyanAccent,
                          fontSize: 13,
                          fontWeight: FontWeight.w600,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  onPressed: () {
                    // Copy error to clipboard or trigger a refresh
                    setState(() {});
                  },
                  icon: const Icon(Icons.refresh),
                  label: const Text('Retry'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.cyan,
                    foregroundColor: Colors.black,
                  ),
                ),
              ],
            ),
          ),
        );
      }

      // Loading state
      if (snapshot.connectionState == ConnectionState.waiting) {
        return const Center(
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation(Colors.cyan),
          ),
        );
      }

      final docs = snapshot.data?.docs ?? [];
      
      // Parse documents with error handling
      final models = <CreatedTaskViewModel>[];
      for (final doc in docs) {
        try {
          final data = doc.data() as Map<String, dynamic>?;
          if (data != null) {
            models.add(
              CreatedTaskViewModel.fromFirestore(
                docId: doc.id,
                data: data,
              ),
            );
          }
        } catch (e) {
          debugPrint('âš ï¸  Error parsing task ${doc.id}: $e');
          // Continue to next document instead of crashing
        }
      }

      if (models.isEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.assignment_outlined,
                size: 80,
                color: Colors.white.withOpacity(0.2),
              ),
              const SizedBox(height: 16),
              const Text(
                'No tasks created yet',
                style: TextStyle(
                  color: Colors.white70,
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(height: 8),
              const Text(
                'Create a new task to get started',
                style: TextStyle(
                  color: Colors.white38,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        );
      }

      // Ensure selectedTask is still valid
      if (selectedTask != null) {
        final exists = models.any((t) => t.docId == selectedTask!.docId);
        if (!exists) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
              setState(() => selectedTask = null);
            }
          });
        }
      }

      return Row(
        children: [
          // LEFT: List of created tasks
          Expanded(
            flex: 2,
            child: CreatedTaskList(
              tasks: models,
              selectedTaskId: selectedTask?.docId,
              onTaskSelected: (task) {
                setState(() => selectedTask = task);
              },
            ),
          ),
          // RIGHT: Workspace with chat to lead
          Expanded(
            flex: 3,
            child: selectedTask == null
                ? buildEmptyWorkspace()
                : CreatedTaskWorkspace(
                    task: selectedTask!,
                    tenantId: ViewAllTasksPage.tenantId,
                    onBack: () {
                      setState(() => selectedTask = null);
                    },
                  ),
          ),
        ],
      );
    },
  );
}


  Widget buildEmptyWorkspace() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: const [
          Icon(
            Icons.touch_app,
            size: 64,
            color: Colors.white24,
          ),
          SizedBox(height: 16),
          Text(
            'Select a task from the left',
            style: TextStyle(
              color: Colors.white60,
              fontSize: 16,
            ),
          ),
        ],
      ),
    );
  }
}


  Widget buildEmptyWorkspace() {
    return const Center(
      child: Text('Select a task from the left'),
    );
  }


================================================================================

// File: lib\task\pages\view_all_tasks_page\models\created_task_view_model.dart
class CreatedTaskViewModel {
  final String docId;
  final String title;
  final String description;
  final String status;
  final String priority;
  final DateTime? dueDate;
  final String groupName;
  final List<String> assignedToUids;
  final int assigneeCount;
  final String? leadMemberId;

  CreatedTaskViewModel({
    required this.docId,
    required this.title,
    required this.description,
    required this.status,
    required this.priority,
    required this.dueDate,
    required this.groupName,
    required this.assignedToUids,
    required this.assigneeCount,
    required this.leadMemberId,
  });

  factory CreatedTaskViewModel.fromFirestore({
    required String docId,
    required Map<String, dynamic> data,
  }) {
    final title = data['title'] as String? ?? '';
    final description = data['description'] as String? ?? '';
    final status = data['status'] as String? ?? 'PENDING';
    
    // Safe priority extraction
    final customFields = data['customfields'];
    String priority = '';
    if (customFields != null && customFields is Map) {
      priority = customFields['priority'] as String? ?? '';
    }
    
    // Safe due date parsing
    final dueIso = data['duedate'] as String? ?? '';
    DateTime? due;
    if (dueIso.isNotEmpty) {
      try {
        due = DateTime.parse(dueIso);
      } catch (_) {
        due = null;
      }
    }

    final groupName = data['groupname'] as String? ?? '';
    
    // FIXED: Safe list handling for assigned_to
    List<String> assignedToUids = [];
    final assignedTo = data['assignedto'];
    
    if (assignedTo != null) {
      if (assignedTo is String) {
        // If it's a comma-separated string
        if (assignedTo.isNotEmpty) {
          assignedToUids = assignedTo
              .split(',')
              .map((s) => s.trim())
              .where((s) => s.isNotEmpty)
              .toList();
        }
      } else if (assignedTo is List) {
        // If it's already a list (from Firestore array)
        assignedToUids = assignedTo
            .map((e) => e.toString())
            .where((s) => s.isNotEmpty)
            .toList();
      }
    }
    
    final assigneeCount = assignedToUids.length;
    final leadMemberId = data['leadmember'] as String?;

    return CreatedTaskViewModel(
      docId: docId,
      title: title,
      description: description,
      status: status,
      priority: priority,
      dueDate: due,
      groupName: groupName,
      assignedToUids: assignedToUids,
      assigneeCount: assigneeCount,
      leadMemberId: leadMemberId,
    );
  }

  bool get hasLead => leadMemberId != null && leadMemberId!.isNotEmpty;
}

================================================================================

// File: lib\task\pages\view_all_tasks_page\widgets\created_task_card.dart
import 'package:flutter/material.dart';
import '../models/created_task_view_model.dart';

class CreatedTaskCard extends StatelessWidget {
  final CreatedTaskViewModel task;
  final bool isSelected;
  final VoidCallback onTap;

  const CreatedTaskCard({
    super.key,
    required this.task,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: isSelected
              ? Colors.cyan.withOpacity(0.12)
              : Colors.white.withOpacity(0.04),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected
                ? Colors.cyan.withOpacity(0.6)
                : Colors.white.withOpacity(0.1),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header: Title + Member count
            Row(
              children: [
                Expanded(
                  child: Text(
                    task.title.isEmpty ? 'Untitled Task' : task.title,
                    style: TextStyle(
                      color: isSelected ? Colors.cyan : Colors.white,
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                // Member count badge
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.purple.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.purple.withOpacity(0.6),
                    ),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(
                        Icons.people,
                        size: 14,
                        color: Colors.purpleAccent,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${task.assigneeCount}',
                        style: const TextStyle(
                          color: Colors.purpleAccent,
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),

            // Group name
            if (task.groupName.isNotEmpty) ...[
              Row(
                children: [
                  const Icon(
                    Icons.label_outline,
                    size: 14,
                    color: Colors.white54,
                  ),
                  const SizedBox(width: 4),
                  Expanded(
                    child: Text(
                      task.groupName,
                      style: const TextStyle(
                        color: Colors.white54,
                        fontSize: 13,
                        fontStyle: FontStyle.italic,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],

            // Lead badge (if assigned)
            if (task.hasLead) ...[
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: Colors.amber.withOpacity(0.15),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: Colors.amber.withOpacity(0.5),
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: const [
                    Icon(
                      Icons.star,
                      size: 14,
                      color: Colors.amber,
                    ),
                    SizedBox(width: 4),
                    Text(
                      'LEAD ASSIGNED',
                      style: TextStyle(
                        color: Colors.amber,
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        letterSpacing: 0.5,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 8),
            ],

            // Status and Priority badges
            Wrap(
              spacing: 6,
              runSpacing: 4,
              children: [
                _buildStatusBadge(task.status),
                if (task.priority.isNotEmpty)
                  _buildPriorityBadge(task.priority),
              ],
            ),

            // Due date
            if (task.dueDate != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(
                    Icons.calendar_today,
                    size: 12,
                    color: _getDueDateColor(task.dueDate!),
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Due: ${_formatDate(task.dueDate!)}',
                    style: TextStyle(
                      color: _getDueDateColor(task.dueDate!),
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStatusBadge(String status) {
    final color = _getStatusColor(status);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.6)),
      ),
      child: Text(
        status.toUpperCase(),
        style: TextStyle(
          color: color,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildPriorityBadge(String priority) {
    final color = _getPriorityColor(priority);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.6)),
      ),
      child: Text(
        priority.toUpperCase(),
        style: TextStyle(
          color: color,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status.toUpperCase()) {
      case 'COMPLETED':
        return Colors.green;
      case 'IN_PROGRESS':
      case 'IN PROGRESS':
        return Colors.blue;
      case 'PENDING':
        return Colors.orange;
      case 'CANCELLED':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  Color _getPriorityColor(String priority) {
    switch (priority.toUpperCase()) {
      case 'CRITICAL':
        return Colors.redAccent;
      case 'HIGH':
        return Colors.deepOrangeAccent;
      case 'MEDIUM':
        return Colors.yellowAccent;
      case 'LOW':
        return Colors.lightGreenAccent;
      default:
        return Colors.grey;
    }
  }

  Color _getDueDateColor(DateTime dueDate) {
    final now = DateTime.now();
    final difference = dueDate.difference(now);

    if (difference.isNegative) {
      // Overdue
      return Colors.redAccent;
    } else if (difference.inDays <= 1) {
      // Due soon (within 24 hours)
      return Colors.orangeAccent;
    } else if (difference.inDays <= 3) {
      // Due in 2-3 days
      return Colors.yellowAccent;
    } else {
      // More than 3 days
      return Colors.white70;
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final taskDate = DateTime(date.year, date.month, date.day);
    final difference = taskDate.difference(today).inDays;

    if (difference == 0) {
      return 'Today at ${_formatTime(date)}';
    } else if (difference == 1) {
      return 'Tomorrow at ${_formatTime(date)}';
    } else if (difference == -1) {
      return 'Yesterday';
    } else if (difference < 0) {
      return '${difference.abs()} days ago';
    } else {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${_formatTime(date)}';
    }
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

================================================================================

// File: lib\task\pages\view_all_tasks_page\widgets\created_task_list.dart
import 'package:flutter/material.dart';
import '../models/created_task_view_model.dart';
import 'created_task_card.dart';

class CreatedTaskList extends StatelessWidget {
  final List<CreatedTaskViewModel> tasks;
  final String? selectedTaskId;
  final Function(CreatedTaskViewModel) onTaskSelected;

  const CreatedTaskList({
    super.key,
    required this.tasks,
    required this.selectedTaskId,
    required this.onTaskSelected,
  });

  @override
  Widget build(BuildContext context) {
    if (tasks.isEmpty) {
      return _buildEmptyState();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Tasks You Created',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                '${tasks.length} task${tasks.length == 1 ? '' : 's'}',
                style: const TextStyle(
                  color: Colors.white60,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
        const Divider(color: Colors.white12, height: 1),
        
        // Task list
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: tasks.length,
            itemBuilder: (context, index) {
              final task = tasks[index];
              final isSelected = task.docId == selectedTaskId;

              return CreatedTaskCard(
                task: task,
                isSelected: isSelected,
                onTap: () => onTaskSelected(task),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.assignment_outlined,
            size: 80,
            color: Colors.white.withOpacity(0.2),
          ),
          const SizedBox(height: 16),
          const Text(
            'No Tasks Created Yet',
            style: TextStyle(
              color: Colors.white70,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          const Text(
            'Create a new task to get started',
            style: TextStyle(
              color: Colors.white38,
              fontSize: 14,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_all_tasks_page\widgets\created_task_workspace.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../../chat/models/chat_channel.dart';
import '../../../../chat/models/chat_conversation.dart';
import '../../../../chat/widgets/chat_shell.dart';
import '../models/created_task_view_model.dart';
import 'manager_task_details_panel.dart';

class CreatedTaskWorkspace extends StatefulWidget {
  final CreatedTaskViewModel task;
  final String tenantId;
  final VoidCallback onBack;

  const CreatedTaskWorkspace({
    super.key,
    required this.task,
    required this.tenantId,
    required this.onBack,
  });

  @override
  State<CreatedTaskWorkspace> createState() => _CreatedTaskWorkspaceState();
}

class _CreatedTaskWorkspaceState extends State<CreatedTaskWorkspace> {
  String activeView = 'details'; // details | manager

  String get currentUserUid => FirebaseAuth.instance.currentUser?.uid ?? '';

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildTopBar(),
        const Divider(color: Colors.white24, height: 1),
        Expanded(child: _buildContent()),
      ],
    );
  }

  Widget _buildTopBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with back button and title
          Row(
            children: [
              IconButton(
                icon: const Icon(Icons.arrow_back, color: Colors.cyan),
                onPressed: widget.onBack,
                tooltip: 'Back',
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  widget.task.title.isEmpty ? 'TASK' : widget.task.title.toUpperCase(),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),

          // Tab buttons
          Row(
            children: [
              Expanded(
                child: _buildTabButton(
                  icon: Icons.info_outline,
                  label: 'Task Details',
                  isActive: activeView == 'details',
                  onTap: () => setState(() => activeView = 'details'),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: _buildTabButton(
                  icon: Icons.support_agent,
                  label: 'Manager Communication',
                  isActive: activeView == 'manager',
                  onTap: () => setState(() => activeView = 'manager'),
                  activeColor: Colors.greenAccent,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTabButton({
    required IconData icon,
    required String label,
    required bool isActive,
    required VoidCallback onTap,
    Color activeColor = Colors.cyanAccent,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 250),
        curve: Curves.easeInOut,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isActive
              ? activeColor.withOpacity(0.15)
              : Colors.white.withOpacity(0.05),
          borderRadius: BorderRadius.circular(30),
          border: Border.all(
            color: isActive ? activeColor : Colors.white.withOpacity(0.2),
            width: isActive ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              color: isActive ? activeColor : Colors.white60,
              size: 20,
            ),
            const SizedBox(width: 8),
            Flexible(
              child: Text(
                label,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(
                  color: isActive ? activeColor : Colors.white60,
                  fontSize: 14,
                  fontWeight: isActive ? FontWeight.w600 : FontWeight.w500,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContent() {
    switch (activeView) {
      case 'manager':
        return _buildManagerCommunication();

      case 'details':
      default:
        return ManagerTaskDetailsPanel(
          task: widget.task,
          tenantId: widget.tenantId,
        );
    }
  }

  Widget _buildManagerCommunication() {
    final conversation = ChatConversation(
      conversationId: widget.task.docId,
      taskTitle: widget.task.title,
      assignedByUid: currentUserUid,
      assignedToUids: widget.task.assignedToUids,
      leadMemberUid: widget.task.leadMemberId,
      groupName: widget.task.groupName,
      dueDate: widget.task.dueDate,
    );

    return Padding(
      padding: const EdgeInsets.all(16),
      child: ChatShell(
        tenantId: widget.tenantId,
        conversation: conversation,
        channel: ChatChannel.managerCommunication,
        currentUserId: currentUserUid,
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_all_tasks_page\widgets\manager_task_details_panel.dart
import 'package:flutter/material.dart';
import '../models/created_task_view_model.dart';
import '../../../utils/user_helper.dart';

class ManagerTaskDetailsPanel extends StatefulWidget {
  final CreatedTaskViewModel task;
  final String tenantId;

  const ManagerTaskDetailsPanel({
    super.key,
    required this.task,
    required this.tenantId,
  });

  @override
  State<ManagerTaskDetailsPanel> createState() => _ManagerTaskDetailsPanelState();
}

class _ManagerTaskDetailsPanelState extends State<ManagerTaskDetailsPanel> {
  String? leadMemberName;
  bool isLoadingLeadName = false;

  @override
  void initState() {
    super.initState();
    _fetchLeadMemberName();
  }

  Future<void> _fetchLeadMemberName() async {
    if (widget.task.hasLead && widget.task.leadMemberId != null) {
      setState(() => isLoadingLeadName = true);
      
      final name = await UserHelper.getUserDisplayName(
        tenantId: widget.tenantId,
        userId: widget.task.leadMemberId!,
      );
      
      if (mounted) {
        setState(() {
          leadMemberName = name;
          isLoadingLeadName = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Title
          const Text(
            'Task Overview',
            style: TextStyle(
              color: Colors.white,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),

          // Description
          if (widget.task.description.isNotEmpty) ...[
            const Text(
              'Description',
              style: TextStyle(
                color: Colors.white70,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              widget.task.description,
              style: const TextStyle(color: Colors.white),
            ),
            const SizedBox(height: 16),
          ],

          // Group Name
          if (widget.task.groupName.isNotEmpty) ...[
            _buildInfoRow(
              icon: Icons.label_outline,
              label: 'Group',
              value: widget.task.groupName,
            ),
            const SizedBox(height: 12),
          ],

          // Status & Priority
          Row(
            children: [
              _buildChip('Status', widget.task.status, Colors.cyanAccent),
              const SizedBox(width: 8),
              if (widget.task.priority.isNotEmpty)
                _buildChip('Priority', widget.task.priority, Colors.deepOrangeAccent),
            ],
          ),
          const SizedBox(height: 16),

          // Assignees
          _buildInfoRow(
            icon: Icons.people,
            label: 'Team Members',
            value: '${widget.task.assigneeCount} member(s)',
          ),
          const SizedBox(height: 12),

          // Lead Member with name
          if (widget.task.hasLead) ...[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(
                  Icons.star,
                  size: 18,
                  color: Colors.amberAccent,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Lead Member',
                        style: TextStyle(
                          color: Colors.white54,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(height: 2),
                      isLoadingLeadName
                          ? const SizedBox(
                              height: 14,
                              width: 14,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation(Colors.amberAccent),
                              ),
                            )
                          : Text(
                              leadMemberName ?? widget.task.leadMemberId ?? 'Not assigned',
                              style: const TextStyle(
                                color: Colors.amberAccent,
                                fontSize: 14,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
          ],

          // Due date
          if (widget.task.dueDate != null) ...[
            _buildInfoRow(
              icon: Icons.calendar_today,
              label: 'Due Date',
              value: _formatDueDate(widget.task.dueDate!),
              valueColor: _getDueDateColor(widget.task.dueDate!),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String label,
    required String value,
    Color? valueColor,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(
          icon,
          size: 18,
          color: Colors.white54,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: const TextStyle(
                  color: Colors.white54,
                  fontSize: 12,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                value,
                style: TextStyle(
                  color: valueColor ?? Colors.white,
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildChip(String label, String value, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.8)),
      ),
      child: Text(
        '$label: ${value.toUpperCase()}',
        style: TextStyle(
          color: color,
          fontSize: 12,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Color _getDueDateColor(DateTime dueDate) {
    final now = DateTime.now();
    final difference = dueDate.difference(now);

    if (difference.isNegative) {
      return Colors.redAccent;
    } else if (difference.inDays <= 1) {
      return Colors.orangeAccent;
    } else if (difference.inDays <= 3) {
      return Colors.yellowAccent;
    } else {
      return Colors.white70;
    }
  }

  String _formatDueDate(DateTime date) {
    final now = DateTime.now();
    final difference = date.difference(now);

    if (difference.isNegative) {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} (Overdue)';
    } else if (difference.inDays == 0) {
      return 'Today at ${_formatTime(date)}';
    } else if (difference.inDays == 1) {
      return 'Tomorrow at ${_formatTime(date)}';
    } else {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} at ${_formatTime(date)}';
    }
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\view_assigned_tasks_page.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../core/glass_container.dart';
import 'models/assigned_task_view_model.dart';
import 'widgets/assigned_task_list.dart';
import 'widgets/assigned_task_workspace.dart';

class ViewAssignedTasksPage extends StatefulWidget {
  const ViewAssignedTasksPage({super.key});

  static const String tenantId = 'default_tenant';

  @override
  State<ViewAssignedTasksPage> createState() => _ViewAssignedTasksPageState();
}

class _ViewAssignedTasksPageState extends State<ViewAssignedTasksPage> {
  AssignedTaskViewModel? _selectedTask;

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    if (user == null) {
      return const Center(
        child: Text(
          'You must be logged in to see assigned tasks.',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    final uid = user.uid;

    final stream = FirebaseFirestore.instance
        .collection('tenants')
        .doc(ViewAssignedTasksPage.tenantId)
        .collection('tasks')
        .orderBy('createdat', descending: true)
        .snapshots();

    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: stream,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
            ),
          );
        }

        if (snapshot.hasError) {
          return _buildError(snapshot.error);
        }

        final allDocs = snapshot.data?.docs ?? [];

        // Filter tasks where current uid is in assigned_to (comma-separated)
        final myTasks = allDocs.where((doc) {
          final data = doc.data();
          final assignedTo = (data['assignedto'] ?? '') as String;
          if (assignedTo.isEmpty) return false;
          final assignees =
              assignedTo.split(',').map((s) => s.trim()).toList();
          return assignees.contains(uid);
        }).toList();

        if (myTasks.isEmpty) {
          return const Center(
            child: Text(
              'No tasks are currently assigned to you.',
              style: TextStyle(color: Colors.white70),
            ),
          );
        }

        final models = myTasks.map((doc) {
          final data = doc.data();
          return AssignedTaskViewModel.fromFirestore(
            docId: doc.id,
            data: data,
          );
        }).toList();

        // Ensure selected task is valid
        if (_selectedTask != null) {
          final exists = models.any((t) => t.docId == _selectedTask!.docId);
          if (!exists) {
            _selectedTask = null;
          }
        }

        return Row(
          children: [
            // LEFT: List of assigned tasks
            Expanded(
              flex: 2,
              child: AssignedTaskList(
                tasks: models,
                selectedTaskId: _selectedTask?.docId,
                currentUserId: uid,  // ADD THIS
                onTaskSelected: (task) {
                  setState(() => _selectedTask = task);
                },
              ),
            ),
            // RIGHT: Workspace
            Expanded(
              flex: 3,
              child: _selectedTask == null
                  ? _buildEmptyWorkspace()
                  : AssignedTaskWorkspace(
                      task: _selectedTask!,
                      tenantId: ViewAssignedTasksPage.tenantId,
                      onBack: () {
                        setState(() => _selectedTask = null);
                      },
                    ),
            ),
          ],
        );

      },
    );
  }

  Widget _buildEmptyWorkspace() {
    return Center(
      child: GlassContainer(
        blur: 18,
        opacity: 0.12,
        tint: Colors.black,
        borderRadius: BorderRadius.circular(18),
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
        child: const Text(
          'Select a task from the left to see details.',
          style: TextStyle(
            color: Colors.white70,
            fontSize: 14,
          ),
        ),
      ),
    );
  }

  Widget _buildError(Object? error) {
    String debugMessage = 'Unknown snapshot error: $error';
    String consoleUrl = '';

    if (error is FirebaseException && error.message != null) {
      final msg = error.message!;
      final marker = 'https://';
      final idx = msg.indexOf(marker);
      if (idx != -1) {
        consoleUrl = msg.substring(idx).trim();
        debugPrint('ğŸ”¥ FIRESTORE INDEX URL: $consoleUrl');
      } else {
        debugPrint('Firestore error (no URL found): $msg');
      }
    } else {
      debugPrint(debugMessage);
    }

    return Center(
      child: Text(
        'Failed to load assigned tasks.\n'
        'Check debug console for Firestore details.',
        textAlign: TextAlign.center,
        style: const TextStyle(color: Colors.redAccent),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\models\assigned_task_view_model.dart
class AssignedTaskViewModel {
  final String docId;
  final String title;
  final String description;
  final String status;
  final String priority;
  final DateTime? dueDate;
  final String groupName;
  final List<String> assignedToUids;
  final int assigneeCount;
  final String? leadMemberId;
  final String assignedByUid;

  AssignedTaskViewModel({
    required this.docId,
    required this.title,
    required this.description,
    required this.status,
    required this.priority,
    required this.dueDate,
    required this.groupName,
    required this.assignedToUids,
    required this.assigneeCount,
    required this.leadMemberId,
    required this.assignedByUid,
  });

  // ADD THIS METHOD
  bool isUserLead(String userId) {
    return leadMemberId != null && leadMemberId == userId;
  }

  bool get hasLead => leadMemberId != null && leadMemberId!.isNotEmpty;

  factory AssignedTaskViewModel.fromFirestore({
    required String docId,
    required Map<String, dynamic> data,
  }) {
    final title = data['title'] as String? ?? '';
    final description = data['description'] as String? ?? '';
    final status = data['status'] as String? ?? 'PENDING';
    
    // Safe priority extraction
    final customFields = data['customfields'];
    String priority = '';
    if (customFields != null && customFields is Map) {
      priority = customFields['priority'] as String? ?? '';
    }
    
    // Safe due date parsing
    final dueIso = data['duedate'] as String? ?? '';
    DateTime? due;
    if (dueIso.isNotEmpty) {
      try {
        due = DateTime.parse(dueIso);
      } catch (_) {
        due = null;
      }
    }

    final groupName = data['groupname'] as String? ?? '';
    
    // Safe list handling for assigned_to
    List<String> assignedToUids = [];
    final assignedTo = data['assignedto'];
    
    if (assignedTo != null) {
      if (assignedTo is String) {
        if (assignedTo.isNotEmpty) {
          assignedToUids = assignedTo
              .split(',')
              .map((s) => s.trim())
              .where((s) => s.isNotEmpty)
              .toList();
        }
      } else if (assignedTo is List) {
        assignedToUids = assignedTo
            .map((e) => e.toString())
            .where((s) => s.isNotEmpty)
            .toList();
      }
    }
    
    final assigneeCount = assignedToUids.length;
    final leadMemberId = data['leadmember'] as String?;
    final assignedByUid = data['assignedby'] as String? ?? '';

    return AssignedTaskViewModel(
      docId: docId,
      title: title,
      description: description,
      status: status,
      priority: priority,
      dueDate: due,
      groupName: groupName,
      assignedToUids: assignedToUids,
      assigneeCount: assigneeCount,
      leadMemberId: leadMemberId,
      assignedByUid: assignedByUid,
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_card.dart
import 'package:flutter/material.dart';
import '../models/assigned_task_view_model.dart';

class AssignedTaskCard extends StatelessWidget {
  final AssignedTaskViewModel task;
  final bool isSelected;
  final VoidCallback onTap;
  final String currentUserId;

  const AssignedTaskCard({
    super.key,
    required this.task,
    required this.isSelected,
    required this.onTap,
    required this.currentUserId,
  });

  @override
  Widget build(BuildContext context) {
    final isLead = task.isUserLead(currentUserId);
    
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: isSelected
              ? Colors.cyan.withOpacity(0.12)
              : Colors.white.withOpacity(0.04),
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected
                ? Colors.cyan.withOpacity(0.6)
                : Colors.white.withOpacity(0.1),
            width: isSelected ? 2 : 1,
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header: Title + Member count
            Row(
              children: [
                Expanded(
                  child: Text(
                    task.title.isEmpty ? 'Untitled Task' : task.title,
                    style: TextStyle(
                      color: isSelected ? Colors.cyan : Colors.white,
                      fontSize: 16,
                      fontWeight: FontWeight.bold,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                // Member count badge
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.purple.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Colors.purple.withOpacity(0.6),
                    ),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(
                        Icons.people,
                        size: 14,
                        color: Colors.purpleAccent,
                      ),
                      const SizedBox(width: 4),
                      Text(
                        '${task.assigneeCount}',
                        style: const TextStyle(
                          color: Colors.purpleAccent,
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 8),

            // Group name
            if (task.groupName.isNotEmpty) ...[
              Row(
                children: [
                  const Icon(
                    Icons.label_outline,
                    size: 14,
                    color: Colors.white54,
                  ),
                  const SizedBox(width: 4),
                  Expanded(
                    child: Text(
                      task.groupName,
                      style: const TextStyle(
                        color: Colors.white54,
                        fontSize: 13,
                        fontStyle: FontStyle.italic,
                      ),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],

            // "YOU ARE THE LEAD" badge
            if (isLead) ...[
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: Colors.amber.withOpacity(0.15),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(
                    color: Colors.amber.withOpacity(0.5),
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: const [
                    Icon(
                      Icons.star,
                      size: 14,
                      color: Colors.amber,
                    ),
                    SizedBox(width: 4),
                    Text(
                      'YOU ARE THE LEAD',
                      style: TextStyle(
                        color: Colors.amber,
                        fontSize: 11,
                        fontWeight: FontWeight.w600,
                        letterSpacing: 0.5,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 8),
            ],

            // Status and Priority badges
            Wrap(
              spacing: 6,
              runSpacing: 4,
              children: [
                _buildStatusBadge(task.status),
                if (task.priority.isNotEmpty)
                  _buildPriorityBadge(task.priority),
              ],
            ),

            // Due date
            if (task.dueDate != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(
                    Icons.calendar_today,
                    size: 12,
                    color: _getDueDateColor(task.dueDate!),
                  ),
                  const SizedBox(width: 4),
                  Text(
                    'Due: ${_formatDate(task.dueDate!)}',
                    style: TextStyle(
                      color: _getDueDateColor(task.dueDate!),
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildStatusBadge(String status) {
    final color = _getStatusColor(status);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.6)),
      ),
      child: Text(
        status.toUpperCase(),
        style: TextStyle(
          color: color,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildPriorityBadge(String priority) {
    final color = _getPriorityColor(priority);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.6)),
      ),
      child: Text(
        priority.toUpperCase(),
        style: TextStyle(
          color: color,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Color _getStatusColor(String status) {
    switch (status.toUpperCase()) {
      case 'COMPLETED':
        return Colors.green;
      case 'IN_PROGRESS':
      case 'IN PROGRESS':
        return Colors.blue;
      case 'PENDING':
        return Colors.orange;
      case 'CANCELLED':
        return Colors.red;
      default:
        return Colors.grey;
    }
  }

  Color _getPriorityColor(String priority) {
    switch (priority.toUpperCase()) {
      case 'CRITICAL':
        return Colors.redAccent;
      case 'HIGH':
        return Colors.deepOrangeAccent;
      case 'MEDIUM':
        return Colors.yellowAccent;
      case 'LOW':
        return Colors.lightGreenAccent;
      default:
        return Colors.grey;
    }
  }

  Color _getDueDateColor(DateTime dueDate) {
    final now = DateTime.now();
    final difference = dueDate.difference(now);

    if (difference.isNegative) {
      // Overdue
      return Colors.redAccent;
    } else if (difference.inDays <= 1) {
      // Due soon (within 24 hours)
      return Colors.orangeAccent;
    } else if (difference.inDays <= 3) {
      // Due in 2-3 days
      return Colors.yellowAccent;
    } else {
      // More than 3 days
      return Colors.white70;
    }
  }

  String _formatDate(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final taskDate = DateTime(date.year, date.month, date.day);
    final difference = taskDate.difference(today).inDays;

    if (difference == 0) {
      return 'Today at ${_formatTime(date)}';
    } else if (difference == 1) {
      return 'Tomorrow at ${_formatTime(date)}';
    } else if (difference == -1) {
      return 'Yesterday';
    } else if (difference < 0) {
      return '${difference.abs()} days ago';
    } else {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} ${_formatTime(date)}';
    }
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_list.dart
import 'package:flutter/material.dart';
import '../models/assigned_task_view_model.dart';
import 'assigned_task_card.dart';

class AssignedTaskList extends StatelessWidget {
  final List<AssignedTaskViewModel> tasks;
  final String? selectedTaskId;
  final Function(AssignedTaskViewModel) onTaskSelected;
  final String currentUserId;

  const AssignedTaskList({
    super.key,
    required this.tasks,
    required this.selectedTaskId,
    required this.onTaskSelected,
    required this.currentUserId,
  });

  @override
  Widget build(BuildContext context) {
    if (tasks.isEmpty) {
      return _buildEmptyState();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text(
                'Assigned Tasks',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 22,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                '${tasks.length} task${tasks.length == 1 ? '' : 's'}',
                style: const TextStyle(
                  color: Colors.white60,
                  fontSize: 14,
                ),
              ),
            ],
          ),
        ),
        const Divider(color: Colors.white12, height: 1),
        
        // Task list
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemCount: tasks.length,
            itemBuilder: (context, index) {
              final task = tasks[index];
              final isSelected = task.docId == selectedTaskId;

              return AssignedTaskCard(
                task: task,
                isSelected: isSelected,
                onTap: () => onTaskSelected(task),
                currentUserId: currentUserId,
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.assignment_outlined,
            size: 80,
            color: Colors.white.withOpacity(0.2),
          ),
          const SizedBox(height: 16),
          const Text(
            'No Assigned Tasks',
            style: TextStyle(
              color: Colors.white70,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          const Text(
            'You have no tasks assigned to you',
            style: TextStyle(
              color: Colors.white38,
              fontSize: 14,
            ),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_workspace.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../../chat/models/chat_channel.dart';
import '../../../../chat/models/chat_conversation.dart';
import '../../../../chat/widgets/chat_shell.dart';
import '../models/assigned_task_view_model.dart';
import 'task_details_panel.dart';

enum TaskRole { manager, lead, member }

class AssignedTaskWorkspace extends StatefulWidget {
  final AssignedTaskViewModel task;
  final String tenantId;
  final VoidCallback onBack;

  const AssignedTaskWorkspace({
    super.key,
    required this.task,
    required this.tenantId,
    required this.onBack,
  });

  @override
  State<AssignedTaskWorkspace> createState() => _AssignedTaskWorkspaceState();
}

class _AssignedTaskWorkspaceState extends State<AssignedTaskWorkspace> {
  String activeView = 'details'; // details | manager | team

  String get currentUserUid => FirebaseAuth.instance.currentUser?.uid ?? '';

  TaskRole get role {
    if (currentUserUid == widget.task.assignedByUid) {
      return TaskRole.manager;
    }
    if (widget.task.isUserLead(currentUserUid)) {
      return TaskRole.lead;
    }
    return TaskRole.member;
  }

  bool get showManagerComm =>
      role == TaskRole.manager || role == TaskRole.lead;

  bool get showTeamCollab => role == TaskRole.lead || role == TaskRole.member;

  @override
  void initState() {
    super.initState();
    _validateActiveView();
  }

  void _validateActiveView() {
    if (!showManagerComm && activeView == 'manager') {
      activeView = 'details';
    }
    if (!showTeamCollab && activeView == 'team') {
      activeView = 'details';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildTopBar(),
        const Divider(color: Colors.white24, height: 1),
        Expanded(child: _buildContent()),
      ],
    );
  }

  Widget _buildTopBar() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header row with back button and title
          Row(
            children: [
              IconButton(
                icon: const Icon(Icons.arrow_back, color: Colors.cyan),
                onPressed: widget.onBack,
                tooltip: 'Back',
              ),
              const SizedBox(width: 8),
              Expanded(
                child: Text(
                  widget.task.title.isEmpty ? 'TASK' : widget.task.title.toUpperCase(),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
            ],
          ),
          
          const SizedBox(height: 16),

          // Tab buttons (responsive to role)
          _buildTabButtons(),
        ],
      ),
    );
  }

  Widget _buildTabButtons() {
    final List<Widget> buttons = [];

    // Task Details (always visible)
    buttons.add(
      Expanded(
        child: _buildTabButton(
          icon: Icons.info_outline,
          label: 'Task Details',
          isActive: activeView == 'details',
          onTap: () => setState(() => activeView = 'details'),
        ),
      ),
    );

    // Manager Communication (Manager + Lead)
    if (showManagerComm) {
      buttons.add(const SizedBox(width: 12));
      buttons.add(
        Expanded(
          child: _buildTabButton(
            icon: Icons.support_agent,
            label: 'Manager Communication',
            isActive: activeView == 'manager',
            onTap: () => setState(() => activeView = 'manager'),
            activeColor: Colors.cyanAccent,
          ),
        ),
      );
    }

    // Team Collaboration (Lead + Members)
    if (showTeamCollab) {
      buttons.add(const SizedBox(width: 12));
      buttons.add(
        Expanded(
          child: _buildTabButton(
            icon: Icons.group,
            label: 'Team Collaboration',
            isActive: activeView == 'team',
            onTap: () => setState(() => activeView = 'team'),
            activeColor: Colors.greenAccent,
          ),
        ),
      );
    }

    return Row(children: buttons);
  }

  Widget _buildTabButton({
    required IconData icon,
    required String label,
    required bool isActive,
    required VoidCallback onTap,
    Color activeColor = Colors.cyanAccent,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 250),
        curve: Curves.easeInOut,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          color: isActive
              ? activeColor.withOpacity(0.15)
              : Colors.white.withOpacity(0.05),
          borderRadius: BorderRadius.circular(30),
          border: Border.all(
            color: isActive ? activeColor : Colors.white.withOpacity(0.2),
            width: isActive ? 2 : 1,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              color: isActive ? activeColor : Colors.white60,
              size: 20,
            ),
            const SizedBox(width: 8),
            Flexible(
              child: Text(
                label,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
                style: TextStyle(
                  color: isActive ? activeColor : Colors.white60,
                  fontSize: 14,
                  fontWeight: isActive ? FontWeight.w600 : FontWeight.w500,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildContent() {
    if (!showManagerComm && activeView == 'manager') {
      activeView = 'details';
    }
    if (!showTeamCollab && activeView == 'team') {
      activeView = 'details';
    }

    switch (activeView) {
      case 'manager':
        return _buildManagerCommunication();

      case 'team':
        return _buildTeamCollaboration();

      case 'details':
      default:
        return TaskDetailsPanel(
          task: widget.task,
          tenantId: widget.tenantId,
        );
    }
  }

  Widget _buildManagerCommunication() {
    final conversation = ChatConversation(
      conversationId: widget.task.docId,
      taskTitle: widget.task.title,
      assignedByUid: widget.task.assignedByUid,
      assignedToUids: widget.task.assignedToUids,
      leadMemberUid: widget.task.leadMemberId,
      groupName: widget.task.groupName,
      dueDate: widget.task.dueDate,
    );

    return Padding(
      padding: const EdgeInsets.all(16),
      child: ChatShell(
        tenantId: widget.tenantId,
        conversation: conversation,
        channel: ChatChannel.managerCommunication,
        currentUserId: currentUserUid,
      ),
    );
  }

  Widget _buildTeamCollaboration() {
    final conversation = ChatConversation(
      conversationId: widget.task.docId,
      taskTitle: widget.task.title,
      assignedByUid: widget.task.assignedByUid,
      assignedToUids: widget.task.assignedToUids,
      leadMemberUid: widget.task.leadMemberId,
      groupName: widget.task.groupName,
      dueDate: widget.task.dueDate,
    );

    return Padding(
      padding: const EdgeInsets.all(16),
      child: ChatShell(
        tenantId: widget.tenantId,
        conversation: conversation,
        channel: ChatChannel.teamMembers,
        currentUserId: currentUserUid,
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\lead_badge.dart
import 'package:flutter/material.dart';

class LeadBadge extends StatelessWidget {
  final bool isCurrentUserLead;

  const LeadBadge({
    super.key,
    required this.isCurrentUserLead,
  });

  @override
  Widget build(BuildContext context) {
    if (!isCurrentUserLead) return const SizedBox.shrink();

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.16),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.amber, width: 0.8),
      ),
      child: const Text(
        'YOU ARE THE LEAD',
        style: TextStyle(
          color: Colors.amber,
          fontSize: 10,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\task_details_panel.dart
import 'package:flutter/material.dart';
import '../models/assigned_task_view_model.dart';
import '../../../utils/user_helper.dart';

class TaskDetailsPanel extends StatefulWidget {
  final AssignedTaskViewModel task;
  final String tenantId;

  const TaskDetailsPanel({
    super.key,
    required this.task,
    required this.tenantId,
  });

  @override
  State<TaskDetailsPanel> createState() => _TaskDetailsPanelState();
}

class _TaskDetailsPanelState extends State<TaskDetailsPanel> {
  String? leadMemberName;
  bool isLoadingLeadName = false;

  @override
  void initState() {
    super.initState();
    _fetchLeadMemberName();
  }

  Future<void> _fetchLeadMemberName() async {
    if (widget.task.hasLead && widget.task.leadMemberId != null) {
      setState(() => isLoadingLeadName = true);
      
      final name = await UserHelper.getUserDisplayName(
        tenantId: widget.tenantId,
        userId: widget.task.leadMemberId!,
      );
      
      if (mounted) {
        setState(() {
          leadMemberName = name;
          isLoadingLeadName = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Title
          const Text(
            'Task Overview',
            style: TextStyle(
              color: Colors.white,
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),

          // Description
          if (widget.task.description.isNotEmpty) ...[
            const Text(
              'Description',
              style: TextStyle(
                color: Colors.white70,
                fontSize: 14,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 4),
            Text(
              widget.task.description,
              style: const TextStyle(color: Colors.white),
            ),
            const SizedBox(height: 16),
          ],

          // Group Name
          if (widget.task.groupName.isNotEmpty) ...[
            _buildInfoRow(
              icon: Icons.label_outline,
              label: 'Group',
              value: widget.task.groupName,
            ),
            const SizedBox(height: 12),
          ],

          // Status & Priority
          Row(
            children: [
              _buildChip('Status', widget.task.status, Colors.cyanAccent),
              const SizedBox(width: 8),
              if (widget.task.priority.isNotEmpty)
                _buildChip('Priority', widget.task.priority, Colors.deepOrangeAccent),
            ],
          ),
          const SizedBox(height: 16),

          // Assignees
          _buildInfoRow(
            icon: Icons.people,
            label: 'Team Members',
            value: '${widget.task.assigneeCount} member(s)',
          ),
          const SizedBox(height: 12),

          // Lead Member with name
          if (widget.task.hasLead) ...[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(
                  Icons.star,
                  size: 18,
                  color: Colors.amberAccent,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Lead Member',
                        style: TextStyle(
                          color: Colors.white54,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(height: 2),
                      isLoadingLeadName
                          ? const SizedBox(
                              height: 14,
                              width: 14,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                valueColor: AlwaysStoppedAnimation(Colors.amberAccent),
                              ),
                            )
                          : Text(
                              leadMemberName ?? widget.task.leadMemberId ?? 'Not assigned',
                              style: const TextStyle(
                                color: Colors.amberAccent,
                                fontSize: 14,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
          ],

          // Due date
          if (widget.task.dueDate != null) ...[
            _buildInfoRow(
              icon: Icons.calendar_today,
              label: 'Due Date',
              value: _formatDueDate(widget.task.dueDate!),
              valueColor: _getDueDateColor(widget.task.dueDate!),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoRow({
    required IconData icon,
    required String label,
    required String value,
    Color? valueColor,
  }) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(
          icon,
          size: 18,
          color: Colors.white54,
        ),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: const TextStyle(
                  color: Colors.white54,
                  fontSize: 12,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                value,
                style: TextStyle(
                  color: valueColor ?? Colors.white,
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildChip(String label, String value, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.8)),
      ),
      child: Text(
        '$label: ${value.toUpperCase()}',
        style: TextStyle(
          color: color,
          fontSize: 12,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }

  Color _getDueDateColor(DateTime dueDate) {
    final now = DateTime.now();
    final difference = dueDate.difference(now);

    if (difference.isNegative) {
      return Colors.redAccent;
    } else if (difference.inDays <= 1) {
      return Colors.orangeAccent;
    } else if (difference.inDays <= 3) {
      return Colors.yellowAccent;
    } else {
      return Colors.white70;
    }
  }

  String _formatDueDate(DateTime date) {
    final now = DateTime.now();
    final difference = date.difference(now);

    if (difference.isNegative) {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} (Overdue)';
    } else if (difference.inDays == 0) {
      return 'Today at ${_formatTime(date)}';
    } else if (difference.inDays == 1) {
      return 'Tomorrow at ${_formatTime(date)}';
    } else {
      return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')} at ${_formatTime(date)}';
    }
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

================================================================================

// File: lib\task\utils\user_helper.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class UserHelper {
  static Future<String> getUserDisplayName({
    required String tenantId,
    required String userId,
  }) async {
    try {
      final userDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('users')
          .doc(userId)
          .get();

      if (userDoc.exists) {
        final data = userDoc.data();
        
        // Get profiledata nested map
        final profile = data?['profiledata'] as Map<dynamic, dynamic>? ?? {};
        
        // Get fullName from profiledata
        final fullName = profile['fullName'] as String?;
        
        // Fallback to email if fullName not available
        final email = data?['email'] as String?;
        
        // Return fullName if available, otherwise email, otherwise UID
        return fullName ?? email ?? userId;
      }
      
      return userId; // Fallback to UID if user not found
    } catch (e) {
      return userId; // Return UID on error
    }
  }
  
  /// Get user initials for avatar
  static String getUserInitials(String name) {
    if (name.isEmpty) return 'U';
    
    final parts = name.trim().split(' ');
    if (parts.length >= 2) {
      return '${parts[0][0]}${parts[1][0]}'.toUpperCase();
    }
    return name[0].toUpperCase();
  }
}

================================================================================

// File: lib\task\widgets\task_side_panel.dart
import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import '../task_tabs_manifest.dart';

class TaskSidePanel extends StatelessWidget {
  final String selectedTabId;
  final ValueChanged<String> onSelect;

  const TaskSidePanel({
    super.key,
    required this.selectedTabId,
    required this.onSelect,
  });

  @override
  Widget build(BuildContext context) {
    final wallpaper = WallpaperService.instance;

    return AnimatedBuilder(
      animation: wallpaper,
      builder: (context, _) {
        final double glassBlur = wallpaper.globalGlassBlur;
        final double glassOpacity = wallpaper.globalGlassOpacity;

        return GlassContainer(
            blur: glassBlur,
            opacity: glassOpacity * 0.7,
            tint: Colors.white,
            borderRadius: BorderRadius.circular(20),
            padding: const EdgeInsets.symmetric(vertical: 10),
            // ADD THIS:
            blurMode: GlassBlurMode.perWidget,
          child: Column(
            children: [
              const SizedBox(height: 6),
              const Text(
                'TASK',
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.w700,
                  letterSpacing: 1.2,
                ),
              ),
              const SizedBox(height: 10),
              Expanded(
                child: ListView(
                  children: [
                    for (final t in taskTabs)
                      _item(
                        selected: selectedTabId == t.id,
                        icon: t.icon,
                        title: t.title,
                        onTap: () => onSelect(t.id),
                      ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _item({
    required bool selected,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    final Color fg = selected ? Colors.cyanAccent : Colors.white70;

    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
        decoration: BoxDecoration(
          color: selected ? Colors.cyan.withOpacity(0.12) : Colors.transparent,
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color:
                selected ? Colors.cyanAccent.withOpacity(0.5) : Colors.white12,
          ),
        ),
        child: Row(
          children: [
            Icon(icon, color: fg, size: 18),
            const SizedBox(width: 10),
            Text(
              title,
              style: TextStyle(
                color: fg,
                fontWeight: selected ? FontWeight.w600 : FontWeight.w400,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================

// File: lib\workspace\loading_screen.dart
import 'dart:async';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../core/permissions_cache.dart';
import '../core/wallpaper_service.dart';
import '../dynamic_screen/dashboard_permissions.dart';

class LoadingScreen extends StatefulWidget {
  final VoidCallback onLoadingComplete;

  const LoadingScreen({
    super.key,
    required this.onLoadingComplete,
  });

  @override
  State<LoadingScreen> createState() => _LoadingScreenState();
}

class _LoadingScreenState extends State<LoadingScreen>
    with SingleTickerProviderStateMixin {
  late final AnimationController _pulseController;
  late final Animation<double> _pulse;

  final ValueNotifier<double> _progress = ValueNotifier<double>(0.0);
  final ValueNotifier<String> _status = ValueNotifier<String>('Initializingâ€¦');

  bool _completed = false;
  Object? _error;

  @override
  void initState() {
    super.initState();

    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1400),
    )..repeat(reverse: true);

    _pulse = Tween<double>(begin: 0.96, end: 1.04).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );

    // Start after first frame so context is stable.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      unawaited(_startLoadingSequence());
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _progress.dispose();
    _status.dispose();
    super.dispose();
  }

  Future<void> _startLoadingSequence() async {
    if (_completed) return;

    try {
      _error = null;

      await _step(0.10, 'Loading wallpaperâ€¦', () async {
        // Safe even if already loaded (WallpaperService guards internally)
        await WallpaperService.instance.loadSettings();
      });

      await _step(0.35, 'Checking authenticationâ€¦', () async {
        // Just touching currentUser is cheap; no extra delay needed
        FirebaseAuth.instance.currentUser;
      });

      await _step(0.65, 'Loading permissionsâ€¦', () async {
        final user = FirebaseAuth.instance.currentUser;
        if (user == null) return;

        // Use cache first
        final cached = PermissionsCache.instance.getCachedPermissions(user.uid);
        if (cached != null) return;

        final ids = await _loadPermissions(user.uid);
        PermissionsCache.instance.setCachedPermissions(user.uid, ids);
      });

      await _step(0.90, 'Finalizingâ€¦', () async {
        // Tiny yield to ensure UI paints last progress update
        await Future<void>.delayed(const Duration(milliseconds: 60));
      });

      _progress.value = 1.0;
      _status.value = 'Ready';

      await Future<void>.delayed(const Duration(milliseconds: 160));
      _complete();
    } catch (e) {
      _error = e;
      _status.value = 'Loading failed. Retry?';
      if (kDebugMode) {
        debugPrint('[LoadingScreen] error: $e');
      }
    }
  }

  Future<void> _step(
    double progress,
    String message,
    Future<void> Function() action,
  ) async {
    _progress.value = progress;
    _status.value = message;
    await action();
  }

  Future<Set<String>> _loadPermissions(String userId) async {
    final completer = Completer<Set<String>>();

    await DashboardPermissions.loadUserPermissions(
      context: context,
      userId: userId,
      onAllowedWidgetIds: (ids) {
        if (!completer.isCompleted) completer.complete(ids);
      },
    );

    // Safety: don't hang forever on network issues.
    return completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => <String>{'login'},
    );
  }

  void _complete() {
    if (_completed) return;
    _completed = true;
    widget.onLoadingComplete();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Stack(
        children: [
          // Wallpaper background: repaints only this layer on wallpaper changes.
          Positioned.fill(
            child: AnimatedBuilder(
              animation: WallpaperService.instance,
              builder: (_, __) => DecoratedBox(
                decoration: WallpaperService.instance.backgroundDecoration,
              ),
            ),
          ),

          // Subtle dark overlay for legibility
          Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.45),
              ),
            ),
          ),

          Center(
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 520),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 22),
                child: ScaleTransition(
                  scale: _pulse,
                  child: _Card(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const SizedBox(height: 6),
                        const Text(
                          'WALL-D',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 22,
                            fontWeight: FontWeight.w800,
                            letterSpacing: 1.4,
                          ),
                        ),
                        const SizedBox(height: 10),
                        const Text(
                          'Preparing your workspaceâ€¦',
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(color: Colors.white70, fontSize: 12),
                        ),
                        const SizedBox(height: 18),

                        ValueListenableBuilder<double>(
                          valueListenable: _progress,
                          builder: (_, p, __) {
                            return ClipRRect(
                              borderRadius: BorderRadius.circular(999),
                              child: LinearProgressIndicator(
                                value: p.clamp(0.0, 1.0),
                                minHeight: 8,
                                backgroundColor: Colors.white.withOpacity(0.10),
                                valueColor: const AlwaysStoppedAnimation<Color>(
                                  Colors.cyanAccent,
                                ),
                              ),
                            );
                          },
                        ),

                        const SizedBox(height: 12),

                        ValueListenableBuilder<String>(
                          valueListenable: _status,
                          builder: (_, msg, __) {
                            return Text(
                              msg,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: const TextStyle(
                                color: Colors.white60,
                                fontSize: 12,
                              ),
                            );
                          },
                        ),

                        if (_error != null) ...[
                          const SizedBox(height: 14),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            children: [
                              TextButton(
                                onPressed: _complete,
                                child: const Text('Continue'),
                              ),
                              const SizedBox(width: 8),
                              FilledButton(
                                onPressed: () {
                                  _error = null;
                                  unawaited(_startLoadingSequence());
                                },
                                child: const Text('Retry'),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _Card extends StatelessWidget {
  final Widget child;
  const _Card({required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(18, 16, 18, 14),
      decoration: BoxDecoration(
        color: const Color(0xCC0B0B12),
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: Colors.white.withOpacity(0.10)),
        boxShadow: const [
          BoxShadow(
            color: Color(0xAA000000),
            blurRadius: 24,
            offset: Offset(0, 14),
          ),
        ],
      ),
      child: child,
    );
  }
}

================================================================================

// File: lib\workspace\universal_top_bar.dart
import 'package:flutter/material.dart';

import '../core/glass_container.dart';
import '../workspace/workspace_switcher.dart';
import 'workspace_controller.dart';
import '../core/wallpaper_service.dart';

class UniversalTopBar extends StatelessWidget {
  final WorkspaceController workspaceController;
  final VoidCallback onWallpaperSettings;
  final VoidCallback onGlassSettings;
  final VoidCallback onSignOut;

  const UniversalTopBar({
    super.key,
    required this.workspaceController,
    required this.onWallpaperSettings,
    required this.onGlassSettings,
    required this.onSignOut,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;
        final double glassBlur = ws.globalGlassBlur;
        final double glassOpacity = ws.globalGlassOpacity;

        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.fromLTRB(18, 12, 18, 0),
            child: SizedBox(
              height: 40,
              child: GlassContainer(
                blur: glassBlur,  // NOW REACTIVE
                opacity: glassOpacity,  // NOW REACTIVE
                tint: Colors.white,
                borderRadius: BorderRadius.circular(20),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
                blurMode: GlassBlurMode.perWidget,  // FORCE BLUR (top bar is tiny)
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    // LEFT: Branding
                    const Align(
                      alignment: Alignment.centerLeft,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.blur_on_rounded,
                            color: Colors.cyan,
                            size: 18,
                          ),
                          SizedBox(width: 8),
                          Text(
                            'Wall-D Workspace',
                            style: TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    ),

                    // CENTER: Workspace Switcher
                    Align(
                      alignment: Alignment.center,
                      child: WorkspaceSwitcher(
                        controller: workspaceController,
                      ),
                    ),

                    // RIGHT: Settings & Actions
                    Align(
                      alignment: Alignment.centerRight,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          IconButton(
                            icon: const Icon(
                              Icons.wallpaper_rounded,
                              color: Colors.white70,
                              size: 18,
                            ),
                            tooltip: 'Wallpaper settings',
                            onPressed: onWallpaperSettings,
                          ),
                          IconButton(
                            icon: const Icon(
                              Icons.tune_rounded,
                              color: Colors.white70,
                              size: 18,
                            ),
                            tooltip: 'Glass settings',
                            onPressed: onGlassSettings,
                          ),
                          IconButton(
                            icon: const Icon(
                              Icons.logout_rounded,
                              color: Colors.redAccent,
                              size: 18,
                            ),
                            tooltip: 'Sign out',
                            onPressed: onSignOut,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\workspace\workspace_controller.dart
import 'package:flutter/foundation.dart';
import 'workspace_ids.dart';

class WorkspaceController extends ChangeNotifier {
  String _current = WorkspaceIds.dashboard;

  String get current => _current;

  // FIX: Added 'switchTo' to match the call in UniversalTopBar
  void switchTo(String id) {
    if (id == _current) return;
    _current = id;
    notifyListeners();
  }

  // Optional: Keep this if other files use it, or alias it
  void setWorkspace(String id) => switchTo(id);
}

================================================================================

// File: lib\workspace\workspace_ids.dart
class WorkspaceIds {
  static const dashboard = 'dashboard';
  static const task = 'task';
}

================================================================================

// File: lib\workspace\workspace_shell.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:walld_flutter/core/permissions_cache.dart';
import 'package:walld_flutter/workspace/universal_top_bar.dart';
import 'package:walld_flutter/workspace/workspace_controller.dart';
import 'package:walld_flutter/workspace/workspace_ids.dart';

import '../core/performance_state.dart';
import '../core/wallpaper_service.dart';
import '../dynamic_screen/dashboard_screen.dart';
import '../task/task_workspace.dart';

// Imports from the other 2 files
import 'widgets/fps_counter.dart';
import 'mixins/shell_performance_mixin.dart';

class WorkspaceShell extends StatefulWidget {
  final WorkspaceController workspaceController;

  const WorkspaceShell({
    super.key,
    required this.workspaceController,
  });

  @override
  State<WorkspaceShell> createState() => WorkspaceShellState();
}

// Mixin added here to separate performance logic
class WorkspaceShellState extends State<WorkspaceShell>
    with SingleTickerProviderStateMixin, ShellPerformanceMixin {
  
  // DEBUG INSTANCE TRACKING
  static int _instanceCounter = 0;
  final int _instanceNumber;
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString();

  late final AnimationController animationController;
  late final Animation<Offset> _slideForward;
  late final Animation<Offset> _slideBackward;
  late final Animation<double> _fadeOut;
  late final Animation<double> _fadeIn;

  int _currentIndex = 0;
  int _previousIndex = 0;
  bool _isAnimating = false;
  bool _isForward = true;

  Duration _lastBuildDuration = Duration.zero;

  WorkspaceShellState() : _instanceNumber = ++_instanceCounter {
    debugPrint('ğŸ¢ WorkspaceShell INSTANCE #$_instanceNumber CREATED (ID: $_instanceId)');
  }

  @override
  void initState() {
    super.initState();
    debugPrint('ğŸ¢ WorkspaceShell #$_instanceNumber - initState()');

    _currentIndex = _getCurrentIndex();
    _previousIndex = _currentIndex;

    animationController = AnimationController(
      duration: const Duration(milliseconds: 360),
      vsync: this,
    );

    _setupCachedAnimations();

    animationController.addStatusListener((status) {
      if (status == AnimationStatus.forward) {
        setAnimating(true); // From Mixin
        if (mounted) setState(() => _isAnimating = true);
      } else if (status == AnimationStatus.completed) {
        setAnimating(false); // From Mixin
        if (mounted) {
          setState(() {
            _isAnimating = false;
            _previousIndex = _currentIndex;
          });
        }
      }
    });

    widget.workspaceController.addListener(_onWorkspaceChanged);
    
    // Initialize performance tracking from Mixin
    initPerformanceTracking();
  }

  void _setupCachedAnimations() {
    const curve = Curves.easeInOutCubicEmphasized;

    _slideForward = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(-1.0, 0.0),
    ).animate(CurvedAnimation(parent: animationController, curve: curve));

    _slideBackward = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(1.0, 0.0),
    ).animate(CurvedAnimation(parent: animationController, curve: curve));

    _fadeOut = Tween<double>(begin: 1.0, end: 0.0).animate(
      CurvedAnimation(
        parent: animationController,
        curve: const Interval(0.0, 0.60, curve: Curves.easeOut),
      ),
    );

    _fadeIn = Tween<double>(begin: 0.2, end: 1.0).animate(
      CurvedAnimation(
        parent: animationController,
        curve: const Interval(0.10, 0.85, curve: Curves.easeIn),
      ),
    );
  }

  int _getCurrentIndex() {
    return widget.workspaceController.current == WorkspaceIds.task ? 1 : 0;
  }

  void _onWorkspaceChanged() {
    final newIndex = _getCurrentIndex();
    if (newIndex == _currentIndex) return;
    if (_isAnimating) return;

    setState(() {
      _previousIndex = _currentIndex;
      _currentIndex = newIndex;
      _isForward = newIndex > _previousIndex;
    });

    animationController.forward(from: 0.0);
  }

  // NOTE: This logic stays here because it accesses AnimationController
  @override
  void onLowEndModeChanged(bool isLowEnd) {
    if (isLowEnd) {
      animationController.duration = const Duration(milliseconds: 300);
    }
  }

  Future<void> pickWallpaperFromWindows() async {
    await WallpaperService.instance.pickWallpaper();
  }

  Future<void> signOut() async {
  try {
    debugPrint('WorkspaceShell #$_instanceNumber - Starting logout process...');

    PermissionsCache.instance.clearCache();
    debugPrint('Permissions cache cleared');

    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
    debugPrint('SharedPreferences cleared');

    WallpaperService.instance.wallpaperPath = null;
    WallpaperService.instance.globalGlassOpacity = 0.12;
    WallpaperService.instance.globalGlassBlur = 16.0;
    debugPrint('WallpaperService reset');

    await FirebaseAuth.instance.signOut();
    debugPrint('Firebase Auth signed out');

    if (!mounted) return;

    

    // SnackBar...
  } catch (e) {
    debugPrint('Sign out error: $e');
  }
}


  Future<void> openGlobalGlassSheet() async {
  final service = WallpaperService.instance;
  double tempOpacity = service.globalGlassOpacity;
  double tempBlur = service.globalGlassBlur;

  final applied = await showModalBottomSheet<bool>(
    context: context,
    backgroundColor: const Color(0xFF05040A),
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
    ),
    builder: (context) {
      return StatefulBuilder(
        builder: (context, setModalState) {
          return SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text('Glass settings', style: TextStyle(color: Colors.white, fontSize: 16)),
                  const SizedBox(height: 20),
                  
                  // Opacity slider
                  Row(
                    children: [
                      const Text('Opacity', style: TextStyle(color: Colors.white70)),
                      Expanded(
                        child: Slider(
                          min: 0.04,
                          max: 0.30,
                          divisions: 26,
                          value: tempOpacity.clamp(0.04, 0.30),
                          onChanged: (v) {
                            setModalState(() => tempOpacity = v);
                            service.setGlassOpacity(v); // âœ… Auto-saves now!
                          },
                        ),
                      ),
                    ],
                  ),
                  
                  // Blur slider
                  Row(
                    children: [
                      const Text('Blur', style: TextStyle(color: Colors.white70)),
                      Expanded(
                        child: Slider(
                          min: 0,
                          max: 30,
                          divisions: 30,
                          value: tempBlur.clamp(0, 30),
                          onChanged: (v) {
                            setModalState(() => tempBlur = v);
                            service.setGlassBlur(v); // âœ… Auto-saves now!
                          },
                        ),
                      ),
                    ],
                  ),
                  
                  // Close button
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () => Navigator.pop(context, true),
                      child: const Text('Close'),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    },
  );
  
  // âŒ REMOVED: No need to manually save anymore
  // if (applied == true) {
  //   service.setGlassOpacity(tempOpacity);
  //   service.setGlassBlur(tempBlur);
  //   await service.saveSettings();
  // }
}


  @override
  void dispose() {
    debugPrint('ğŸ¢ WorkspaceShell #$_instanceNumber DISPOSED');
    widget.workspaceController.removeListener(_onWorkspaceChanged);
    animationController.dispose();
    disposePerformanceTracking(); // From Mixin
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final buildStart = DateTime.now();

    final outgoingSlide = _isForward ? _slideForward : _slideBackward;
    final incomingSlide = _isForward
        ? Tween<Offset>(begin: const Offset(1.0, 0.0), end: Offset.zero).animate(
            CurvedAnimation(parent: animationController, curve: Curves.easeInOutCubicEmphasized))
        : Tween<Offset>(begin: const Offset(-1.0, 0.0), end: Offset.zero).animate(
            CurvedAnimation(parent: animationController, curve: Curves.easeInOutCubicEmphasized));

    final result = Scaffold(
      backgroundColor: Colors.transparent,
      body: Stack(
        children: [
          // 1) Wallpaper
          Positioned.fill(
            child: AnimatedBuilder(
              animation: WallpaperService.instance,
              builder: (_, __) => DecoratedBox(
                decoration: WallpaperService.instance.backgroundDecoration,
              ),
            ),
          ),

          // 2) Content
          RepaintBoundary(
            child: AnimatedBuilder(
              animation: animationController,
              builder: (context, child) {
                return Stack(
                  children: [
                    Positioned.fill(
                      child: Visibility(
                        visible: _currentIndex == 0 || _isAnimating,
                        child: SlideTransition(
                          position: _currentIndex == 0 ? incomingSlide : outgoingSlide,
                          child: FadeTransition(
                            opacity: _currentIndex == 0 ? _fadeIn : _fadeOut,
                            child: const RepaintBoundary(
                                child: DashboardScreen(key: PageStorageKey('dashboardscreen'))),
                          ),
                        ),
                      ),
                    ),
                    Positioned.fill(
                      child: Visibility(
                        visible: _currentIndex == 1 || _isAnimating,
                        child: SlideTransition(
                          position: _currentIndex == 1 ? incomingSlide : outgoingSlide,
                          child: FadeTransition(
                            opacity: _currentIndex == 1 ? _fadeIn : _fadeOut,
                            child: const RepaintBoundary(
                                child: TaskWorkspace(key: PageStorageKey('taskworkspace'))),
                          ),
                        ),
                      ),
                    ),
                  ],
                );
              },
            ),
          ),

          // 3) Top Bar
          RepaintBoundary(
            child: UniversalTopBar(
              workspaceController: widget.workspaceController,
              onWallpaperSettings: pickWallpaperFromWindows,
              onGlassSettings: openGlobalGlassSheet,
              onSignOut: signOut,
            ),
          ),

          // 4) FPS Counter (Using Mixin Data)
          if (showFPS)
            Positioned(
              top: 60, right: 16,
              child: ValueListenableBuilder<double>(
                valueListenable: fpsNotifier,
                builder: (context, fps, _) {
                  return ValueListenableBuilder<bool>(
                    valueListenable: isAnimatingNotifier,
                    builder: (context, isAnimating, _) {
                      return FPSCounter(
                        fps: fps,
                        isAnimating: isAnimating,
                        isLowEnd: isLowEndDevice,
                        vsyncLocked: vsyncLockDetected,
                        avgFrameTime: avgFrameTimeWindow,
                        warmupStable: PerformanceState.instance.isWarmupStable,
                        onToggle: toggleFPS,
                      );
                    },
                  );
                },
              ),
            ),
        ],
      ),
    );

    _lastBuildDuration = DateTime.now().difference(buildStart);
    if (kDebugMode && _lastBuildDuration.inMilliseconds > 24) {
      debugPrint('[BUILD] #$_instanceNumber dt=${_lastBuildDuration.inMilliseconds}ms');
    }

    return result;
  }
}

================================================================================

// File: lib\workspace\workspace_switcher.dart
import 'package:flutter/material.dart';
import '../core/glass_container.dart';
import 'workspace_controller.dart';
import 'workspace_ids.dart';

class WorkspaceSwitcher extends StatelessWidget {
  final WorkspaceController controller;

  const WorkspaceSwitcher({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (_, __) {
        final current = controller.current;

        return GlassContainer(
          blur: 16,
          opacity: 0.10,
          tint: Colors.white,
          borderRadius: BorderRadius.circular(999),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              _pillIcon(
                selected: current == WorkspaceIds.dashboard,
                icon: Icons.dashboard_customize_rounded,
                tooltip: 'Dashboard',
                onTap: () => controller.setWorkspace(WorkspaceIds.dashboard),
              ),
              const SizedBox(width: 6),
              _pillIcon(
                selected: current == WorkspaceIds.task,
                icon: Icons.task_alt_rounded,
                tooltip: 'Task',
                onTap: () => controller.setWorkspace(WorkspaceIds.task),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _pillIcon({
    required bool selected,
    required IconData icon,
    required String tooltip,
    required VoidCallback onTap,
  }) {
    final fg = selected ? Colors.cyanAccent : Colors.white70;
    final bg = selected ? Colors.cyan.withOpacity(0.16) : Colors.transparent;

    return Tooltip(
      message: tooltip,
      child: InkWell(
        borderRadius: BorderRadius.circular(999),
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(999),
            border: Border.all(
              color: selected ? Colors.cyanAccent.withOpacity(0.6) : Colors.white24,
              width: 1,
            ),
          ),
          child: Icon(icon, size: 18, color: fg),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\workspace\mixins\shell_performance_mixin.dart
import 'dart:collection';
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/material.dart';

import '../../core/performance_state.dart';
import '../../core/wallpaper_service.dart';

mixin ShellPerformanceMixin<T extends StatefulWidget> on State<T> {
  
  // State variables for Performance
  final ValueNotifier<double> fpsNotifier = ValueNotifier<double>(60.0);
  final ValueNotifier<bool> isAnimatingNotifier = ValueNotifier<bool>(false);
  
  bool showFPS = true;
  bool isLowEndDevice = false;
  bool vsyncLockDetected = false;
  double avgFrameTimeWindow = 0.0;
  
  // Internal trackers
  final Queue<double> _frameMsWindow = Queue<double>();
  static const int _windowSize = 180;
  static const double _targetFrameTime = 16.67;
  static const double _jankThreshold = 33.33;
  static const double _severeJankThreshold = 50.0;
  
  int _frameCount = 0;
  int _consecutive30fpsLike = 0;
  int _stableChecks = 0;
  bool _warmupMarked = false;
  
  DateTime _lastPerfLog = DateTime.fromMillisecondsSinceEpoch(0);
  DateTime _lastJankLog = DateTime.fromMillisecondsSinceEpoch(0);
  DateTime _lastSevereJankLog = DateTime.fromMillisecondsSinceEpoch(0);

  // Method to be overridden by Shell to adjust animations
  void onLowEndModeChanged(bool isLowEnd) {}

  void initPerformanceTracking() {
    SchedulerBinding.instance.addTimingsCallback(_onFrameTimings);
  }

  void disposePerformanceTracking() {
    SchedulerBinding.instance.removeTimingsCallback(_onFrameTimings);
    fpsNotifier.dispose();
    isAnimatingNotifier.dispose();
  }

  void setAnimating(bool animating) {
    isAnimatingNotifier.value = animating;
  }
  
  void toggleFPS() {
    if (mounted) setState(() => showFPS = !showFPS);
  }

  void _onFrameTimings(List<FrameTiming> timings) {
    for (final t in timings) {
      final frameMs = t.totalSpan.inMicroseconds / 1000.0;

      _frameMsWindow.addLast(frameMs);
      while (_frameMsWindow.length > _windowSize) {
        _frameMsWindow.removeFirst();
      }

      final avgMs = _frameMsWindow.isEmpty
          ? _targetFrameTime
          : _frameMsWindow.reduce((a, b) => a + b) / _frameMsWindow.length;

      avgFrameTimeWindow = avgMs;

      final fps = (1000.0 / avgMs).clamp(1.0, 240.0);
      _frameCount++;

      PerformanceState.instance.currentFps = fps;

      if (_frameCount % 10 == 0) {
        fpsNotifier.value = fps;
      }

      if (!isLowEndDevice && fps < 50) {
        isLowEndDevice = true;
        onLowEndModeChanged(true);
        _applyPerformanceOptimizations(fps);
      }

      if (!kDebugMode) continue;

      if (frameMs >= _severeJankThreshold) {
        final now = DateTime.now();
        if (now.difference(_lastSevereJankLog).inMilliseconds >= 700) {
          _lastSevereJankLog = now;
          _logJank(severe: true, frameMs: frameMs, fps: fps);
        }
      } else if (frameMs >= _jankThreshold) {
        final now = DateTime.now();
        if (now.difference(_lastJankLog).inMilliseconds >= 900) {
          _lastJankLog = now;
          _logJank(severe: false, frameMs: frameMs, fps: fps);
        }
      }

      _detectVsyncLock(avgMs);
      _checkWarmupStability(avgMs, fps);

      final now = DateTime.now();
      if (now.difference(_lastPerfLog).inSeconds >= 10) {
        _lastPerfLog = now;
        debugPrint(
          '[PERF] fps=${fps.toStringAsFixed(1)} avg=${avgMs.toStringAsFixed(1)}ms '
          'stable=${PerformanceState.instance.isWarmupStable ? "Y" : "N"}',
        );
      }
    }
  }

  void _logJank({required bool severe, required double frameMs, required double fps}) {
    final tag = severe ? 'JANK:S' : 'JANK:M';
    final dropped = (frameMs / _targetFrameTime).floor();
    debugPrint('[$tag] dt=${frameMs.toStringAsFixed(1)}ms drop=$dropped fps=${fps.toStringAsFixed(1)}');
    
    if (severe) {
      developer.Timeline.instantSync('JANK_SEVERE', arguments: {'dtMs': frameMs, 'fps': fps});
    }
  }

  void _detectVsyncLock(double avgMs) {
    if (avgMs > 30.0 && avgMs < 36.5) {
      if (++_consecutive30fpsLike >= 12) vsyncLockDetected = true;
    } else if (avgMs < 22.0) {
      _consecutive30fpsLike = 0;
      vsyncLockDetected = false;
    }
  }

  void _checkWarmupStability(double avgMs, double fps) {
    if (_warmupMarked || _frameMsWindow.length < 120) return;
    
    final severeCount = _frameMsWindow.where((ms) => ms >= _severeJankThreshold).length;
    final stable = fps >= 45 && !isAnimatingNotifier.value && severeCount <= 6;

    if (stable) {
      if (++_stableChecks >= 6) {
        _warmupMarked = true;
        PerformanceState.instance.isWarmupStable = true;
        if (kDebugMode) debugPrint('[WARMUP] Stable! fps=${fps.toStringAsFixed(1)}');
      }
    } else {
      _stableChecks = 0;
    }
  }

  void _applyPerformanceOptimizations(double avgFps) {
    final ws = WallpaperService.instance;
    if (avgFps < 25) {
      ws.setGlassBlur(0.0);
      ws.setGlassOpacity(0.04);
      if (kDebugMode) debugPrint('[OPT] extreme blur=0 op=0.04');
    } else if (avgFps < 40) {
      ws.setGlassBlur(6.0);
      ws.setGlassOpacity(0.08);
      if (kDebugMode) debugPrint('[OPT] medium blur=6 op=0.08');
    } else if (avgFps < 50) {
      ws.setGlassBlur(8.0);
      ws.setGlassOpacity(0.10);
      if (kDebugMode) debugPrint('[OPT] light blur=8 op=0.10');
    }
  }
}

================================================================================

// File: lib\workspace\widgets\fps_counter.dart
import 'package:flutter/material.dart';

class FPSCounter extends StatelessWidget {
  final double fps;
  final bool isAnimating;
  final bool isLowEnd;
  final bool vsyncLocked;
  final double avgFrameTime;
  final bool warmupStable;
  final VoidCallback onToggle;

  const FPSCounter({
    super.key,
    required this.fps,
    required this.isAnimating,
    required this.isLowEnd,
    required this.vsyncLocked,
    required this.avgFrameTime,
    required this.warmupStable,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    Color fpsColor;
    String status;

    if (fps >= 58) {
      fpsColor = Colors.greenAccent;
      status = 'EXCELLENT';
    } else if (fps >= 50) {
      fpsColor = Colors.yellowAccent;
      status = 'GOOD';
    } else if (fps >= 40) {
      fpsColor = Colors.orangeAccent;
      status = 'FAIR';
    } else if (fps >= 28 && fps <= 32) {
      fpsColor = Colors.redAccent;
      status = 'VSYNC 30FPS';
    } else {
      fpsColor = Colors.red;
      status = 'LOW';
    }

    return GestureDetector(
      onTap: onToggle,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.85),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: fpsColor.withOpacity(0.6), width: 2),
          boxShadow: [
            BoxShadow(
              color: fpsColor.withOpacity(0.25),
              blurRadius: 14,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.speed, color: fpsColor, size: 18),
                const SizedBox(width: 6),
                Text(
                  '${fps.toStringAsFixed(1)} FPS',
                  style: TextStyle(
                    color: fpsColor,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    fontFamily: 'monospace',
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Text(
              status,
              style: TextStyle(
                color: fpsColor.withOpacity(0.9),
                fontSize: 11,
                fontWeight: FontWeight.w700,
                letterSpacing: 0.5,
              ),
            ),
            if (avgFrameTime > 0) ...[
              const SizedBox(height: 4),
              Text(
                'Frame: ${avgFrameTime.toStringAsFixed(1)}ms',
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 10,
                  fontFamily: 'monospace',
                ),
              ),
            ],
            if (warmupStable) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.greenAccent.withOpacity(0.18),
                  borderRadius: BorderRadius.circular(4),
                  border: Border.all(
                    color: Colors.greenAccent.withOpacity(0.45),
                    width: 1,
                  ),
                ),
                child: const Text(
                  'WARM-UP OK',
                  style: TextStyle(
                    color: Colors.greenAccent,
                    fontSize: 9,
                    fontWeight: FontWeight.w800,
                  ),
                ),
              ),
            ],
            if (vsyncLocked) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.redAccent.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                  border: Border.all(color: Colors.redAccent, width: 1),
                ),
                child: const Text(
                  'VSYNC LOCKED',
                  style: TextStyle(
                    color: Colors.redAccent,
                    fontSize: 9,
                    fontWeight: FontWeight.w900,
                  ),
                ),
              ),
            ],
            if (isLowEnd) ...[
              const SizedBox(height: 4),
              const Text(
                'OPTIMIZED',
                style: TextStyle(
                  color: Colors.orangeAccent,
                  fontSize: 9,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
            if (isAnimating) ...[
              const SizedBox(height: 4),
              const Text(
                'ANIMATING',
                style: TextStyle(
                  color: Colors.cyanAccent,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

================================================================================

