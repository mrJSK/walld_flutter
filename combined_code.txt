================================================================================
PROJECT FILE STRUCTURE
================================================================================

Root: lib (lib)
â”œâ”€â”€ chat/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ chat_channel.dart
â”‚   â”‚   â”œâ”€â”€ chat_conversation.dart
â”‚   â”‚   â””â”€â”€ chat_message.dart
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ chat_repository.dart
â”‚   â””â”€â”€ widgets/
â”‚       â”œâ”€â”€ chat_input_bar.dart
â”‚       â”œâ”€â”€ chat_shell.dart
â”‚       â”œâ”€â”€ message_bubble.dart
â”‚       â””â”€â”€ message_list.dart
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ app_colors.dart
â”‚   â”œâ”€â”€ glass_container.dart
â”‚   â”œâ”€â”€ performance_state.dart
â”‚   â”œâ”€â”€ permissions_cache.dart
â”‚   â””â”€â”€ wallpaper_service.dart
â”œâ”€â”€ Developer/
â”‚   â”œâ”€â”€ DynamicForms/
â”‚   â”‚   â”œâ”€â”€ dynamic_forms_panel.dart
â”‚   â”‚   â”œâ”€â”€ dynamic_forms_repository.dart
â”‚   â”‚   â””â”€â”€ form_models.dart
â”‚   â”œâ”€â”€ Hierarchy/
â”‚   â”‚   â”œâ”€â”€ hierarchy_panel.dart
â”‚   â”‚   â”œâ”€â”€ hierarchy_repository.dart
â”‚   â”‚   â””â”€â”€ org_node_model.dart
â”‚   â”œâ”€â”€ Metadata/
â”‚   â”‚   â”œâ”€â”€ designation/
â”‚   â”‚   â”‚   â”œâ”€â”€ designation_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ designation_tab.dart
â”‚   â”‚   â”œâ”€â”€ form_schema/
â”‚   â”‚   â”‚   â”œâ”€â”€ form_schema_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ form_schema_tab.dart
â”‚   â”‚   â”œâ”€â”€ role_permission/
â”‚   â”‚   â”‚   â”œâ”€â”€ role_permission_model.dart
â”‚   â”‚   â”‚   â””â”€â”€ role_permission_tab.dart
â”‚   â”‚   â”œâ”€â”€ metadata_panel.dart
â”‚   â”‚   â””â”€â”€ metadata_repository.dart
â”‚   â”œâ”€â”€ UserDatabase/
â”‚   â”‚   â”œâ”€â”€ userdatabasemodel.dart
â”‚   â”‚   â”œâ”€â”€ userdatabasepanel.dart
â”‚   â”‚   â””â”€â”€ userdatabaserepository.dart
â”‚   â””â”€â”€ developer_dashboard_screen.dart
â”œâ”€â”€ dynamic_screen/
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ floating_widget.dart
â”‚   â”‚   â”œâ”€â”€ grid_layout.dart
â”‚   â”‚   â”œâ”€â”€ screen_grid.dart
â”‚   â”‚   â”œâ”€â”€ task_form_models.dart
â”‚   â”‚   â””â”€â”€ widget.dart
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â””â”€â”€ dashboard_repository.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”œâ”€â”€ complete_task_widget.dart
â”‚   â”‚   â”œâ”€â”€ create_task_widget.dart
â”‚   â”‚   â”œâ”€â”€ login_widget.dart
â”‚   â”‚   â”œâ”€â”€ view_all_tasks_widget.dart
â”‚   â”‚   â”œâ”€â”€ view_assigned_tasks_widget.dart
â”‚   â”‚   â””â”€â”€ widgets.dart
â”‚   â”œâ”€â”€ dashboard_drawer.dart
â”‚   â”œâ”€â”€ dashboard_grid.dart
â”‚   â”œâ”€â”€ dashboard_layout_persistence.dart
â”‚   â”œâ”€â”€ dashboard_permissions.dart
â”‚   â”œâ”€â”€ dashboard_screen.dart
â”‚   â”œâ”€â”€ dashboardpanel.dart
â”‚   â”œâ”€â”€ widget_factory.dart
â”‚   â”œâ”€â”€ widget_manifest.dart
â”‚   â””â”€â”€ widgets.dart
â”œâ”€â”€ task/
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ create_task_page/
â”‚   â”‚   â”‚   â”œâ”€â”€ mixins/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user_data_loader_mixin.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ assignment_data.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assignment_type_selector.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dynamic_date_field.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ task_form_renderer.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ team_member_selector.dart
â”‚   â”‚   â”‚   â””â”€â”€ create_task_page.dart
â”‚   â”‚   â”œâ”€â”€ view_assigned_tasks_page/
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ assigned_task_view_model.dart
â”‚   â”‚   â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_card.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_list.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ assigned_task_workspace.dart
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ lead_badge.dart
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ task_details_panel.dart
â”‚   â”‚   â”‚   â””â”€â”€ view_assigned_tasks_page.dart
â”‚   â”‚   â”œâ”€â”€ complete_task_page.dart
â”‚   â”‚   â””â”€â”€ view_all_tasks_page.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ task_side_panel.dart
â”‚   â”œâ”€â”€ task_tabs_manifest.dart
â”‚   â””â”€â”€ task_workspace.dart
â”œâ”€â”€ workspace/
â”‚   â”œâ”€â”€ mixins/
â”‚   â”‚   â””â”€â”€ shell_performance_mixin.dart
â”‚   â”œâ”€â”€ widgets/
â”‚   â”‚   â””â”€â”€ fps_counter.dart
â”‚   â”œâ”€â”€ loading_screen.dart
â”‚   â”œâ”€â”€ universal_top_bar.dart
â”‚   â”œâ”€â”€ workspace_controller.dart
â”‚   â”œâ”€â”€ workspace_ids.dart
â”‚   â”œâ”€â”€ workspace_shell.dart
â”‚   â””â”€â”€ workspace_switcher.dart
â”œâ”€â”€ firebase_options.dart
â””â”€â”€ main.dart


================================================================================

// File: lib\firebase_options.dart
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyCtuGo0WIcuVltvmttchCt-StQDPvXtV80',
    appId: '1:272745497278:web:5e70e948a3b71cda7794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    authDomain: 'wall-d-fcc76.firebaseapp.com',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyAW4qdIw0JxmgZJzo9lWLKP62N4i-_9Eqc',
    appId: '1:272745497278:android:538512854c58fbab7794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCoSa3laqnShMxxORF_hQq7GvYO0gb3caI',
    appId: '1:272745497278:ios:635ef9197be82e587794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
    iosClientId: '272745497278-i1l9q3r1mi6e0vc1ggtgshlqn7mjcjlj.apps.googleusercontent.com',
    iosBundleId: 'com.example.walldFlutter',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCoSa3laqnShMxxORF_hQq7GvYO0gb3caI',
    appId: '1:272745497278:ios:635ef9197be82e587794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
    iosClientId: '272745497278-i1l9q3r1mi6e0vc1ggtgshlqn7mjcjlj.apps.googleusercontent.com',
    iosBundleId: 'com.example.walldFlutter',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyCtuGo0WIcuVltvmttchCt-StQDPvXtV80',
    appId: '1:272745497278:web:a251ae5cafedf1077794ef',
    messagingSenderId: '272745497278',
    projectId: 'wall-d-fcc76',
    authDomain: 'wall-d-fcc76.firebaseapp.com',
    databaseURL: 'https://wall-d-fcc76-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'wall-d-fcc76.firebasestorage.app',
  );
}

================================================================================

// File: lib\main.dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:walld_flutter/Developer/developer_dashboard_screen.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';
import 'package:walld_flutter/firebase_options.dart';
import 'package:walld_flutter/workspace/loading_screen.dart';
import 'package:walld_flutter/workspace/workspace_controller.dart';
import 'package:walld_flutter/workspace/workspace_shell.dart';
import 'package:window_manager/window_manager.dart';
import 'dart:io' show Platform;


Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // STEP 1: Defer first frame until heavy init is done
  final binding = WidgetsBinding.instance;
  binding.deferFirstFrame();

  try {
    // Initialize Firebase
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );

    // STEP 2: Pre-load wallpaper service
    await WallpaperService.instance.loadSettings();
    debugPrint('âœ… WallpaperService loaded before first frame');

    // STEP 3: Setup desktop window properties
    if (Platform.isWindows || Platform.isMacOS || Platform.isLinux) {
      await _setupDesktopWindow();
    }
  } catch (e) {
    debugPrint('âŒ Error during pre-initialization: $e');
  }

  // STEP 4: Allow first frame and run app
  binding.allowFirstFrame();
  runApp(const WallDApp());
}

/// Setup desktop window properties (Windows/macOS/Linux)
Future<void> _setupDesktopWindow() async {
  try {
    await windowManager.ensureInitialized();

    const windowOptions = WindowOptions(
      backgroundColor: Colors.black,
      titleBarStyle: TitleBarStyle.hidden,
      skipTaskbar: false,
    );

    await windowManager.waitUntilReadyToShow(windowOptions, () async {
      await windowManager.show();
      await windowManager.setFullScreen(false);
      await windowManager.maximize();

      // Removed: setMovable (not supported)
      await windowManager.setResizable(false);
      await windowManager.setMinimizable(false);
      await windowManager.setClosable(false);

      try {
        await windowManager.setAlwaysOnBottom(true);
      } catch (e) {
        debugPrint('âš ï¸ Could not set window to bottom: $e');
      }
    });

    debugPrint('âœ… Desktop window configured');
  } catch (e) {
    debugPrint('âŒ Desktop window setup failed: $e');
  }
}

class WallDApp extends StatefulWidget {
  const WallDApp({super.key});

  @override
  State<WallDApp> createState() => WallDAppState();
}

class WallDAppState extends State<WallDApp> {
  final WorkspaceController workspaceController = WorkspaceController();
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    debugPrint('WallDApp - initState');
  }

  @override
  void dispose() {
    debugPrint('WallDApp - dispose');
    workspaceController.dispose();
    super.dispose();
  }

  void onLoadingComplete() {
    debugPrint('WallDApp - onLoadingComplete called');
    debugPrint('Loading complete - transitioning to workspace');
    if (mounted) {
      setState(() {
        isLoading = false;
      });
      debugPrint('WallDApp - isLoading set to false - showing WorkspaceShell');
    } else {
      debugPrint('WallDApp - Widget not mounted, skipping setState');
    }
  }

  @override
  Widget build(BuildContext context) {
    debugPrint('WallDApp - build - isLoading:$isLoading');
    return MaterialApp(
      title: 'Wall-D',
      debugShowCheckedModeBanner: false,
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: const Color(0xFF05040A),
      ),
      home: isLoading 
        ? LoadingScreen(onLoadingComplete: onLoadingComplete)
        : WorkspaceShell(workspaceController: workspaceController),
      //home: const DeveloperDashboardScreen(),
    );
  }
}



================================================================================

// File: lib\chat\models\chat_channel.dart
// lib/chat/models/chat_channel.dart

/// Defines the type of chat channel
enum ChatChannel {
  /// Chat among all assigned team members
  teamMembers,

  /// Chat between lead member and assigned_by user
  assignedBy,
}

extension ChatChannelExt on ChatChannel {
  String get firestoreCollection {
    switch (this) {
      case ChatChannel.teamMembers:
        return 'team_members_chat';
      case ChatChannel.assignedBy:
        return 'assigned_by_chat';
    }
  }

  String get displayName {
    switch (this) {
      case ChatChannel.teamMembers:
        return 'Team Chat';
      case ChatChannel.assignedBy:
        return 'Manager Chat';
    }
  }
}

================================================================================

// File: lib\chat\models\chat_conversation.dart
// lib/chat/models/chat_conversation.dart

/// Metadata about a conversation (task context)
class ChatConversation {
  final String conversationId; // typically the task docId
  final String taskTitle;
  final String assignedByUid;
  final List<String> assignedToUids;
  final String? leadMemberUid;
  final String? groupName;
  final DateTime? dueDate;

  ChatConversation({
    required this.conversationId,
    required this.taskTitle,
    required this.assignedByUid,
    required this.assignedToUids,
    this.leadMemberUid,
    this.groupName,
    this.dueDate,
  });

  /// Helper: check if a user can send to assignedBy channel
  bool canSendToAssignedByChannel(String currentUserUid) {
    return currentUserUid == leadMemberUid || currentUserUid == assignedByUid;
  }

  /// Helper: check if a user can send to team members channel
  bool canSendToTeamChannel(String currentUserUid) {
    return assignedToUids.contains(currentUserUid);
  }
}

================================================================================

// File: lib\chat\models\chat_message.dart
// lib/chat/models/chat_message.dart

import 'package:cloud_firestore/cloud_firestore.dart';

enum MessageType {
  text,
  file,
  progress,
}

class ChatMessage {
  final String id;
  final String senderId;
  final String senderRole; // "member", "lead", "manager"
  final MessageType type;
  final String? text;
  final String? fileUrl;
  final String? fileType; // "image", "pdf", "excel", etc.
  final DateTime createdAt;

  ChatMessage({
    required this.id,
    required this.senderId,
    required this.senderRole,
    required this.type,
    this.text,
    this.fileUrl,
    this.fileType,
    required this.createdAt,
  });

  factory ChatMessage.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    final typeStr = (data['type'] ?? 'text') as String;
    final type = MessageType.values.firstWhere(
      (t) => t.name == typeStr,
      orElse: () => MessageType.text,
    );

    final timestamp = data['created_at'];
    DateTime createdAt;
    if (timestamp is Timestamp) {
      createdAt = timestamp.toDate();
    } else if (timestamp is String) {
      createdAt = DateTime.tryParse(timestamp) ?? DateTime.now();
    } else {
      createdAt = DateTime.now();
    }

    return ChatMessage(
      id: doc.id,
      senderId: data['sender_id'] as String? ?? '',
      senderRole: data['sender_role'] as String? ?? 'member',
      type: type,
      text: data['text'] as String?,
      fileUrl: data['file_url'] as String?,
      fileType: data['file_type'] as String?,
      createdAt: createdAt,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'sender_id': senderId,
      'sender_role': senderRole,
      'type': type.name,
      if (text != null) 'text': text,
      if (fileUrl != null) 'file_url': fileUrl,
      if (fileType != null) 'file_type': fileType,
      'created_at': Timestamp.fromDate(createdAt),
    };
  }
}

================================================================================

// File: lib\chat\repositories\chat_repository.dart
// lib/chat/repositories/chat_repository.dart

import 'package:cloud_firestore/cloud_firestore.dart';

import '../models/chat_channel.dart';
import '../models/chat_message.dart';

class ChatRepository {
  final String tenantId;
  final FirebaseFirestore _db;

  ChatRepository({
    required this.tenantId,
    FirebaseFirestore? firestore,
  }) : _db = firestore ?? FirebaseFirestore.instance;

  /// Base path: /tenants/{tenantId}/CHATS/{conversationId}/{channelCollection}
  CollectionReference<Map<String, dynamic>> _channelCollection(
    String conversationId,
    ChatChannel channel,
  ) {
    return _db
        .collection('tenants')
        .doc(tenantId)
        .collection('CHATS')
        .doc(conversationId)
        .collection(channel.firestoreCollection);
  }

  /// Stream messages in a channel ordered by created_at
  Stream<List<ChatMessage>> streamMessages({
    required String conversationId,
    required ChatChannel channel,
  }) {
    return _channelCollection(conversationId, channel)
        .orderBy('created_at', descending: false)
        .snapshots()
        .map(
          (snap) => snap.docs
              .map((doc) => ChatMessage.fromFirestore(doc))
              .toList(),
        );
  }

  /// Send a text message
  Future<void> sendTextMessage({
    required String conversationId,
    required ChatChannel channel,
    required String senderId,
    required String senderRole,
    required String text,
    MessageType type = MessageType.text,
  }) async {
    final message = ChatMessage(
      id: '',
      senderId: senderId,
      senderRole: senderRole,
      type: type,
      text: text,
      createdAt: DateTime.now(),
    );

    await _channelCollection(conversationId, channel).add(
      message.toFirestore(),
    );
  }

  /// Send a file or progress message with optional text
  Future<void> sendFileMessage({
    required String conversationId,
    required ChatChannel channel,
    required String senderId,
    required String senderRole,
    required String fileUrl,
    required String fileType,
    String? text,
    MessageType type = MessageType.file,
  }) async {
    final message = ChatMessage(
      id: '',
      senderId: senderId,
      senderRole: senderRole,
      type: type,
      text: text,
      fileUrl: fileUrl,
      fileType: fileType,
      createdAt: DateTime.now(),
    );

    await _channelCollection(conversationId, channel).add(
      message.toFirestore(),
    );
  }
}

================================================================================

// File: lib\chat\widgets\chat_input_bar.dart
// lib/chat/widgets/chat_input_bar.dart

import 'package:flutter/material.dart';

class ChatInputBar extends StatefulWidget {
  final Future<void> Function(String text) onSend;
  final bool enabled;
  final String hintText;

  const ChatInputBar({
    super.key,
    required this.onSend,
    this.enabled = true,
    this.hintText = 'Type a message',
  });

  @override
  State<ChatInputBar> createState() => _ChatInputBarState();
}

class _ChatInputBarState extends State<ChatInputBar> {
  final TextEditingController _controller = TextEditingController();
  bool _sending = false;

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  Future<void> _handleSend() async {
    final text = _controller.text.trim();
    if (text.isEmpty || _sending || !widget.enabled) return;

    setState(() => _sending = true);
    try {
      await widget.onSend(text);
      _controller.clear();
    } finally {
      if (mounted) setState(() => _sending = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: TextField(
            controller: _controller,
            enabled: widget.enabled && !_sending,
            style: const TextStyle(color: Colors.white),
            minLines: 1,
            maxLines: 4,
            decoration: InputDecoration(
              hintText: widget.hintText,
              hintStyle: const TextStyle(color: Colors.white38),
              filled: true,
              fillColor: Colors.white.withOpacity(0.06),
              contentPadding:
                  const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(18),
                borderSide: const BorderSide(color: Colors.white24),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(18),
                borderSide: const BorderSide(color: Colors.white24),
              ),
              focusedBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(18),
                borderSide:
                    const BorderSide(color: Colors.cyanAccent, width: 1.5),
              ),
            ),
            onSubmitted: (_) => _handleSend(),
          ),
        ),
        const SizedBox(width: 8),
        IconButton(
          onPressed: widget.enabled && !_sending ? _handleSend : null,
          icon: _sending
              ? const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
                  ),
                )
              : const Icon(Icons.send_rounded, color: Colors.cyanAccent),
          tooltip: 'Send',
        ),
      ],
    );
  }
}

================================================================================

// File: lib\chat\widgets\chat_shell.dart
// lib/chat/widgets/chat_shell.dart

import 'package:flutter/material.dart';

import '../models/chat_channel.dart';
import '../models/chat_conversation.dart';
import '../models/chat_message.dart';
import '../repositories/chat_repository.dart';
import 'chat_input_bar.dart';
import 'message_list.dart';

class ChatShell extends StatelessWidget {
  final String tenantId;
  final ChatConversation conversation;
  final ChatChannel channel;
  final String currentUserId;

  const ChatShell({
    super.key,
    required this.tenantId,
    required this.conversation,
    required this.channel,
    required this.currentUserId,
  });

  bool get _canSend {
    switch (channel) {
      case ChatChannel.teamMembers:
        return conversation.canSendToTeamChannel(currentUserId);
      case ChatChannel.assignedBy:
        return conversation.canSendToAssignedByChannel(currentUserId);
    }
  }

  String get _hint {
    switch (channel) {
      case ChatChannel.teamMembers:
        return 'Message team members';
      case ChatChannel.assignedBy:
        return 'Ask doubt / share progress with manager';
    }
  }

  @override
  Widget build(BuildContext context) {
    final repo = ChatRepository(tenantId: tenantId);

    return Column(
      children: [
        // header
        Padding(
          padding: const EdgeInsets.only(bottom: 8),
          child: Row(
            children: [
              Text(
                channel.displayName,
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 13,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const SizedBox(width: 8),
              if (!_canSend)
                const Text(
                  '(read only)',
                  style: TextStyle(
                    color: Colors.white38,
                    fontSize: 10,
                    fontStyle: FontStyle.italic,
                  ),
                ),
            ],
          ),
        ),

        // messages
        Expanded(
          child: StreamBuilder<List<ChatMessage>>(
            stream: repo.streamMessages(
              conversationId: conversation.conversationId,
              channel: channel,
            ),
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.waiting) {
                return const Center(
                  child: CircularProgressIndicator(
                    valueColor:
                        AlwaysStoppedAnimation<Color>(Colors.cyanAccent),
                    strokeWidth: 2,
                  ),
                );
              }

              final msgs = snapshot.data ?? const <ChatMessage>[];

              if (msgs.isEmpty) {
                return const Center(
                  child: Text(
                    'No messages yet.\nStart the conversation.',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.white38, fontSize: 11),
                  ),
                );
              }

              return MessageList(
                messages: msgs,
                currentUserId: currentUserId,
              );
            },
          ),
        ),

        const SizedBox(height: 8),

        ChatInputBar(
          enabled: _canSend,
          hintText: _hint,
          onSend: (text) => repo.sendTextMessage(
            conversationId: conversation.conversationId,
            channel: channel,
            senderId: currentUserId,
            senderRole: _roleForCurrentUser(),
            text: text,
          ),
        ),
      ],
    );
  }

  String _roleForCurrentUser() {
    if (currentUserId == conversation.assignedByUid) return 'manager';
    if (currentUserId == conversation.leadMemberUid) return 'lead';
    return 'member';
  }
}

================================================================================

// File: lib\chat\widgets\message_bubble.dart
// lib/chat/widgets/message_bubble.dart

import 'package:flutter/material.dart';

import '../models/chat_message.dart';

class MessageBubble extends StatelessWidget {
  final ChatMessage message;
  final bool isMine;

  const MessageBubble({
    super.key,
    required this.message,
    required this.isMine,
  });

  @override
  Widget build(BuildContext context) {
    final bgColor = isMine
        ? Colors.cyanAccent.withOpacity(0.18)
        : Colors.white.withOpacity(0.06);
    final borderColor =
        isMine ? Colors.cyanAccent.withOpacity(0.7) : Colors.white12;
    final align =
        isMine ? CrossAxisAlignment.end : CrossAxisAlignment.start;

    return Align(
      alignment: isMine ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 4),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: borderColor, width: 0.8),
        ),
        child: Column(
          crossAxisAlignment: align,
          mainAxisSize: MainAxisSize.min,
          children: [
            if (message.type == MessageType.progress)
              Padding(
                padding: const EdgeInsets.only(bottom: 2),
                child: Text(
                  'Progress update',
                  style: TextStyle(
                    color: Colors.greenAccent.shade200,
                    fontSize: 10,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            if (message.fileUrl != null)
              Padding(
                padding: const EdgeInsets.only(bottom: 4),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(Icons.attach_file,
                        size: 14, color: Colors.white70),
                    const SizedBox(width: 4),
                    Text(
                      message.fileType ?? 'file',
                      style: const TextStyle(
                        color: Colors.white70,
                        fontSize: 11,
                      ),
                    ),
                  ],
                ),
              ),
            if (message.text != null && message.text!.isNotEmpty)
              Text(
                message.text!,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                ),
              ),
            const SizedBox(height: 2),
            Text(
              _formatTime(message.createdAt),
              style: const TextStyle(
                color: Colors.white54,
                fontSize: 9,
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTime(DateTime dt) {
    final h = dt.hour.toString().padLeft(2, '0');
    final m = dt.minute.toString().padLeft(2, '0');
    return '$h:$m';
  }
}

================================================================================

// File: lib\chat\widgets\message_list.dart
// lib/chat/widgets/message_list.dart

import 'package:flutter/material.dart';

import '../models/chat_message.dart';
import 'message_bubble.dart';

class MessageList extends StatelessWidget {
  final List<ChatMessage> messages;
  final String currentUserId;

  const MessageList({
    super.key,
    required this.messages,
    required this.currentUserId,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      reverse: false,
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
      itemCount: messages.length,
      itemBuilder: (context, index) {
        final msg = messages[index];
        final isMine = msg.senderId == currentUserId;

        return MessageBubble(
          message: msg,
          isMine: isMine,
        );
      },
    );
  }
}

================================================================================

// File: lib\core\app_colors.dart
import 'package:flutter/material.dart';

class AppColors {
  // Greys
  static const grey300 = Color(0xFFE0E0E0);
  static const grey400 = Color(0xFFBDBDBD);
  static const grey500 = Color(0xFF9E9E9E);
  static const grey600 = Color(0xFF757575);
  static const grey700 = Color(0xFF616161);
  static const grey800 = Color(0xFF424242);
  static const grey900 = Color(0xFF212121);
  
  // Custom theme colors
  static const darkBg = Color(0xFF05040A);
  static const cardBg = Color(0x6611111C);
  static const glassWhite = Color(0x22FFFFFF);
}

================================================================================

// File: lib\core\glass_container.dart
import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// import 'performancestate.dart'; // âŒ REMOVED - no more performance overrides

// Controls whether this widget applies per-widget BackdropFilter blur
enum GlassBlurMode { none, perWidget, auto }

// High-level quality selection (user-controlled only)
enum GlassQualityMode { auto, high, medium, low, ultraLow }

class GlassContainer extends StatelessWidget {
  final double blur;
  final double opacity;
  final Color tint;
  final BorderRadius borderRadius;
  final EdgeInsetsGeometry padding;
  final Widget child;
  final double borderOpacity;
  final double borderWidth;
  final List<BoxShadow> boxShadow;

  // Controls blur strategy
  final GlassBlurMode blurMode;
  // Controls quality strategy (user choice only)
  final GlassQualityMode qualityMode;
  // Hint from callers (dragging/resizing/scrolling/animating)
  final bool isInteracting;
  // Allow callers to disable shadows completely
  final bool disableShadows;

  const GlassContainer({
    super.key,
    required this.blur,
    required this.opacity,
    required this.tint,
    required this.borderRadius,
    required this.child,
    this.padding = EdgeInsets.zero,
    this.borderOpacity = 0.18,
    this.borderWidth = 1,
    this.boxShadow = const [
      BoxShadow(
        color: Color(0x40000000),
        blurRadius: 18,
        offset: Offset(0, 10),
      ),
    ],
    this.blurMode = GlassBlurMode.auto,
    this.qualityMode = GlassQualityMode.auto,
    this.isInteracting = false,
    this.disableShadows = false,
  });

  // âœ… FIXED: Always use user's exact settings - NO performance overrides
  GlassQualityMode get resolvedQualityMode {
    // User explicitly chose a quality level
    if (qualityMode != GlassQualityMode.auto) return qualityMode;
    
    // Always use high quality unless user specifically chose lower
    return GlassQualityMode.high;
  }

  // âœ… FIXED: Use EXACT user blur value - no clamping/reduction
  double get effectiveBlur => blur.clamp(0.0, 40.0);

  // âœ… FIXED: Use EXACT user opacity value - no clamping/reduction  
  double get effectiveOpacity => opacity.clamp(0.0, 1.0);

  // âœ… FIXED: Always use full shadows - no performance reduction
  List<BoxShadow> get effectiveShadows {
    if (disableShadows) return const [];
    return boxShadow;
  }

  // âœ… FIXED: Simplified backdrop filter logic - respect user blurMode only
  bool get shouldUseBackdropFilter {
    if (effectiveBlur == 0) return false;
    
    switch (blurMode) {
      case GlassBlurMode.none:
        return false;
      case GlassBlurMode.perWidget:
        return true;
      case GlassBlurMode.auto:
        // Always use backdrop filter if user set blur > 0
        return true;
    }
  }

  @override
  Widget build(BuildContext context) {
    final blurSigma = effectiveBlur.clamp(0.0, 30.0);
    final a = effectiveOpacity;
    
    // Tint fill
    final fill = tint.withOpacity(a);
    
    // Full border (no performance reduction)
    final effBorderOpacity = borderOpacity.clamp(0.0, 1.0);
    final effBorderWidth = borderWidth;

    final decoration = BoxDecoration(
      color: fill,
      borderRadius: borderRadius,
      border: Border.all(
        color: Colors.white.withOpacity(effBorderOpacity),
        width: effBorderWidth,
      ),
      boxShadow: effectiveShadows,
    );

    final body = Container(
      decoration: decoration,
      padding: padding,
      child: child,
    );

    // Fast path: no BackdropFilter
    if (!shouldUseBackdropFilter) {
      return body;
    }

    // High quality: per-widget BackdropFilter
    return ClipRRect(
      borderRadius: borderRadius,
      child: BackdropFilter(
        filter: ImageFilter.blur(
          sigmaX: blurSigma,
          sigmaY: blurSigma,
        ),
        child: body,
      ),
    );
  }
}

================================================================================

// File: lib\core\performance_state.dart
/// Shared singleton to track app warm-up and performance state
class PerformanceState {
  PerformanceState._();
  static final PerformanceState instance = PerformanceState._();

  /// Set to true when WorkspaceShell has warmed up and is stable
  bool isWarmupStable = false;
  
  /// Optional: track current FPS for logging
  double? currentFps;
  
  /// Reset state (e.g., on hot reload)
  void reset() {
    isWarmupStable = false;
    currentFps = null;
  }
}

================================================================================

// File: lib\core\permissions_cache.dart
import 'package:flutter/material.dart';

class PermissionsCache extends ChangeNotifier {
  static final PermissionsCache instance = PermissionsCache._();
  PermissionsCache._();

  Set<String>? _cachedWidgetIds;
  String? _cachedUserId;
  DateTime? _cacheTime;

  static const _cacheValidDuration = Duration(minutes: 5);

  bool get hasCache => _cachedWidgetIds != null && _isValid;

  bool get _isValid {
    if (_cacheTime == null) return false;
    return DateTime.now().difference(_cacheTime!) < _cacheValidDuration;
  }

  /// Return cached permissions for [userId] if they are still valid,
  /// otherwise null.
  Set<String>? getCachedPermissions(String userId) {
    if (_cachedUserId != userId) return null;
    if (!_isValid) return null;
    return _cachedWidgetIds;
  }

  /// Store permissions for [userId] in memory cache for a short duration.
  void setCachedPermissions(String userId, Set<String> widgetIds) {
    _cachedUserId = userId;
    _cachedWidgetIds = widgetIds;
    _cacheTime = DateTime.now();

    debugPrint(
      '[PermissionsCache] âœ… Cached ${widgetIds.length} permissions for user $userId',
    );
    notifyListeners();
  }

  void clearCache() {
    _cachedWidgetIds = null;
    _cachedUserId = null;
    _cacheTime = null;
    debugPrint('[PermissionsCache] ğŸ—‘ï¸ Cache cleared');
    notifyListeners();
  }
}

================================================================================

// File: lib\core\wallpaper_service.dart
import 'dart:async';
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

class WallpaperService extends ChangeNotifier {
  static final WallpaperService instance = WallpaperService._();
  WallpaperService._();

  static const _prefsWallpaperKey = 'wallpaper_path';
  static const prefsGlobalOpacityKey = 'global_widget_opacity';
  static const prefsGlobalBlurKey = 'global_widget_blur';

  String? wallpaperPath;
  double globalGlassOpacity = 0.12;
  double globalGlassBlur = 16.0;
  bool isLoaded = false;

  ui.Image? _cachedDecodedImage;
  ImageProvider? cachedImageProvider;
  DateTime _lastNotify = DateTime.fromMillisecondsSinceEpoch(0);

  Future<void> loadSettings() async {
    if (isLoaded) return;

    final prefs = await SharedPreferences.getInstance();
    wallpaperPath = prefs.getString(_prefsWallpaperKey);
    globalGlassOpacity = prefs.getDouble(prefsGlobalOpacityKey) ?? 0.12;
    globalGlassBlur = prefs.getDouble(prefsGlobalBlurKey) ?? 16.0;

    debugPrint('âœ… [GLASS] Loaded from cache: blur=$globalGlassBlur, opacity=$globalGlassOpacity');

    if (wallpaperPath != null && File(wallpaperPath!).existsSync()) {
      await _precacheWallpaper();
    } else {
      wallpaperPath = null;
    }

    isLoaded = true;
    _notifyNow();
  }

  Future<void> saveSettings() async {
    final prefs = await SharedPreferences.getInstance();
    if (wallpaperPath != null) {
      await prefs.setString(_prefsWallpaperKey, wallpaperPath!);
    } else {
      await prefs.remove(_prefsWallpaperKey);
    }
    await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);
    await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);
    debugPrint('ğŸ’¾ [GLASS] Full settings saved: blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    _notifyNow();
  }

  Future<void> pickWallpaper() async {
    final result = await FilePicker.platform.pickFiles(
      type: FileType.image,
      allowMultiple: false,
      withData: false,
    );

    final pickedPath = result?.files.single.path;
    if (pickedPath == null) return;

    final normalizedPath = await _copyAndNormalizeWallpaper(pickedPath);
    wallpaperPath = normalizedPath;
    await _precacheWallpaper();
    await saveSettings();
  }

  Future<void> resetWallpaper() async {
    wallpaperPath = null;
    cachedImageProvider = null;
    _cachedDecodedImage = null;
    await saveSettings();
  }

  // In lib/core/wallpaper_service.dart - Replace the setters:

void setGlassBlur(double blur) {
  final oldBlur = globalGlassBlur;
  final clampedBlur = blur.clamp(0.0, 40.0);
  
  // ğŸ›¡ï¸ BLOCK performance overrides that reset to 0.0
  if (clampedBlur == 0.0 && oldBlur > 5.0) {
    debugPrint('ğŸ›¡ï¸ [GLASS PROTECTED] Blocked blur=0.0 â†’ keeping $oldBlur');
    _throttledNotify();
    return; // BLOCK IT!
  }
  
  globalGlassBlur = clampedBlur;
  debugPrint('ğŸ”µ [GLASS] Blur â†’ $globalGlassBlur');
  _throttledNotify();
  unawaited(_saveGlassSettingsOnly());
}

void setGlassOpacity(double opacity) {
  final oldOpacity = globalGlassOpacity;
  final clampedOpacity = opacity.clamp(0.02, 0.40);
  
  // ğŸ›¡ï¸ BLOCK performance overrides that reset to 0.04
  if (clampedOpacity <= 0.05 && oldOpacity > 0.10) {
    debugPrint('ğŸ›¡ï¸ [GLASS PROTECTED] Blocked opacity=$clampedOpacity â†’ keeping $oldOpacity');
    _throttledNotify();
    return; // BLOCK IT!
  }
  
  globalGlassOpacity = clampedOpacity;
  debugPrint('ğŸ”µ [GLASS] Opacity â†’ $globalGlassOpacity');
  _throttledNotify();
  unawaited(_saveGlassSettingsOnly());
}



  // âœ… NEW: Fast save (only glass settings, not wallpaper)
  Future<void> _saveGlassSettingsOnly() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);
      await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);
      debugPrint('âœ… [GLASS] Saved to cache: blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    } catch (e) {
      debugPrint('âŒ [GLASS] Save failed: $e');
    }
  }

  void _throttledNotify() {
    final now = DateTime.now();
    if (now.difference(_lastNotify).inMilliseconds < 16) return;
    _lastNotify = now;
    notifyListeners();
  }

  void _notifyNow() {
    _lastNotify = DateTime.now();
    notifyListeners();
  }

  Future<void> _precacheWallpaper() async {
    final path = wallpaperPath;
    if (path == null) return;

    final file = File(path);
    if (!file.existsSync()) {
      wallpaperPath = null;
      cachedImageProvider = null;
      _cachedDecodedImage = null;
      return;
    }

    try {
      cachedImageProvider = FileImage(file);
      final imageStream = cachedImageProvider!.resolve(const ImageConfiguration());
      final completer = Completer<void>();
      late final ImageStreamListener listener;

      listener = ImageStreamListener(
        (ImageInfo info, bool _) {
          _cachedDecodedImage = info.image;
          imageStream.removeListener(listener);
          completer.complete();
        },
        onError: (_, __) {
          imageStream.removeListener(listener);
          cachedImageProvider = null;
          _cachedDecodedImage = null;
          completer.complete();
        },
      );

      imageStream.addListener(listener);
      await completer.future;
    } catch (_) {
      cachedImageProvider = null;
      _cachedDecodedImage = null;
    }
  }

  Future<String> _copyAndNormalizeWallpaper(
    String pickedPath, [
    int maxDimension = 2560,
  ]) async {
    final appDir = await getApplicationSupportDirectory();
    final wpDir = Directory(p.join(appDir.path, 'wallpapers'));
    if (!await wpDir.exists()) {
      await wpDir.create(recursive: true);
    }

    final cachedPath = p.join(wpDir.path, 'current_wallpaper.png');
    final srcBytes = await File(pickedPath).readAsBytes();

    try {
      final codec = await ui.instantiateImageCodec(srcBytes);
      final frame = await codec.getNextFrame();
      final img = frame.image;

      final srcW = img.width;
      final srcH = img.height;

      final scale = math.min(
        1.0,
        maxDimension / math.max(srcW.toDouble(), srcH.toDouble()),
      );
      final targetW = (srcW * scale).round();
      final targetH = (srcH * scale).round();

      ui.Image outImage = img;

      if (scale < 1.0) {
        codec.dispose();
        final codec2 = await ui.instantiateImageCodec(
          srcBytes,
          targetWidth: targetW,
          targetHeight: targetH,
        );
        final frame2 = await codec2.getNextFrame();
        outImage = frame2.image;
        codec2.dispose();
      } else {
        codec.dispose();
      }

      final byteData = await outImage.toByteData(format: ui.ImageByteFormat.png);
      final pngBytes = byteData?.buffer.asUint8List();

      if (pngBytes == null) {
        await File(pickedPath).copy(cachedPath);
        return cachedPath;
      }

      await File(cachedPath).writeAsBytes(pngBytes, flush: true);

      try {
        outImage.dispose();
      } catch (_) {}

      return cachedPath;
    } catch (_) {
      final ext = p.extension(pickedPath).isNotEmpty ? p.extension(pickedPath) : '.jpg';
      final fallbackPath = p.join(wpDir.path, 'current_wallpaper$ext');
      await File(pickedPath).copy(fallbackPath);
      return fallbackPath;
    }
  }

  BoxDecoration get backgroundDecoration {
    if (cachedImageProvider != null && _cachedDecodedImage != null) {
      return BoxDecoration(
        image: DecorationImage(
          image: cachedImageProvider!,
          fit: BoxFit.cover,
        ),
      );
    }

    return const BoxDecoration(
      gradient: LinearGradient(
        begin: Alignment.topCenter,
        end: Alignment.bottomCenter,
        colors: [Color(0xFF050716), Color(0xFF020308)],
      ),
    );
  }

  // Legacy method (kept for backward compatibility)
  Future<void> updateGlass({
    required double blur,
    required double opacity,
  }) async {
    globalGlassBlur = blur.clamp(0.0, 30.0);
    globalGlassOpacity = opacity.clamp(0.0, 1.0);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(prefsGlobalBlurKey, globalGlassBlur);
    await prefs.setDouble(prefsGlobalOpacityKey, globalGlassOpacity);
    debugPrint('ğŸ’¾ [GLASS] Legacy updateGlass() saved: blur=$globalGlassBlur, opacity=$globalGlassOpacity');
    notifyListeners();
  }
}

================================================================================

// File: lib\Developer\developer_dashboard_screen.dart
import 'package:flutter/material.dart';
import 'Metadata/metadata_panel.dart';
import 'Hierarchy/hierarchy_panel.dart';
import 'DynamicForms/dynamic_forms_panel.dart';
import 'UserDatabase/userdatabasepanel.dart'; // NEW IMPORT

class DeveloperDashboardScreen extends StatefulWidget {
  const DeveloperDashboardScreen({super.key});

  @override
  State<DeveloperDashboardScreen> createState() =>
      _DeveloperDashboardScreenState();  // ADD () here
}

class _DeveloperDashboardScreenState extends State<DeveloperDashboardScreen> {
  // 0: User Database, 1: Metadata, 2: Hierarchy, 3: Dynamic Forms
  int selectedIndex = 0; // Starts at User Database

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Row(
        children: [
          // LEFT NAVIGATION
          Container(
            width: 260,
            color: const Color(0xFF0B0B10),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 32),
                const ListTile(
                  leading: Icon(Icons.code, color: Colors.cyan),
                  title: Text(
                    'Developer Console',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                const Divider(color: Colors.white24),
                
                // NAVIGATION ITEMS
                navItem(0, Icons.dns_rounded, 'User Database'), // CHANGED ICON
                navItem(1, Icons.storage_rounded, 'Metadata'),
                navItem(2, Icons.account_tree_rounded, 'Hierarchy'),
                navItem(3, Icons.dynamic_form_rounded, 'Dynamic Forms'),
                
                const Spacer(),
                const Padding(
                  padding: EdgeInsets.all(12.0),
                  child: Text(
                    'Tenant: default_tenant â€¢ Synced',
                    style: TextStyle(color: Colors.grey, fontSize: 12),
                  ),
                ),
              ],
            ),
          ),
          
          // MAIN CONTENT
          Expanded(
            child: Container(
              color: const Color(0xFF050509),
              padding: const EdgeInsets.all(24),
              child: buildSelectedPanel(),
            ),
          ),
        ],
      ),
    );
  }

  // PANEL BUILDER
  Widget buildSelectedPanel() {
    switch (selectedIndex) {
      case 0:
        return const UserDatabasePanel();
      case 1:
        return const MetadataPanel();
      case 2:
        return const HierarchyPanel();
      case 3:
        return const DynamicFormsPanel();
      default:
        return const UserDatabasePanel();
    }
  }

  // NAVIGATION ITEM
  Widget navItem(int index, IconData icon, String label) {
    final selected = selectedIndex == index;
    return ListTile(
      leading: Icon(
        icon,
        color: selected ? Colors.cyan : Colors.grey,
      ),
      title: Text(
        label,
        style: TextStyle(
          color: selected ? Colors.cyan : Colors.grey.shade300,
          fontWeight: selected ? FontWeight.bold : FontWeight.normal,
        ),
      ),
      selected: selected,
      selectedTileColor: const Color(0xFF1A1A25),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: () {
        setState(() {
          selectedIndex = index;
        });
      },
    );
  }
}

================================================================================

// File: lib\Developer\DynamicForms\dynamic_forms_panel.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import 'dynamic_forms_repository.dart';
import 'form_models.dart';

class DynamicFormsPanel extends StatefulWidget {
  const DynamicFormsPanel({super.key});

  @override
  State<DynamicFormsPanel> createState() => _DynamicFormsPanelState();
}

class _DynamicFormsPanelState extends State<DynamicFormsPanel> {
  // Line 11:
  static const String tenantId = 'default_tenant'; // Fixed


  final DynamicFormsRepository _repo = DynamicFormsRepository();

  final List<FormSchemaMeta> _forms = [];
  int _selectedIndex = 0;
  bool _loading = false;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  void _setStatus(String msg, {bool error = false}) {
    setState(() {
      _status = msg;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await _repo.loadForms(tenantId);
      setState(() {
        _forms
          ..clear()
          ..addAll(list);
        _selectedIndex = 0;
      });
      _setStatus('Loaded ${_forms.length} form(s)');
    } catch (e) {
      _setStatus('Failed to load forms: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final selectedForm = _forms.isEmpty ? null : _forms[_selectedIndex];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Dynamic Forms Engine â€“ Preview',
          style: TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Runtime renderer for formSchemas metadata (system + custom forms).',
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Row(
            children: [
              // LEFT: Form list
              SizedBox(
                width: 260,
                child: Card(
                  color: const Color(0xFF111118),
                  child: _forms.isEmpty
                      ? const Center(
                          child: Text(
                            'No forms yet.',
                            style: TextStyle(color: Colors.white70),
                          ),
                        )
                      : ListView.builder(
                          itemCount: _forms.length,
                          itemBuilder: (context, index) {
                            final f = _forms[index];
                            final selected = index == _selectedIndex;
                            return ListTile(
                              selected: selected,
                              selectedTileColor: const Color(0xFF1A1A25),
                              title: Text(
                                f.formId,
                                style: TextStyle(
                                  color: selected
                                      ? Colors.cyan
                                      : Colors.white,
                                  fontWeight: selected
                                      ? FontWeight.bold
                                      : FontWeight.normal,
                                ),
                              ),
                              subtitle: Text(
                                f.name,
                                style: const TextStyle(
                                    color: Colors.grey, fontSize: 12),
                              ),
                              onTap: () =>
                                  setState(() => _selectedIndex = index),
                            );
                          },
                        ),
                ),
              ),
              const SizedBox(width: 12),
              // RIGHT: Form preview
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: selectedForm == null
                        ? const Center(
                            child: Text(
                              'No form selected.',
                              style: TextStyle(color: Colors.white70),
                            ),
                          )
                        : _DynamicFormRenderer(
                            tenantId: tenantId,
                            form: selectedForm,
                            onSubmit: (payload) async {
                              // hook for real backend later
                              debugPrint(
                                  'Dynamic form "${selectedForm.formId}" submitted: $payload');
                            },
                          ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

/* ------------------------ Runtime form renderer ------------------------ */

class _DynamicFormRenderer extends StatefulWidget {
  final String tenantId;
  final FormSchemaMeta form;
  final Future<void> Function(Map<String, dynamic> values)? onSubmit;

  const _DynamicFormRenderer({
    required this.tenantId,
    required this.form,
    this.onSubmit,
  });

  @override
  State<_DynamicFormRenderer> createState() => _DynamicFormRendererState();
}

class _DynamicFormRendererState extends State<_DynamicFormRenderer> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, dynamic> _values = {};
  final Map<String, bool> _checkboxValues = {};
  final Map<String, String?> _dropdownValues = {};
  final Map<String, List<DropdownMenuItem<String>>> _dropdownItems = {};
  final Map<String, bool> _loadingDropdown = {};

  @override
  void initState() {
    super.initState();
    for (final field in widget.form.fields) {
      if (field.type == 'checkbox') {
        _checkboxValues[field.id] = false;
      } else if (field.type == 'dropdown') {
        _dropdownValues[field.id] =
            field.options.isNotEmpty ? field.options.first : null;
        _loadDropdownOptions(field);
      } else {
        _controllers[field.id] = TextEditingController();
      }
    }
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  Future<void> _loadDropdownOptions(FormFieldMeta field) async {
    if (field.dataSource != 'firestore' ||
        field.collection == null ||
        field.displayField == null ||
        field.valueField == null) {
      // static options
      _dropdownItems[field.id] = field.options
          .map((o) => DropdownMenuItem(value: o, child: Text(o)))
          .toList();
      setState(() {});
      return;
    }

    setState(() => _loadingDropdown[field.id] = true);
    try {
      final snap = await FirebaseFirestore.instance
          .collection('tenants/${widget.tenantId}/${field.collection}')
          .get();

      final items = snap.docs.map((doc) {
        final data = doc.data();
        final value = data[field.valueField] ?? doc.id;
        final label = data[field.displayField] ?? value.toString();
        return DropdownMenuItem<String>(
          value: value.toString(),
          child: Text(label.toString()),
        );
      }).toList();

      _dropdownItems[field.id] = items;
      if (_dropdownValues[field.id] == null && items.isNotEmpty) {
        _dropdownValues[field.id] = items.first.value;
      }
    } finally {
      setState(() => _loadingDropdown[field.id] = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (widget.form.fields.isEmpty) {
      return const Center(
        child: Text(
          'This form has no fields.',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    return Form(
      key: _formKey,
      child: ListView(
        children: [
          Text(
            widget.form.name,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          if (widget.form.description.isNotEmpty) ...[
            const SizedBox(height: 4),
            Text(
              widget.form.description,
              style: const TextStyle(color: Colors.white70),
            ),
          ],
          const SizedBox(height: 16),
          ...widget.form.fields.map(_buildField),
          const SizedBox(height: 24),
          SizedBox(
            height: 48,
            child: FilledButton(
              onPressed: _onSubmit,
              child: const Text('Submit (debug)'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildField(FormFieldMeta field) {
    switch (field.type) {
      case 'email':
      case 'text':
      case 'password':
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: TextFormField(
            controller: _controllers[field.id],
            obscureText: field.type == 'password',
            decoration: InputDecoration(
              labelText: field.label,
              floatingLabelBehavior: FloatingLabelBehavior.auto,
            ),
            validator: (v) => _runValidation(field, v?.trim() ?? ''),
          ),
        );
      case 'dropdown':
        final loading = _loadingDropdown[field.id] ?? false;
        final items = _dropdownItems[field.id] ??
            field.options
                .map(
                  (o) => DropdownMenuItem(
                    value: o,
                    child: Text(o),
                  ),
                )
                .toList();

        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: DropdownButtonFormField<String>(
            value: _dropdownValues[field.id],
            decoration: InputDecoration(
              labelText: field.label,
              floatingLabelBehavior: FloatingLabelBehavior.auto,
            ),
            dropdownColor: const Color(0xFF111118),
            items: items,
            validator: (v) {
              if (field.required && (v == null || v.isEmpty)) {
                return '${field.label} is required';
              }
              return null;
            },
            onChanged: loading
                ? null
                : (v) {
                    setState(() => _dropdownValues[field.id] = v);
                  },
          ),
        );
      case 'checkbox':
        return Padding(
          padding: const EdgeInsets.only(bottom: 8.0),
          child: CheckboxListTile(
            value: _checkboxValues[field.id] ?? false,
            onChanged: (v) {
              setState(() => _checkboxValues[field.id] = v ?? false);
            },
            title: Text(
              field.label,
              style: const TextStyle(color: Colors.white),
            ),
            controlAffinity: ListTileControlAffinity.leading,
            contentPadding: EdgeInsets.zero,
          ),
        );
      case 'date':
        return _DateField(
          label: field.label,
          required: field.required,
          onChanged: (value) => _values[field.id] = value,
        );
      default:
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: Text(
            'Unsupported field type: ${field.type}',
            style: const TextStyle(color: Colors.redAccent),
          ),
        );
    }
  }

  String? _runValidation(FormFieldMeta field, String value) {
    if (field.required && value.isEmpty) {
      return '${field.label} is required';
    }
    if (field.type == 'email' && value.isNotEmpty) {
      final ok =
          RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value);
      if (!ok) return 'Invalid email';
    }
    if (field.validation != null && value.isNotEmpty) {
      final re = RegExp(field.validation!);
      if (!re.hasMatch(value)) {
        return 'Invalid ${field.label}';
      }
    }
    return null;
  }

  Future<void> _onSubmit() async {
    if (!_formKey.currentState!.validate()) return;

    for (final entry in _controllers.entries) {
      _values[entry.key] = entry.value.text.trim();
    }
    for (final entry in _checkboxValues.entries) {
      _values[entry.key] = entry.value;
    }
    for (final entry in _dropdownValues.entries) {
      _values[entry.key] = entry.value;
    }

    if (widget.onSubmit != null) {
      await widget.onSubmit!(_values);
    } else {
      debugPrint(
          'Dynamic form "${widget.form.formId}" submitted: $_values');
      ScaffoldMessenger.of(_formKey.currentContext!).showSnackBar(
        const SnackBar(
          content:
              Text('Form submitted â€“ see debug console for payload'),
        ),
      );
    }
  }
}

/* ----------------------------- Helper widgets ---------------------------- */

class _DateField extends StatefulWidget {
  final String label;
  final bool required;
  final ValueChanged<DateTime?> onChanged;

  const _DateField({
    required this.label,
    required this.required,
    required this.onChanged,
  });

  @override
  State<_DateField> createState() => _DateFieldState();
}

class _DateFieldState extends State<_DateField> {
  DateTime? _value;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: InkWell(
        onTap: _pickDate,
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: widget.label,
          ),
          child: Text(
            _value == null
                ? 'Select date'
                : '${_value!.year}-${_value!.month.toString().padLeft(2, '0')}-${_value!.day.toString().padLeft(2, '0')}',
            style: const TextStyle(color: Colors.white),
          ),
        ),
      ),
    );
  }

  Future<void> _pickDate() async {
    final now = DateTime.now();
    final picked = await showDatePicker(
      context: context,
      initialDate: _value ?? now,
      firstDate: DateTime(now.year - 5),
      lastDate: DateTime(now.year + 5),
    );
    if (picked != null) {
      setState(() => _value = picked);
      widget.onChanged(picked);
    }
  }
}

================================================================================

// File: lib\Developer\DynamicForms\dynamic_forms_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';

import 'form_models.dart';

class DynamicFormsRepository {
  final FirebaseFirestore _db;

  DynamicFormsRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;

  Future<List<FormSchemaMeta>> loadForms(String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .get();

    final List<FormSchemaMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final forms =
          (data['forms'] ?? <String, dynamic>{}) as Map<String, dynamic>;

      for (final entry in forms.entries) {
        final m = entry.value as Map<String, dynamic>;
        result.add(FormSchemaMeta.fromFirestore(entry.key, m));
      }
    }

    if (result.isEmpty) {
      result.add(FormSchemaMeta.defaultUserRegistration());
    }

    return result;
  }
}

================================================================================

// File: lib\Developer\DynamicForms\form_models.dart
import 'dart:convert';

/* High-level form definition */

class FormSchemaMeta {
  String formId;
  String name;
  String description;
  List<FormFieldMeta> fields;

  FormSchemaMeta({
    required this.formId,
    required this.name,
    required this.description,
    required this.fields,
  });

  factory FormSchemaMeta.fromFirestore(
      String id, Map<String, dynamic> map) {
    final schema = map['schema'] ?? {};
    final fieldsJson = (schema['fields'] ?? []) as List<dynamic>;

    return FormSchemaMeta(
      formId: id,
      name: map['name'] ?? id,
      description: map['description'] ?? '',
      fields: fieldsJson
          .map((e) => FormFieldMeta.fromMap(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toFirestore() {
    final schema = {
      'formId': formId,
      'version': 1,
      'fields': fields.map((f) => f.toMap()).toList(),
    };

    return {
      'name': name,
      'description': description,
      'schema': schema,
    };
  }

  static FormSchemaMeta defaultUserRegistration() {
    return FormSchemaMeta(
      formId: 'user_registration',
      name: 'User Registration Form',
      description: 'New user signup with designation + department',
      fields: [
        FormFieldMeta(
          id: 'fullName',
          type: 'text',
          label: 'Full Name',
          required: true,
          validation: r'^[a-zA-Z\s]{3,50}$',
        ),
        FormFieldMeta(
          id: 'email',
          type: 'email',
          label: 'Email Address',
          required: true,
          validation: r'^[^@]+@[^@]+\.[^@]+$',
        ),
      ],
    );
  }
}

/* Per-field metadata */

class FormFieldMeta {
  String id;
  String type;              // text, email, dropdown, checkbox, date, etc.
  String label;
  bool required;
  List<String> options;     // for static dropdowns

  // Dynamic data source (for designation / department pickers, etc.)
  String? dataSource;       // e.g. "firestore"
  String? collection;       // collection path under tenant (e.g. "designations")
  String? displayField;     // field used for display text
  String? valueField;       // field used as stored value

  // Schema-driven validation (regex)
  String? validation;

  FormFieldMeta({
    required this.id,
    required this.type,
    required this.label,
    this.required = false,
    List<String>? options,
    this.dataSource,
    this.collection,
    this.displayField,
    this.valueField,
    this.validation,
  }) : options = options ?? [];

  factory FormFieldMeta.fromMap(Map<String, dynamic> map) {
    return FormFieldMeta(
      id: map['id'] ?? '',
      type: map['type'] ?? 'text',
      label: map['label'] ?? '',
      required: map['required'] ?? false,
      options: List<String>.from(map['options'] ?? const []),
      dataSource: map['dataSource'],
      collection: map['collection'],
      displayField: map['displayField'],
      valueField: map['valueField'],
      validation: map['validation'],
    );
  }

  Map<String, dynamic> toMap() {
    final data = <String, dynamic>{
      'id': id,
      'type': type,
      'label': label,
      'required': required,
    };
    if (options.isNotEmpty) data['options'] = options;
    if (dataSource != null) data['dataSource'] = dataSource;
    if (collection != null) data['collection'] = collection;
    if (displayField != null) data['displayField'] = displayField;
    if (valueField != null) data['valueField'] = valueField;
    if (validation != null) data['validation'] = validation;
    return data;
  }
}

================================================================================

// File: lib\Developer\Hierarchy\hierarchy_panel.dart
import 'package:flutter/material.dart';

import 'hierarchy_repository.dart';
import 'org_node_model.dart';

class HierarchyPanel extends StatefulWidget {
  const HierarchyPanel({super.key});

  @override
  State<HierarchyPanel> createState() => _HierarchyPanelState();
}

class _HierarchyPanelState extends State<HierarchyPanel> {
  // Single fixed tenant
  static const String tenantId = HierarchyRepository.tenantId;

  final HierarchyRepository _repo = HierarchyRepository();
  final List<OrgNodeMeta> _nodes = [];

  bool _loading = false;
  bool _saving = false;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  String? _selectedNodeId;

  OrgNodeMeta? get _selectedNode {
    try {
      return _nodes.firstWhere((n) => n.id == _selectedNodeId);
    } catch (_) {
      return null;
    }
  }

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await _repo.loadHierarchy();
      setState(() {
        _nodes
          ..clear()
          ..addAll(list);
        _selectedNodeId = _nodes.isEmpty ? null : _nodes.first.id;
      });
      _setStatus('Hierarchy loaded (${_nodes.length} nodes)');
    } catch (e) {
      _setStatus('Failed to load hierarchy: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  void _setStatus(String msg, {bool error = false}) {
    setState(() {
      _status = msg;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await _repo.saveHierarchy(_nodes);
      _setStatus('Hierarchy saved for tenant $tenantId');
    } catch (e) {
      _setStatus('Failed to save hierarchy: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  /// Generate node id from name:
  /// 1. lowercase
  /// 2. only letters / digits / space / - / _
  /// 3. spaces and - to _
  String _generateIdFromName(String rawName) {
    final lower = rawName.toLowerCase();
    final buffer = StringBuffer();
    for (final ch in lower.runes) {
      final c = String.fromCharCode(ch);
      final isAlphaNum =
          (c.codeUnitAt(0) >= 97 && c.codeUnitAt(0) <= 122) || // a-z
          (c.codeUnitAt(0) >= 48 && c.codeUnitAt(0) <= 57); // 0-9
      if (isAlphaNum) {
        buffer.write(c);
      } else if (c == ' ' || c == '-' || c == '_') {
        buffer.write('_');
      }
      // other characters are skipped (not allowed)
    }
    var id = buffer.toString();
    id = id.replaceAll(RegExp('_+'), '_').trim();
    if (id.startsWith('_')) id = id.substring(1);
    if (id.endsWith('_')) id = id.substring(0, id.length - 1);
    if (id.isEmpty) {
      id = 'node_${DateTime.now().millisecondsSinceEpoch}';
    }
    return id;
  }

  /// Name validation: only letters, digits, space, - and _.
  String? _validateName(String value) {
    if (value.trim().isEmpty) {
      return 'Name is required';
    }
    final regex = RegExp(r'^[a-zA-Z0-9 _-]+$');
    if (!regex.hasMatch(value)) {
      return 'Only letters, numbers, space, - and _ are allowed';
    }
    return null;
  }

  void _addNode({String? parentId}) {
    final nameController = TextEditingController();
    final typeController = TextEditingController(text: 'organization');
    final levelController = TextEditingController();
    final managerIdController = TextEditingController();
    final designationController = TextEditingController();
    bool isActive = true;

    // compute default level from parent
    int computedLevel = 0;
    if (parentId != null && _nodes.isNotEmpty) {
      final parent = _nodes.firstWhere((n) => n.id == parentId);
      computedLevel = parent.level + 1;
    }
    levelController.text = computedLevel.toString();

    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: const Text(
              'Add Node',
              style: TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 460,
              child: Form(
                key: formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    // Name (only editable field for id generation)
                    TextFormField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name (e.g. Automation Testing Team)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                      validator: (v) => _validateName(v ?? ''),
                    ),
                    const SizedBox(height: 12),

                    // Parent info (read-only)
                    Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        'Parent: ${parentId ?? '(root node)'}',
                        style: const TextStyle(
                          color: Colors.white70,
                          fontSize: 12,
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),

                    // Type
                    TextFormField(
                      controller: typeController,
                      decoration: const InputDecoration(
                        labelText:
                            'Type (e.g. organization, department, team)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Level
                    TextFormField(
                      controller: levelController,
                      keyboardType: TextInputType.number,
                      decoration: const InputDecoration(
                        labelText: 'Level (0 = root)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Manager ID
                    TextFormField(
                      controller: managerIdController,
                      decoration: const InputDecoration(
                        labelText: 'Manager ID (optional)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Designation IDs
                    TextFormField(
                      controller: designationController,
                      decoration: const InputDecoration(
                        labelText:
                            'Designation IDs (comma-separated, e.g. ceo,cto)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Active
                    SwitchListTile(
                      value: isActive,
                      onChanged: (v) =>
                          setDialogState(() => isActive = v),
                      title: const Text(
                        'Active',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (!formKey.currentState!.validate()) return;

                  final rawName = nameController.text.trim();
                  final id = _generateIdFromName(rawName);

                  final level =
                      int.tryParse(levelController.text.trim()) ??
                          computedLevel;

                  final node = OrgNodeMeta(
                    id: id,
                    name: rawName,
                    parentId: parentId,
                    type: typeController.text.trim().isEmpty
                        ? 'organization'
                        : typeController.text.trim(),
                    level: level,
                    managerId:
                        managerIdController.text.trim().isEmpty
                            ? null
                            : managerIdController.text.trim(),
                    designationIds:
                        _splitCsv(designationController.text),
                    isActive: isActive,
                  );

                  setState(() {
                    _nodes.add(node);
                    _selectedNodeId = id;
                  });

                  Navigator.pop(context);
                },
                child: const Text('Add'),
              ),
            ],
          );
        },
      ),
    );
  }

  void _editSelectedNode() {
    final node = _selectedNode;
    if (node == null) return;

  final nameController = TextEditingController(text: node.name);
  final typeController = TextEditingController(text: node.type);
  final managerIdController =
      TextEditingController(text: node.managerId ?? '');
  final designationController =
      TextEditingController(text: node.designationIds.join(', '));

    bool isActive = node.isActive;

    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: const Text(
              'Edit Node',
              style: TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 420,
              child: Form(
                key: formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    TextFormField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                      validator: (v) => _validateName(v ?? ''),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: typeController,
                      decoration: const InputDecoration(
                        labelText: 'Type',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: managerIdController,
                      decoration: const InputDecoration(
                        labelText: 'Manager ID',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    TextFormField(
                      controller: designationController,
                      decoration: const InputDecoration(
                        labelText:
                            'Designation IDs (comma-separated)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),
                    SwitchListTile(
                      value: isActive,
                      onChanged: (v) =>
                          setDialogState(() => isActive = v),
                      title: const Text(
                        'Active',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  if (!formKey.currentState!.validate()) return;

                  setState(() {
                    node.name = nameController.text.trim();
                    node.type = typeController.text.trim().isEmpty
                        ? 'organization'
                        : typeController.text.trim();
                    node.managerId =
                        managerIdController.text.trim().isEmpty
                            ? null
                            : managerIdController.text.trim();
                    node.designationIds =
                        _splitCsv(designationController.text);
                    node.isActive = isActive;
                  });
                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  void _deleteSelectedNode() {
    final node = _selectedNode;
    if (node == null) return;

    final roots = _nodes.where((n) => n.parentId == null).toList();
    if (roots.length == 1 && node.parentId == null) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          backgroundColor: const Color(0xFF111118),
          title: const Text(
            'Cannot Delete Last Root Node',
            style: TextStyle(color: Colors.redAccent),
          ),
          content: const Text(
            'The hierarchy must have at least one root node. '
            'Please add another root node before deleting this one.',
            style: TextStyle(color: Colors.white70),
          ),
          actions: [
            FilledButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('OK'),
            ),
          ],
        ),
      );
      return;
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Text(
          'Delete Node?',
          style: TextStyle(color: Colors.orange),
        ),
        content: Text(
          'Delete "${node.name}" and all its children? '
          'This action cannot be undone.',
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Colors.redAccent,
            ),
            onPressed: () {
              Navigator.pop(context);
              _performDelete(node);
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _performDelete(OrgNodeMeta node) {
    final toRemove = <String>{node.id};
    bool changed;

    do {
      changed = false;
      for (final n in _nodes.toList()) {
        if (n.parentId != null && toRemove.contains(n.parentId)) {
          if (toRemove.add(n.id)) changed = true;
        }
      }
    } while (changed);

    setState(() {
      _nodes.removeWhere((n) => toRemove.contains(n.id));
      if (_nodes.isEmpty || toRemove.contains(_selectedNodeId)) {
        _selectedNodeId = _nodes.isEmpty ? null : _nodes.first.id;
      }
    });

    _setStatus('Deleted ${toRemove.length} node(s)');
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Organization Hierarchy Builder',
          style: TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          'Define org tree used for approvals, reporting, and dynamic queries.',
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Row(
            children: [
              SizedBox(
                width: 280,
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: _buildTreeView(),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: _buildDetails(),
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTreeView() {
    if (_nodes.isEmpty) {
      return Column(
        children: [
          OutlinedButton.icon(
            onPressed: () => _addNode(parentId: null),
            icon: const Icon(Icons.add_box_outlined),
            label: const Text('Add Root'),
          ),
          const Expanded(
            child: Center(
              child: Text(
                'No nodes yet.\nCreate a root node.',
                style: TextStyle(color: Colors.white70),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ],
      );
    }

    final roots = _nodes.where((n) => n.parentId == null).toList()
      ..sort((a, b) => a.name.compareTo(b.name));

    List<Widget> buildChildren(String parentId, int indent) {
      final children =
          _nodes.where((n) => n.parentId == parentId).toList()
            ..sort((a, b) => a.name.compareTo(b.name));

      return children
          .map(
            (child) => Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _treeTile(child, indent.toDouble()),
                ...buildChildren(child.id, indent + 16),
              ],
            ),
          )
          .toList();
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        OutlinedButton.icon(
          onPressed: () => _addNode(parentId: null),
          icon: const Icon(Icons.add_box_outlined),
          label: const Text('Add Root'),
        ),
        const SizedBox(height: 8),
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: roots
                  .map(
                    (root) => Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        _treeTile(root, 0),
                        ...buildChildren(root.id, 16),
                      ],
                    ),
                  )
                  .toList(),
            ),
          ),
        ),
      ],
    );
  }

  Widget _treeTile(OrgNodeMeta node, double indent) {
  final selected = node.id == _selectedNodeId;
  final Color connectorColor =
      node.isActive ? Colors.cyan : Colors.grey; // same as icon

  return GestureDetector(
    onTap: () => setState(() => _selectedNodeId = node.id),
    child: Container(
      margin: const EdgeInsets.symmetric(vertical: 2),
      padding: const EdgeInsets.only(right: 8, top: 2, bottom: 2),
      decoration: BoxDecoration(
        color: selected ? const Color(0xFF1A1A25) : Colors.transparent,
        borderRadius: BorderRadius.circular(6),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // connector column
          SizedBox(
            width: indent,
            child: Align(
              alignment: Alignment.topRight,
              child: Container(
                width: 1.5,
                height: 26, // length of the vertical line
                color: node.parentId == null
                    ? Colors.transparent // no line for root
                    : connectorColor.withOpacity(0.7),
              ),
            ),
          ),
          const SizedBox(width: 4),

          // icon + label
          Icon(
            node.parentId == null
                ? Icons.account_tree_rounded
                : Icons.subdirectory_arrow_right_rounded,
            size: 18,
            color: connectorColor,
          ),
          const SizedBox(width: 6),
          Expanded(
            child: Text(
              node.name,
              style: TextStyle(
                color: node.isActive ? Colors.white : Colors.grey,
                fontWeight:
                    selected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ),
        ],
      ),
    ),
  );
}


  Widget _buildDetails() {
    final node = _selectedNode;

    if (node == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.info_outline, size: 64, color: Colors.grey[600]),
            const SizedBox(height: 16),
            const Text(
              'Select a node to view or edit details.',
              style: TextStyle(color: Colors.white70, fontSize: 16),
            ),
          ],
        ),
      );
    }

    // READ-ONLY view; editing only via dialog button
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Text(
                'Node Details',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.edit, color: Colors.cyan),
                onPressed: _editSelectedNode,
                tooltip: 'Edit Node',
              ),
              IconButton(
                icon: const Icon(Icons.delete, color: Colors.redAccent),
                onPressed: _deleteSelectedNode,
                tooltip: 'Delete Node',
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Name
          Text(
            'Name',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.name,
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Type
          Text(
            'Type',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.type,
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Manager ID
          Text(
            'Manager ID',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.managerId ?? '-',
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Designation IDs
          Text(
            'Designation IDs',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Text(
            node.designationIds.join(', '),
            style: const TextStyle(color: Colors.white, fontSize: 14),
          ),
          const SizedBox(height: 16),

          // Active
          Text(
            'Active',
            style: TextStyle(color: Colors.grey[500], fontSize: 12),
          ),
          const SizedBox(height: 4),
          Row(
            children: [
              Icon(
                node.isActive ? Icons.check_circle : Icons.cancel,
                color: node.isActive ? Colors.greenAccent : Colors.redAccent,
                size: 18,
              ),
              const SizedBox(width: 6),
              Text(
                node.isActive ? 'Yes' : 'No',
                style:
                    const TextStyle(color: Colors.white, fontSize: 14),
              ),
            ],
          ),
          const SizedBox(height: 24),

          const Divider(color: Colors.white24),
          const SizedBox(height: 8),
          Text(
            'Node ID: ${node.id}',
            style: TextStyle(color: Colors.grey[600], fontSize: 12),
          ),
          Text(
            'Level: ${node.level}',
            style: TextStyle(color: Colors.grey[600], fontSize: 12),
          ),
          if (node.parentId != null)
            Text(
              'Parent ID: ${node.parentId}',
              style: TextStyle(color: Colors.grey[600], fontSize: 12),
            ),
          const SizedBox(height: 16),
          const Text(
            'Add Child Node',
            style: TextStyle(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          OutlinedButton.icon(
            onPressed: () => _addNode(parentId: node.id),
            icon: const Icon(Icons.add),
            label: const Text('Add Child'),
          ),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\Developer\Hierarchy\hierarchy_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'org_node_model.dart';

class HierarchyRepository {
  final FirebaseFirestore _db;

  HierarchyRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;

  static const String tenantId = 'default_tenant';

  Future<List<OrgNodeMeta>> loadHierarchy() async {
    // 1. Load all docs without Firestore orderBy â†’ no composite index needed
    final snap = await _db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes')
        .get();

    // 2. Map to models
    final nodes = snap.docs
        .map((doc) => OrgNodeMeta.fromMap(doc.id, doc.data()))
        .toList();

    // 3. Apply same ordering in Dart: first by level, then by name
    nodes.sort((a, b) {
      final levelCmp = a.level.compareTo(b.level);
      if (levelCmp != 0) return levelCmp;
      return a.name.compareTo(b.name);
    });

    return nodes;
  }

  Future<void> saveHierarchy(List<OrgNodeMeta> nodes) async {
    final batch = _db.batch();
    final coll = _db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes');

    final existing = await coll.get();
    for (final doc in existing.docs) {
      batch.delete(doc.reference);
    }

    for (final node in nodes) {
      final ref = coll.doc(node.id);
      batch.set(ref, node.toMap());
    }

    await batch.commit();
  }
}

================================================================================

// File: lib\Developer\Hierarchy\org_node_model.dart
class OrgNodeMeta {
  String id;
  String name;
  String? parentId;
  String type;            // organization, department, team, etc.
  int level;              // depth in tree (0 = root)
  String? managerId;      // optional manager user id
  List<String> designationIds;
  bool isActive;

  OrgNodeMeta({
    required this.id,
    required this.name,
    required this.parentId,
    required this.type,
    required this.level,
    required this.managerId,
    required this.designationIds,
    required this.isActive,
  });

  factory OrgNodeMeta.fromMap(String id, Map<String, dynamic> map) {
    return OrgNodeMeta(
      id: id,
      name: map['name'] ?? id,
      parentId: map['parentId'],
      type: map['type'] ?? 'organization',
      level: (map['level'] ?? 0) as int,
      managerId: map['managerId'],
      designationIds: List<String>.from(map['designationIds'] ?? const []),
      isActive: map['isActive'] ?? true,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'parentId': parentId,
      'type': type,
      'level': level,
      'managerId': managerId,
      'designationIds': designationIds,
      'isActive': isActive,
    };
  }

  OrgNodeMeta copyWith({
    String? id,
    String? name,
    String? parentId,
    String? type,
    int? level,
    String? managerId,
    List<String>? designationIds,
    bool? isActive,
  }) {
    return OrgNodeMeta(
      id: id ?? this.id,
      name: name ?? this.name,
      parentId: parentId ?? this.parentId,
      type: type ?? this.type,
      level: level ?? this.level,
      managerId: managerId ?? this.managerId,
      designationIds: designationIds ?? this.designationIds,
      isActive: isActive ?? this.isActive,
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\metadata_panel.dart
import 'package:flutter/material.dart';

import 'metadata_repository.dart';
import 'designation/designation_tab.dart';
import 'role_permission/role_permission_tab.dart';
import 'form_schema/form_schema_tab.dart';

enum MetaType { designations, rolePermissions, formSchemas }

class MetadataPanel extends StatefulWidget {
  const MetadataPanel({super.key});

  @override
  State<MetadataPanel> createState() => _MetadataPanelState();
}

class _MetadataPanelState extends State<MetadataPanel> {
  // Line 13:
  static const String tenantId = 'default_tenant'; // Fixed


  final MetadataRepository _repo = MetadataRepository(); // â† no const

  MetaType _selectedType = MetaType.designations;
  String? _status;
  Color _statusColor = Colors.greenAccent;

  void _setStatus(String message, {bool error = false}) {
    setState(() {
      _status = message;
      _statusColor = error ? Colors.redAccent : Colors.greenAccent;
    });
  }

  @override
  Widget build(BuildContext context) {
    final title = switch (_selectedType) {
      MetaType.designations => 'Metadata Engine â€“ Designations',
      MetaType.rolePermissions => 'Metadata Engine â€“ Role Permissions',
      MetaType.formSchemas => 'Metadata Engine â€“ Form Schemas',
    };

    final subtitle = switch (_selectedType) {
      MetaType.designations =>
          'Manage designation hierarchy, permissions and screen access without editing JSON.',
      MetaType.rolePermissions => 'Map roles to permission lists used by RBAC.',
      MetaType.formSchemas =>
          'Manage system/custom forms and their JSON schemas.',
    };

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 24,
            color: Colors.white,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        Text(
          subtitle,
          style: TextStyle(color: Colors.grey[400]),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            DropdownButton<MetaType>(
              value: _selectedType,
              dropdownColor: const Color(0xFF111118),
              onChanged: (v) {
                if (v == null) return;
                setState(() => _selectedType = v);
              },
              items: const [
                DropdownMenuItem(
                  value: MetaType.designations,
                  child: Text('Designations'),
                ),
                DropdownMenuItem(
                  value: MetaType.rolePermissions,
                  child: Text('Role Permissions'),
                ),
                DropdownMenuItem(
                  value: MetaType.formSchemas,
                  child: Text('Form Schemas'),
                ),
              ],
            ),
            const Spacer(),
            if (_status != null)
              Text(
                _status!,
                style: TextStyle(color: _statusColor, fontSize: 12),
              ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: Card(
            color: const Color(0xFF111118),
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: switch (_selectedType) {
                MetaType.designations => DesignationTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
                MetaType.rolePermissions => RolePermissionTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
                MetaType.formSchemas => FormSchemaTab(
                    tenantId: tenantId,
                    repo: _repo,
                    setStatus: _setStatus,
                  ),
              },
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\metadata_repository.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import 'designation/designation_model.dart';
import 'role_permission/role_permission_model.dart';
import 'form_schema/form_schema_model.dart';

class MetadataRepository {
  final FirebaseFirestore _db;

  MetadataRepository({FirebaseFirestore? db})
      : _db = db ?? FirebaseFirestore.instance;
  /* ------------------------------ Designations ----------------------------- */

  Future<List<DesignationMeta>> loadDesignations(String tenantId) async {
  try {
    // FIXED: Correct path structure
    final snap = await _db
        .collection('tenants')
        .doc(tenantId)
        .collection('metadata')
        .doc('designations')
        .get();

    final List<DesignationMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      
      // FIXED: Check if 'designations' key exists
      if (data.containsKey('designations')) {
        final map = data['designations'] as Map<String, dynamic>;
        
        for (final entry in map.entries) {
          result.add(DesignationMeta.fromMap(entry.key, entry.value as Map<String, dynamic>));
        }
      }
    }

    // Seed default if empty
    if (result.isEmpty) {
      result.add(
        DesignationMeta(
          id: 'developer',
          name: 'Developer',
          hierarchyLevel: 1,
          reportsTo: const [],
          permissions: const ['all'],
          screenAccess: const ['developer'],
          requiresApproval: false,
          isRoot: true,
        ),
      );
      
      // AUTO-SAVE the seeded designation
      await saveDesignations(tenantId, result);
    }

    return result;
  } catch (e) {
    debugPrint('âŒ Error loading designations: $e');
    return [];
  }
}
  

  Future<void> saveDesignations(
      String tenantId, List<DesignationMeta> list) async {
    final data = {
      'designations': {for (final d in list) d.id: d.toMap()},
    };

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('designations')
        .set(data);
  }

  /* --------------------------- Role Permissions --------------------------- */

  Future<List<RolePermissionMeta>> loadRolePermissions(
      String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('rolePermissions')
        .get();

    final List<RolePermissionMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final map =
          (data['roles'] ?? <String, dynamic>{}) as Map<String, dynamic>;
      for (final entry in map.entries) {
        result.add(RolePermissionMeta.fromMap(entry.key, entry.value));
      }
    }

    if (result.isEmpty) {
      result.add(RolePermissionMeta(roleId: 'developer_root', permissions: ['*']));
    }

    return result;
  }

  Future<void> saveRolePermissions(
      String tenantId, List<RolePermissionMeta> list) async {
    final data = {
      'roles': {for (final r in list) r.roleId: r.toMap()},
    };

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('rolePermissions')
        .set(data);
  }

  /* ------------------------------ Form Schemas ---------------------------- */

  Future<List<FormSchemaMeta>> loadFormSchemas(String tenantId) async {
    final snap = await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .get();

    final List<FormSchemaMeta> result = [];

    if (snap.exists && snap.data() != null) {
      final data = snap.data() as Map<String, dynamic>;
      final forms =
          (data['forms'] ?? <String, dynamic>{}) as Map<String, dynamic>;

      for (final entry in forms.entries) {
        final m = entry.value as Map<String, dynamic>;
        result.add(FormSchemaMeta.fromFirestore(entry.key, m));
      }
    }

    if (result.isEmpty) {
      // seed with a default user registration form
      result.add(FormSchemaMeta.defaultUserRegistration());
    }

    return result;
  }

  Future<void> saveFormSchemas(
      String tenantId, List<FormSchemaMeta> list) async {
    final forms = <String, dynamic>{};

    for (final f in list) {
      forms[f.formId] = f.toFirestore();
    }

    await _db
        .collection('tenants/$tenantId/metadata')
        .doc('formSchemas')
        .set({'forms': forms});
  }
}

================================================================================

// File: lib\Developer\Metadata\designation\designation_model.dart
class DesignationMeta {
  String id;
  String name;
  int hierarchyLevel;
  List<String> reportsTo;
  List<String> permissions;
  List<String> screenAccess;
  bool requiresApproval;
  bool isRoot;

  DesignationMeta({
    required this.id,
    required this.name,
    required this.hierarchyLevel,
    required this.reportsTo,
    required this.permissions,
    required this.screenAccess,
    required this.requiresApproval,
    required this.isRoot,
  });

  factory DesignationMeta.fromMap(String id, Map<String, dynamic> map) {
    return DesignationMeta(
      id: id,
      name: map['name'] ?? '',
      hierarchyLevel: (map['hierarchy_level'] ?? 0) as int,
      reportsTo: List<String>.from(map['reports_to'] ?? const []),
      permissions: List<String>.from(map['permissions'] ?? const []),
      screenAccess: List<String>.from(map['screen_access'] ?? const []),
      requiresApproval: map['requires_approval'] ?? false,
      isRoot: map['is_root'] ?? false,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'hierarchy_level': hierarchyLevel,
      'reports_to': reportsTo,
      'permissions': permissions,
      'screen_access': screenAccess,
      'requires_approval': requiresApproval,
      'is_root': isRoot,
    };
  }
}

================================================================================

// File: lib\Developer\Metadata\designation\designation_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'designation_model.dart';

class DesignationTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const DesignationTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<DesignationTab> createState() => _DesignationTabState();
}

class _DesignationTabState extends State<DesignationTab> {
  final List<DesignationMeta> _designations = [];
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
  setState(() => _loading = true);
  
  try {
    debugPrint('ğŸ”„ Loading designations for tenant: ${widget.tenantId}');
    
    final list = await widget.repo.loadDesignations(widget.tenantId);
    
    debugPrint('âœ… Loaded ${list.length} designations:');
    for (final d in list) {
      debugPrint('   - ${d.id}: ${d.name} (level ${d.hierarchyLevel})');
    }
    
    setState(() {
      _designations
        ..clear()
        ..addAll(list);
    });
    
    widget.setStatus('${list.length} Designations loaded', error: false);
  } catch (e, stackTrace) {
    debugPrint('âŒ Error loading designations: $e');
    debugPrint('Stack trace: $stackTrace');
    widget.setStatus('Failed to load designations: $e', error: true);
  } finally {
    setState(() => _loading = false);
  }
}


  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveDesignations(widget.tenantId, _designations);
      widget.setStatus('Designations saved');
    } catch (e) {
      widget.setStatus('Failed to save designations: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _openDialog({DesignationMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.id ?? '');
    final nameController = TextEditingController(text: existing?.name ?? '');
    final levelController =
        TextEditingController(text: (existing?.hierarchyLevel ?? 1).toString());
    final reportsToController =
        TextEditingController(text: (existing?.reportsTo ?? []).join(', '));
    final permissionsController =
        TextEditingController(text: (existing?.permissions ?? []).join(', '));
    final screensController =
        TextEditingController(text: (existing?.screenAccess ?? []).join(', '));
    bool requiresApproval = existing?.requiresApproval ?? false;
    bool isRoot = existing?.isRoot ?? false;

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: Text(
              isNew ? 'Add Designation' : 'Edit Designation',
              style: const TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 480,
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    // ID
                    TextField(
                      controller: idController,
                      enabled: isNew,
                      decoration: const InputDecoration(
                        labelText: 'ID (e.g. developer)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Name
                    TextField(
                      controller: nameController,
                      decoration: const InputDecoration(
                        labelText: 'Name',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Hierarchy level
                    TextField(
                      controller: levelController,
                      decoration: const InputDecoration(
                        labelText: 'Hierarchy Level',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      keyboardType: TextInputType.number,
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Reports to
                    TextField(
                      controller: reportsToController,
                      decoration: const InputDecoration(
                        labelText: 'Reports To (comma-separated IDs)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Permissions
                    TextField(
                      controller: permissionsController,
                      decoration: const InputDecoration(
                        labelText: 'Permissions (comma-separated)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Screen access
                    TextField(
                      controller: screensController,
                      decoration: const InputDecoration(
                        labelText:
                            'Screen Access (comma-separated, e.g. developer, admin)',
                        floatingLabelBehavior: FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                    const SizedBox(height: 12),

                    // Switches
                    SwitchListTile(
                      value: requiresApproval,
                      onChanged: (v) =>
                          setDialogState(() => requiresApproval = v),
                      title: const Text(
                        'Requires Approval',
                        style: TextStyle(color: Colors.white),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                    SwitchListTile(
                      value: isRoot,
                      onChanged: (v) => setDialogState(() => isRoot = v),
                      title: const Text(
                        'Root Access (Full System Control)',
                        style: TextStyle(color: Colors.white),
                      ),
                      subtitle: const Text(
                        'Root designations can manage all tenants, metadata and workflows.',
                        style: TextStyle(color: Colors.grey),
                      ),
                      contentPadding: EdgeInsets.zero,
                    ),
                  ],
                ),
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  final id = idController.text.trim();
                  if (id.isEmpty) return;

                  final designation = DesignationMeta(
                    id: id,
                    name: nameController.text.trim(),
                    hierarchyLevel:
                        int.tryParse(levelController.text.trim()) ?? 1,
                    reportsTo: _splitCsv(reportsToController.text),
                    permissions: _splitCsv(permissionsController.text),
                    screenAccess: _splitCsv(screensController.text),
                    requiresApproval: requiresApproval,
                    isRoot: isRoot,
                  );

                  setState(() {
                    if (isNew) {
                      _designations.add(designation);
                    } else {
                      final index =
                          _designations.indexWhere((element) => element.id == id);
                      if (index != -1) {
                        _designations[index] = designation;
                      }
                    }
                  });

                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () => _openDialog(),
              icon: const Icon(Icons.add),
              label: const Text('Add Designation'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('ID')),
                DataColumn(label: Text('Name')),
                DataColumn(label: Text('Level')),
                DataColumn(label: Text('Screens')),
                DataColumn(label: Text('Root')),
                DataColumn(label: Text('Requires Approval')),
                DataColumn(label: Text('Actions')),
              ],
              rows: _designations.map((d) {
                return DataRow(
                  cells: [
                    DataCell(Text(d.id)),
                    DataCell(Text(d.name)),
                    DataCell(Text(d.hierarchyLevel.toString())),
                    DataCell(Text(d.screenAccess.join(', '))),
                    DataCell(
                      Icon(
                        d.isRoot
                            ? Icons.stars
                            : Icons.remove_circle_outline,
                        color:
                            d.isRoot ? Colors.purpleAccent : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Icon(
                        d.requiresApproval
                            ? Icons.check_circle
                            : Icons.cancel,
                        color: d.requiresApproval
                            ? Colors.orange
                            : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () => _openDialog(existing: d),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                _designations
                                    .removeWhere((x) => x.id == d.id);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\form_schema\form_schema_model.dart
import 'dart:convert';

/* High-level form definition */

class FormSchemaMeta {
  String formId;
  String name;
  String description;
  List<FormFieldMeta> fields;

  FormSchemaMeta({
    required this.formId,
    required this.name,
    required this.description,
    required this.fields,
  });

  factory FormSchemaMeta.fromFirestore(
      String id, Map<String, dynamic> map) {
    final schema = map['schema'] ?? {};
    final fieldsJson = (schema['fields'] ?? []) as List<dynamic>;

    return FormSchemaMeta(
      formId: id,
      name: map['name'] ?? id,
      description: map['description'] ?? '',
      fields: fieldsJson
          .map((e) => FormFieldMeta.fromMap(e as Map<String, dynamic>))
          .toList(),
    );
  }

  /// Convert back to Firestore document structure:
  /// { name, description, schema: { formId, version, fields: [...] } }
  Map<String, dynamic> toFirestore() {
    final schema = {
      'formId': formId,
      'version': 1,
      'fields': fields.map((f) => f.toMap()).toList(),
    };

    return {
      'name': name,
      'description': description,
      'schema': schema,
    };
  }

  static FormSchemaMeta defaultUserRegistration() {
    return FormSchemaMeta(
      formId: 'user_registration',
      name: 'User Registration Form',
      description: 'New user signup with designation + department',
      fields: [
        FormFieldMeta(
          id: 'fullName',
          type: 'text',
          label: 'Full Name',
          required: true,
        ),
        FormFieldMeta(
          id: 'email',
          type: 'email',
          label: 'Email Address',
          required: true,
        ),
      ],
    );
  }
}

/* Per-field metadata â€“ this is what the UI edits */

class FormFieldMeta {
  String id;
  String type; // text, email, password, dropdown, checkbox, date, etc.[file:2]
  String label;
  bool required;
  List<String> options; // used when type == dropdown (static options)

  FormFieldMeta({
    required this.id,
    required this.type,
    required this.label,
    this.required = false,
    List<String>? options,
  }) : options = options ?? [];

  factory FormFieldMeta.fromMap(Map<String, dynamic> map) {
    return FormFieldMeta(
      id: map['id'] ?? '',
      type: map['type'] ?? 'text',
      label: map['label'] ?? '',
      required: map['required'] ?? false,
      options: List<String>.from(map['options'] ?? const []),
    );
  }

  Map<String, dynamic> toMap() {
    final data = <String, dynamic>{
      'id': id,
      'type': type,
      'label': label,
      'required': required,
    };
    if (options.isNotEmpty) {
      data['options'] = options;
    }
    return data;
  }
}

================================================================================

// File: lib\Developer\Metadata\form_schema\form_schema_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'form_schema_model.dart';

class FormSchemaTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const FormSchemaTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<FormSchemaTab> createState() => _FormSchemaTabState();
}

class _FormSchemaTabState extends State<FormSchemaTab> {
  final List<FormSchemaMeta> _forms = [];
  int _selectedIndex = 0;
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await widget.repo.loadFormSchemas(widget.tenantId);
      setState(() {
        _forms
          ..clear()
          ..addAll(list);
        _selectedIndex = _forms.isEmpty ? 0 : 0;
      });
      widget.setStatus('Form schemas loaded');
    } catch (e) {
      widget.setStatus('Failed to load form schemas: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveFormSchemas(widget.tenantId, _forms);
      widget.setStatus('Form schemas saved');
    } catch (e) {
      widget.setStatus('Failed to save form schemas: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _createForm() {
    final idController = TextEditingController();
    final nameController = TextEditingController();
    final descController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Text(
          'Create New Form',
          style: TextStyle(color: Colors.white),
        ),
        content: SizedBox(
          width: 420,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                controller: idController,
                decoration: const InputDecoration(labelText: 'Form ID'),
                style: const TextStyle(color: Colors.white),
              ),
              TextField(
                controller: nameController,
                decoration: const InputDecoration(labelText: 'Name'),
                style: const TextStyle(color: Colors.white),
              ),
              TextField(
                controller: descController,
                decoration:
                    const InputDecoration(labelText: 'Description'),
                style: const TextStyle(color: Colors.white),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              final id = idController.text.trim();
              if (id.isEmpty) return;

              setState(() {
                _forms.add(
                  FormSchemaMeta(
                    formId: id,
                    name: nameController.text.trim().isEmpty
                        ? id
                        : nameController.text.trim(),
                    description: descController.text.trim(),
                    fields: [
                      // start with one text field as template
                      FormFieldMeta(
                        id: 'field1',
                        type: 'text',
                        label: 'Field 1',
                        required: false,
                      ),
                    ],
                  ),
                );
                _selectedIndex = _forms.length - 1;
              });

              Navigator.pop(context);
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  void _openFieldDialog(FormSchemaMeta form, {FormFieldMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.id ?? '');
    final labelController = TextEditingController(text: existing?.label ?? '');
    String type = existing?.type ?? 'text';
    bool required = existing?.required ?? false;
    final optionsController =
        TextEditingController(text: (existing?.options ?? []).join(', '));

    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setDialogState) {
          return AlertDialog(
            backgroundColor: const Color(0xFF111118),
            title: Text(
              isNew ? 'Add Field' : 'Edit Field',
              style: const TextStyle(color: Colors.white),
            ),
            content: SizedBox(
              width: 420,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  TextField(
                    controller: idController,
                    enabled: isNew,
                    decoration: const InputDecoration(
                      labelText: 'Field ID (e.g. fullName)',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    style: const TextStyle(color: Colors.white),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: labelController,
                    decoration: const InputDecoration(
                      labelText: 'Label',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    style: const TextStyle(color: Colors.white),
                  ),
                  const SizedBox(height: 12),
                  DropdownButtonFormField<String>(
                    value: type,
                    dropdownColor: const Color(0xFF111118),
                    decoration: const InputDecoration(
                      labelText: 'Field Type',
                      floatingLabelBehavior: FloatingLabelBehavior.auto,
                    ),
                    items: const [
                      DropdownMenuItem(
                        value: 'text',
                        child: Text('Text'),
                      ),
                      DropdownMenuItem(
                        value: 'email',
                        child: Text('Email'),
                      ),
                      DropdownMenuItem(
                        value: 'password',
                        child: Text('Password'),
                      ),
                      DropdownMenuItem(
                        value: 'dropdown',
                        child: Text('Dropdown (static)'),
                      ),
                      DropdownMenuItem(
                        value: 'checkbox',
                        child: Text('Checkbox'),
                      ),
                      DropdownMenuItem(
                        value: 'date',
                        child: Text('Date'),
                      ),
                    ],
                    onChanged: (v) =>
                        setDialogState(() => type = v ?? 'text'),
                  ),
                  const SizedBox(height: 12),
                  SwitchListTile(
                    value: required,
                    onChanged: (v) =>
                        setDialogState(() => required = v),
                    title: const Text(
                      'Required',
                      style: TextStyle(color: Colors.white),
                    ),
                    contentPadding: EdgeInsets.zero,
                  ),
                  if (type == 'dropdown') ...[
                    const SizedBox(height: 8),
                    TextField(
                      controller: optionsController,
                      decoration: const InputDecoration(
                        labelText:
                            'Options (comma-separated, for dropdown)',
                        floatingLabelBehavior:
                            FloatingLabelBehavior.auto,
                      ),
                      style: const TextStyle(color: Colors.white),
                    ),
                  ],
                ],
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text('Cancel'),
              ),
              FilledButton(
                onPressed: () {
                  final id = idController.text.trim();
                  if (id.isEmpty) return;

                  final field = FormFieldMeta(
                    id: id,
                    type: type,
                    label: labelController.text.trim().isEmpty
                        ? id
                        : labelController.text.trim(),
                    required: required,
                    options: _splitCsv(optionsController.text),
                  );

                  setState(() {
                    if (isNew) {
                      form.fields.add(field);
                    } else {
                      final idx = form.fields
                          .indexWhere((element) => element.id == id);
                      if (idx != -1) form.fields[idx] = field;
                    }
                  });

                  Navigator.pop(context);
                },
                child: const Text('Save'),
              ),
            ],
          );
        },
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    final hasForms = _forms.isNotEmpty;

    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: _createForm,
              icon: const Icon(Icons.add),
              label: const Text('Create Form'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: hasForms
              ? Row(
                  children: [
                    // LEFT: form list
                    SizedBox(
                      width: 260,
                      child: ListView.builder(
                        itemCount: _forms.length,
                        itemBuilder: (context, index) {
                          final f = _forms[index];
                          final selected = index == _selectedIndex;
                          return ListTile(
                            selected: selected,
                            selectedTileColor:
                                const Color(0xFF1A1A25),
                            title: Text(
                              f.formId,
                              style: TextStyle(
                                color: selected
                                    ? Colors.cyan
                                    : Colors.white,
                                fontWeight: selected
                                    ? FontWeight.bold
                                    : FontWeight.normal,
                              ),
                            ),
                            subtitle: Text(
                              f.name,
                              style: const TextStyle(
                                  color: Colors.grey, fontSize: 12),
                            ),
                            trailing: IconButton(
                              icon: const Icon(Icons.delete,
                                  size: 18,
                                  color: Colors.redAccent),
                              onPressed: () {
                                setState(() {
                                  _forms.removeAt(index);
                                  if (_selectedIndex >=
                                      _forms.length) {
                                    _selectedIndex =
                                        (_forms.length - 1)
                                            .clamp(0, 999);
                                  }
                                });
                              },
                            ),
                            onTap: () =>
                                setState(() => _selectedIndex = index),
                          );
                        },
                      ),
                    ),
                    const SizedBox(width: 12),

                    // RIGHT: form editor (name + description + fields table)
                    Expanded(
                      child: _buildFormEditor(_forms[_selectedIndex]),
                    ),
                  ],
                )
              : const Center(
                  child: Text(
                    'No forms defined yet.',
                    style: TextStyle(color: Colors.white70),
                  ),
                ),
        ),
      ],
    );
  }

  Widget _buildFormEditor(FormSchemaMeta form) {
    final nameController = TextEditingController(text: form.name);
    final descController =
        TextEditingController(text: form.description);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Editing form: ${form.formId}',
          style: const TextStyle(color: Colors.white, fontSize: 16),
        ),
        const SizedBox(height: 8),
        TextField(
          controller: nameController,
          decoration: const InputDecoration(labelText: 'Name'),
          style: const TextStyle(color: Colors.white),
          onChanged: (v) => form.name = v,
        ),
        const SizedBox(height: 8),
        TextField(
          controller: descController,
          decoration: const InputDecoration(labelText: 'Description'),
          style: const TextStyle(color: Colors.white),
          onChanged: (v) => form.description = v,
        ),
        const SizedBox(height: 12),
        Row(
          children: [
            const Text(
              'Fields',
              style: TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            const Spacer(),
            OutlinedButton.icon(
              onPressed: () => _openFieldDialog(form),
              icon: const Icon(Icons.add),
              label: const Text('Add Field'),
            ),
          ],
        ),
        const SizedBox(height: 8),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('ID')),
                DataColumn(label: Text('Label')),
                DataColumn(label: Text('Type')),
                DataColumn(label: Text('Required')),
                DataColumn(label: Text('Options')),
                DataColumn(label: Text('Actions')),
              ],
              rows: form.fields.map((f) {
                return DataRow(
                  cells: [
                    DataCell(Text(f.id)),
                    DataCell(Text(f.label)),
                    DataCell(Text(f.type)),
                    DataCell(
                      Icon(
                        f.required
                            ? Icons.check_circle
                            : Icons.cancel,
                        color: f.required
                            ? Colors.orange
                            : Colors.grey,
                        size: 18,
                      ),
                    ),
                    DataCell(
                      Text(
                        f.options.isEmpty
                            ? 'â€”'
                            : f.options.join(', '),
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () =>
                                _openFieldDialog(form, existing: f),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                form.fields
                                    .removeWhere((x) => x.id == f.id);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\Metadata\role_permission\role_permission_model.dart
class RolePermissionMeta {
  String roleId;
  List<String> permissions;
  String description;

  RolePermissionMeta({
    required this.roleId,
    required this.permissions,
    this.description = '',
  });

  factory RolePermissionMeta.fromMap(String id, Map<String, dynamic> map) {
    return RolePermissionMeta(
      roleId: id,
      permissions: List<String>.from(map['permissions'] ?? const []),
      description: map['description'] ?? '',
    );
  }

  Map<String, dynamic> toMap() => {
        'permissions': permissions,
        'description': description,
      };
}

================================================================================

// File: lib\Developer\Metadata\role_permission\role_permission_tab.dart
import 'package:flutter/material.dart';

import '../metadata_repository.dart';
import 'role_permission_model.dart';

class RolePermissionTab extends StatefulWidget {
  final String tenantId;
  final MetadataRepository repo;
  final void Function(String message, {bool error}) setStatus;

  const RolePermissionTab({
    super.key,
    required this.tenantId,
    required this.repo,
    required this.setStatus,
  });

  @override
  State<RolePermissionTab> createState() => _RolePermissionTabState();
}

class _RolePermissionTabState extends State<RolePermissionTab> {
  final List<RolePermissionMeta> _roles = [];
  bool _loading = false;
  bool _saving = false;

  @override
  void initState() {
    super.initState();
    _reload();
  }

  Future<void> _reload() async {
    setState(() => _loading = true);
    try {
      final list = await widget.repo.loadRolePermissions(widget.tenantId);
      setState(() {
        _roles
          ..clear()
          ..addAll(list);
      });
      widget.setStatus('Role permissions loaded');
    } catch (e) {
      widget.setStatus('Failed to load role permissions: $e', error: true);
    } finally {
      setState(() => _loading = false);
    }
  }

  Future<void> _save() async {
    setState(() => _saving = true);
    try {
      await widget.repo.saveRolePermissions(widget.tenantId, _roles);
      widget.setStatus('Role permissions saved');
    } catch (e) {
      widget.setStatus('Failed to save role permissions: $e', error: true);
    } finally {
      setState(() => _saving = false);
    }
  }

  void _openDialog({RolePermissionMeta? existing}) {
    final isNew = existing == null;

    final idController = TextEditingController(text: existing?.roleId ?? '');
    final permsController =
        TextEditingController(text: (existing?.permissions ?? []).join(', '));
    final descController =
        TextEditingController(text: existing?.description ?? '');

    // Pre-fill description for well-known roles if creating new.[file:2]
    void seedDefaultDescription(String roleId) {
      if (existing != null) return;
      switch (roleId) {
        case 'developer':
        case 'developer_root':
          descController.text =
              'Can manage all metadata, organizations, workflows; root access.';
          break;
        case 'admin':
          descController.text =
              'Can manage users, forms, workflows inside assigned org.';
          break;
        case 'manager':
          descController.text =
              'Can create/assign tasks, approve within hierarchy, view team.';
          break;
        case 'employee':
          descController.text =
              'Can view and complete assigned tasks, request approvals.';
          break;
      }
    }

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: Text(
          isNew ? 'Add Role' : 'Edit Role',
          style: const TextStyle(color: Colors.white),
        ),
        content: SizedBox(
          width: 460,
          child: SingleChildScrollView(
            child: Column(
              children: [
                TextField(
                  controller: idController,
                  enabled: isNew,
                  decoration: const InputDecoration(
                    labelText: 'Role ID (e.g. developer, admin)',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  style: const TextStyle(color: Colors.white),
                  onChanged: (v) => seedDefaultDescription(v.trim()),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: permsController,
                  decoration: const InputDecoration(
                    labelText: 'Permissions (comma-separated)',
                    hintText:
                        'create_org, manage_metadata, approve_tasks, view_reports',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  style: const TextStyle(color: Colors.white),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: descController,
                  decoration: const InputDecoration(
                    labelText: 'Description (what this role can do)',
                    floatingLabelBehavior: FloatingLabelBehavior.auto,
                  ),
                  maxLines: 3,
                  style: const TextStyle(color: Colors.white),
                ),
              ],
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              final id = idController.text.trim();
              if (id.isEmpty) return;

              final meta = RolePermissionMeta(
                roleId: id,
                permissions: _splitCsv(permsController.text),
                description: descController.text.trim(),
              );

              setState(() {
                if (isNew) {
                  _roles.add(meta);
                } else {
                  final idx =
                      _roles.indexWhere((element) => element.roleId == id);
                  if (idx != -1) _roles[idx] = meta;
                }
              });

              Navigator.pop(context);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  List<String> _splitCsv(String input) {
    return input
        .split(',')
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .toList();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Row(
          children: [
            FilledButton.icon(
              onPressed: _loading ? null : _reload,
              icon: _loading
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.refresh),
              label: const Text('Reload'),
            ),
            const SizedBox(width: 8),
            FilledButton.icon(
              onPressed: _saving ? null : _save,
              icon: _saving
                  ? const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.black,
                      ),
                    )
                  : const Icon(Icons.save),
              label: const Text('Save'),
            ),
            const SizedBox(width: 8),
            OutlinedButton.icon(
              onPressed: () => _openDialog(),
              icon: const Icon(Icons.add),
              label: const Text('Add Role'),
            ),
          ],
        ),
        const SizedBox(height: 16),
        Expanded(
          child: SingleChildScrollView(
            scrollDirection: Axis.vertical,
            child: DataTable(
              headingTextStyle: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
              dataTextStyle: const TextStyle(color: Colors.white),
              columns: const [
                DataColumn(label: Text('Role ID')),
                DataColumn(label: Text('Permissions')),
                DataColumn(label: Text('Description')),
                DataColumn(label: Text('Actions')),
              ],
              rows: _roles.map((r) {
                return DataRow(
                  cells: [
                    DataCell(Text(r.roleId)),
                    DataCell(Text(r.permissions.join(', '))),
                    DataCell(
                      Tooltip(
                        message: r.description,
                        child: Text(
                          r.description.isEmpty
                              ? 'â€”'
                              : (r.description.length > 40
                                  ? '${r.description.substring(0, 40)}â€¦'
                                  : r.description),
                        ),
                      ),
                    ),
                    DataCell(
                      Row(
                        children: [
                          IconButton(
                            icon: const Icon(Icons.edit,
                                size: 18, color: Colors.cyan),
                            onPressed: () => _openDialog(existing: r),
                          ),
                          IconButton(
                            icon: const Icon(Icons.delete,
                                size: 18, color: Colors.redAccent),
                            onPressed: () {
                              setState(() {
                                _roles.removeWhere(
                                    (x) => x.roleId == r.roleId);
                              });
                            },
                          ),
                        ],
                      ),
                    ),
                  ],
                );
              }).toList(),
            ),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabasemodel.dart
// lib/Screen/Developer/UserDatabase/userdatabasemodel.dart

class CSVUserData {
  String email;
  String password;
  String fullName;
  String nodeId;
  int level;
  String designation;
  String employeeType; // New 7th Column

  CSVUserData({
    required this.email,
    required this.password,
    required this.fullName,
    required this.nodeId,
    required this.level,
    required this.designation,
    required this.employeeType,
  });

  factory CSVUserData.fromCSVRow(List<String> row) {
    // Now requires 7 columns
    if (row.length < 7) {
      throw Exception('CSV row must have 7 columns: email, password, fullName, nodeId, level, designation, employeeType');
    }
    return CSVUserData(
      email: row[0].trim(),
      password: row[1].trim(),
      fullName: row[2].trim(),
      nodeId: row[3].trim(),
      level: int.tryParse(row[4].trim()) ?? 0,
      designation: row[5].trim(),
      employeeType: row[6].trim(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'email': email,
      'password': password,
      'fullName': fullName,
      'nodeId': nodeId,
      'level': level,
      'designation': designation,
      'employeeType': employeeType,
    };
  }
}

/// Helper class to store Old vs New values for UI display
class UserDiff {
  final String email;
  final Map<String, Map<String, dynamic>> changes; // Key: fieldName, Value: {'old': ..., 'new': ...}

  UserDiff({required this.email, required this.changes});
}

class ValidationResult {
  bool isValid;
  List<String> errors;
  List<String> warnings;
  List<String> validNodeIds;
  List<String> invalidNodeIds;
  
  // Lists for processing
  List<CSVUserData> newUsers;
  List<CSVUserData> usersToUpdate;
  List<CSVUserData> authConflicts;
  List<UserDiff> diffs; // Specific changes for the UI

  ValidationResult({
    required this.isValid,
    required this.errors,
    required this.warnings,
    required this.validNodeIds,
    required this.invalidNodeIds,
    required this.newUsers,
    required this.usersToUpdate,
    required this.diffs,
    required this.authConflicts
  });
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabasepanel.dart
// lib/Screen/Developer/UserDatabase/userdatabasepanel.dart

import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:csv/csv.dart';
import 'dart:io';
import 'userdatabaserepository.dart';
import 'userdatabasemodel.dart';

class UserDatabasePanel extends StatefulWidget {
  const UserDatabasePanel({super.key});

  @override
  State<UserDatabasePanel> createState() => _UserDatabasePanelState();
}

class _UserDatabasePanelState extends State<UserDatabasePanel> {
  // Ensure this matches your Firestore structure exactly
  static const String tenantId = 'default_tenant'; 
  final UserDatabaseRepository repo = UserDatabaseRepository();

  List<Map<String, dynamic>> hierarchyNodes = [];
  String? selectedNodeId;
  List<Map<String, dynamic>> nodeUsers = [];
  bool loading = false;
  String? status;
  Color statusColor = Colors.greenAccent;

  @override
  void initState() {
    super.initState();
    print("--- UI DEBUG: Init State - Loading Hierarchy for $tenantId ---");
    loadHierarchy();
  }

  Future<void> loadHierarchy() async {
    setState(() => loading = true);
    try {
      final nodes = await repo.loadHierarchyWithUserCounts(tenantId);
      print("--- UI DEBUG: Hierarchy Loaded - ${nodes.length} nodes found ---");
      setState(() {
        hierarchyNodes = nodes;
        status = 'Loaded ${nodes.length} nodes';
        statusColor = Colors.greenAccent;
      });
    } catch (e) {
      print("--- UI DEBUG: Hierarchy Error: $e ---");
      setState(() {
        status = 'Error: $e';
        statusColor = Colors.redAccent;
      });
    } finally {
      setState(() => loading = false);
    }
  }

  Future<void> loadNodeUsers(String nodeId) async {
    print("--- UI DEBUG: Loading Users for Node ID: $nodeId ---");
    setState(() => loading = true);
    try {
      final users = await repo.loadUsersByNode(tenantId, nodeId);
      print("--- UI DEBUG: Node Users Loaded - ${users.length} users found ---");
      setState(() {
        selectedNodeId = nodeId;
        nodeUsers = users;
        status = 'Loaded ${users.length} users';
        statusColor = Colors.greenAccent;
      });
    } catch (e) {
      print("--- UI DEBUG: Node User Error: $e ---");
      setState(() {
        status = 'Error: $e';
        statusColor = Colors.redAccent;
      });
    } finally {
      setState(() => loading = false);
    }
  }

  Future<void> pickAndUploadCSV() async {
    try {
      print("--- UI DEBUG: STARTING CSV PICK ---");
      
      // Pick CSV file
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['csv'],
        withData: true,
      );

      if (result == null || result.files.isEmpty) {
        print("--- UI DEBUG: File Picker Cancelled ---");
        return;
      }

      final csvData = result.files.first.bytes;
      if (csvData == null) {
        print("--- UI DEBUG: Failed to read bytes from file ---");
        showError('Failed to read file');
        return;
      }

      // Parse CSV
      final csvString = String.fromCharCodes(csvData);
      print("--- UI DEBUG: CSV Raw String Length: ${csvString.length} ---");
      
      final List<List<dynamic>> csvTable =
          const CsvToListConverter().convert(csvString);

      print("--- UI DEBUG: CSV Parsed Rows: ${csvTable.length} ---");

      if (csvTable.isEmpty || csvTable.length < 2) {
        showError('CSV file is empty or has no data rows');
        return;
      }

      // Skip header row and parse
      final List<CSVUserData> users = [];
      for (int i = 1; i < csvTable.length; i++) {
        try {
          final row = csvTable[i].map((e) => e.toString()).toList();
          if (row.every((e) => e.trim().isEmpty)) continue; // Skip empty lines
          users.add(CSVUserData.fromCSVRow(row));
        } catch (e) {
          print("--- UI DEBUG: Error parsing row ${i + 1}: $e ---");
          showError('Error parsing row ${i + 1}: $e');
          return;
        }
      }

      print("--- UI DEBUG: Successfully parsed ${users.length} User Objects ---");
      if (users.isNotEmpty) {
        print("--- UI DEBUG: Sample User 1 Email: ${users.first.email} ---");
        print("--- UI DEBUG: Sample User 1 Node: ${users.first.nodeId} ---");
      }

      if (users.isEmpty) {
        showError('No valid users found in CSV');
        return;
      }

      // Validate CSV data
      setState(() {
        loading = true;
        status = 'Validating ${users.length} users...';
      });

      print("--- UI DEBUG: Calling Repo validateCSVData ---");
      final validation = await repo.validateCSVData(tenantId, users);

      print("--- UI DEBUG: VALIDATION RETURNED ---");
      print("   > IsValid: ${validation.isValid}");
      print("   > New Users: ${validation.newUsers.length}");
      print("   > Updates: ${validation.usersToUpdate.length}");
      print("   > Diffs Found: ${validation.diffs.length}");
      print("   > Errors: ${validation.errors.length}");

      setState(() => loading = false);

      if (!validation.isValid) {
        showValidationErrorDialog(validation);
        return;
      }

      // Show the Diff Review Dialog instead of simple confirmation
      showDiffReviewDialog(validation);

    } catch (e) {
      print("--- UI DEBUG: FATAL EXCEPTION IN PICKER: $e ---");
      showError('Failed to process CSV: $e');
    }
  }

  void showValidationErrorDialog(ValidationResult validation) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF111118),
        title: const Row(
          children: [
            Icon(Icons.error_outline, color: Colors.redAccent),
            SizedBox(width: 12),
            Text('CSV Validation Failed', style: TextStyle(color: Colors.white)),
          ],
        ),
        content: SizedBox(
          width: 600,
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Found ${validation.errors.length} errors:',
                  style: const TextStyle(
                    color: Colors.redAccent,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 12),
                ...validation.errors.map(
                  (error) => Padding(
                    padding: const EdgeInsets.only(bottom: 8.0),
                    child: Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text('â€¢ ', style: TextStyle(color: Colors.red)),
                        Expanded(
                          child: Text(
                            error,
                            style: const TextStyle(color: Colors.white70),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (validation.warnings.isNotEmpty) ...[
                  const SizedBox(height: 16),
                  Text(
                    '${validation.warnings.length} warnings:',
                    style: const TextStyle(
                      color: Colors.orangeAccent,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 8),
                  ...validation.warnings.take(5).map(
                    (warning) => Padding(
                      padding: const EdgeInsets.only(bottom: 8.0),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text('âš  ',
                              style: TextStyle(color: Colors.orange)),
                          Expanded(
                            child: Text(
                              warning,
                              style: const TextStyle(color: Colors.white70),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (validation.warnings.length > 5)
                     Padding(
                       padding: const EdgeInsets.only(left: 20),
                       child: Text(
                         '...and ${validation.warnings.length - 5} more warnings',
                         style: const TextStyle(color: Colors.white30, fontStyle: FontStyle.italic),
                       ),
                     )
                ],
              ],
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close', style: TextStyle(color: Colors.cyan)),
          ),
        ],
      ),
    );
  }

  void showDiffReviewDialog(ValidationResult validation) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => DiffReviewDialog(
        validation: validation,
        onConfirm: () {
          Navigator.pop(context);
          // Only import NEW and UPDATES. Skip Conflicts.
          importUsers([...validation.newUsers, ...validation.usersToUpdate]);
        },
      ),
    );
  }

  Future<void> importUsers(List<CSVUserData> users) async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => ImportProgressDialog(
        tenantId: tenantId,
        users: users,
        repo: repo,
        onComplete: () {
          print("--- UI DEBUG: Import Completed, Refreshing Data ---");
          loadHierarchy();
          if (selectedNodeId != null) {
            loadNodeUsers(selectedNodeId!);
          }
        },
      ),
    );
  }

  void showError(String message) {
    setState(() {
      status = message;
      statusColor = Colors.redAccent;
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.redAccent,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header
        Row(
          children: [
            const Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'User Database',
                    style: TextStyle(
                      fontSize: 24,
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  SizedBox(height: 8),
                  Text(
                    'Import users (New or Update) via CSV',
                    style: TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            ),
            // Upload button on top right
            FilledButton.icon(
              onPressed: loading ? null : pickAndUploadCSV,
              icon: const Icon(Icons.upload_file),
              label: const Text('Upload CSV'),
              style: FilledButton.styleFrom(
                backgroundColor: Colors.cyan,
                foregroundColor: Colors.black,
              ),
            ),
          ],
        ),
        const SizedBox(height: 16),

        // Status bar
        if (status != null)
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: statusColor.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: statusColor.withOpacity(0.3)),
            ),
            child: Row(
              children: [
                Icon(Icons.info_outline, color: statusColor, size: 16),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    status!,
                    style: TextStyle(color: statusColor, fontSize: 12),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close, size: 16),
                  onPressed: () => setState(() => status = null),
                  color: statusColor,
                ),
              ],
            ),
          ),
        const SizedBox(height: 16),

        // Main content
        Expanded(
          child: Row(
            children: [
              // Left: Hierarchy tree
              SizedBox(
                width: 320,
                child: Card(
                  color: const Color(0xFF111118),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Row(
                          children: [
                            const Text(
                              'Organization Hierarchy',
                              style: TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                                fontSize: 16,
                              ),
                            ),
                            const Spacer(),
                            IconButton(
                              icon: const Icon(Icons.refresh, size: 18),
                              onPressed: loading ? null : loadHierarchy,
                              color: Colors.cyan,
                            ),
                          ],
                        ),
                      ),
                      const Divider(color: Colors.white12, height: 1),
                      Expanded(
                        child: loading && hierarchyNodes.isEmpty
                            ? const Center(
                                child: CircularProgressIndicator(
                                  color: Colors.cyan,
                                ),
                              )
                            : hierarchyNodes.isEmpty
                                ? const Center(
                                    child: Text(
                                      'No nodes found',
                                      style:
                                          TextStyle(color: Colors.white70),
                                    ),
                                  )
                                : ListView.builder(
                                    itemCount: hierarchyNodes.length,
                                    itemBuilder: (context, index) {
                                      final node = hierarchyNodes[index];
                                      final isSelected =
                                          selectedNodeId == node['id'];
                                      return ListTile(
                                        selected: isSelected,
                                        selectedTileColor:
                                            const Color(0xFF1A1A25),
                                        leading: Icon(
                                          Icons.account_tree_rounded,
                                          color: isSelected
                                              ? Colors.cyan
                                              : Colors.grey,
                                          size: 20,
                                        ),
                                        title: Text(
                                          node['name'] ?? 'Unknown',
                                          style: TextStyle(
                                            color: isSelected
                                                ? Colors.cyan
                                                : Colors.white,
                                            fontWeight: isSelected
                                                ? FontWeight.bold
                                                : FontWeight.normal,
                                          ),
                                        ),
                                        subtitle: Text(
                                          'Level ${node['level']} â€¢ ${node['userCount'] ?? 0} users',
                                          style: const TextStyle(
                                            color: Colors.white54,
                                            fontSize: 11,
                                          ),
                                        ),
                                        onTap: () =>
                                            loadNodeUsers(node['id']),
                                      );
                                    },
                                  ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(width: 16),

              // Right: Node users
              Expanded(
                child: Card(
                  color: const Color(0xFF111118),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(16.0),
                        child: Text(
                          selectedNodeId == null
                              ? 'Select a node to view users'
                              : 'Users in ${hierarchyNodes.firstWhere(
                                  (n) => n['id'] == selectedNodeId,
                                  orElse: () => {'name': 'Node'},
                                )['name']}',
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.bold,
                            fontSize: 16,
                          ),
                        ),
                      ),
                      const Divider(color: Colors.white12, height: 1),
                      Expanded(
                        child: selectedNodeId == null
                            ? const Center(
                                child: Column(
                                  mainAxisAlignment:
                                      MainAxisAlignment.center,
                                  children: [
                                    Icon(
                                      Icons.arrow_back,
                                      size: 48,
                                      color: Colors.white24,
                                    ),
                                    SizedBox(height: 16),
                                    Text(
                                      'Click a node on the left',
                                      style:
                                          TextStyle(color: Colors.white54),
                                    ),
                                  ],
                                ),
                              )
                            : loading
                                ? const Center(
                                    child: CircularProgressIndicator(
                                      color: Colors.cyan,
                                    ),
                                  )
                                : nodeUsers.isEmpty
                                    ? const Center(
                                        child: Text(
                                          'No users in this node',
                                          style: TextStyle(
                                              color: Colors.white70),
                                        ),
                                      )
                                    : ListView.separated(
                                        itemCount: nodeUsers.length,
                                        separatorBuilder: (_, __) =>
                                            const Divider(
                                                color: Colors.white12),
                                        itemBuilder: (context, index) {
                                          final user = nodeUsers[index];
                                          final profile =
                                              user['profiledata']
                                                      as Map? ??
                                                  {};

                                          return ListTile(
                                            leading: CircleAvatar(
                                              backgroundColor: Colors.cyan
                                                  .withOpacity(0.2),
                                              child: Text(
                                                (profile['fullName'] ??
                                                        'U')
                                                    .toString()[0]
                                                    .toUpperCase(),
                                                style: const TextStyle(
                                                  color: Colors.cyan,
                                                ),
                                              ),
                                            ),
                                            title: Text(
                                              profile['fullName'] ??
                                                  'Unknown',
                                              style: const TextStyle(
                                                color: Colors.white,
                                              ),
                                            ),
                                            subtitle: Column(
                                              crossAxisAlignment:
                                                  CrossAxisAlignment
                                                      .start,
                                              mainAxisSize:
                                                  MainAxisSize.min,
                                              children: [
                                                if ((user['designation'] ??
                                                            '')
                                                        .toString()
                                                        .isNotEmpty)
                                                  Text(
                                                    '${user['designation']} â€¢ ${user['employeeType'] ?? 'N/A'}',
                                                    style:
                                                        const TextStyle(
                                                      color:
                                                          Colors.white70,
                                                      fontSize: 12,
                                                    ),
                                                  ),
                                                Text(
                                                  profile['email'] ?? '',
                                                  style:
                                                      const TextStyle(
                                                    color: Colors.white70,
                                                    fontSize: 12,
                                                  ),
                                                ),
                                              ],
                                            ),
                                            trailing: Container(
                                              padding:
                                                  const EdgeInsets
                                                      .symmetric(
                                                horizontal: 8,
                                                vertical: 4,
                                              ),
                                              decoration: BoxDecoration(
                                                color: Colors.greenAccent
                                                    .withOpacity(0.2),
                                                borderRadius:
                                                    BorderRadius.circular(
                                                        12),
                                              ),
                                              child: Text(
                                                user['status'] ??
                                                    'active',
                                                style:
                                                    const TextStyle(
                                                  color:
                                                      Colors.greenAccent,
                                                  fontSize: 11,
                                                ),
                                              ),
                                            ),
                                          );
                                        },
                                      ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// -----------------------------------------------------------------------------
// NEW WIDGETS START HERE
// -----------------------------------------------------------------------------

class DiffReviewDialog extends StatefulWidget {
  final ValidationResult validation;
  final VoidCallback onConfirm;

  const DiffReviewDialog({
    super.key,
    required this.validation,
    required this.onConfirm,
  });

  @override
  State<DiffReviewDialog> createState() => _DiffReviewDialogState();
}

class _DiffReviewDialogState extends State<DiffReviewDialog> {
  String searchQuery = "";

  @override
  Widget build(BuildContext context) {
    // 1. Filter Lists based on Search Query
    final filteredDiffs = widget.validation.diffs
        .where((d) => d.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    final filteredConflicts = widget.validation.authConflicts
        .where((u) => u.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    final filteredNewUsers = widget.validation.newUsers
        .where((u) => u.email.toLowerCase().contains(searchQuery.toLowerCase()))
        .toList();

    return AlertDialog(
      backgroundColor: const Color(0xFF111118),
      title: const Row(
        children: [
          Icon(Icons.rate_review, color: Colors.cyan),
          SizedBox(width: 12),
          Text('Review Import Data', style: TextStyle(color: Colors.white)),
        ],
      ),
      content: SizedBox(
        width: 600,
        height: 500,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 2. Summary Stats Badge Row
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                children: [
                  _statBadge(
                      'Total',
                      widget.validation.newUsers.length +
                          widget.validation.usersToUpdate.length +
                          widget.validation.authConflicts.length,
                      Colors.white),
                  const SizedBox(width: 8),
                  _statBadge('New', widget.validation.newUsers.length,
                      Colors.greenAccent),
                  const SizedBox(width: 8),
                  _statBadge('Updates', widget.validation.usersToUpdate.length,
                      Colors.orangeAccent),
                  const SizedBox(width: 8),
                  _statBadge('Conflicts', widget.validation.authConflicts.length,
                      Colors.redAccent),
                ],
              ),
            ),
            const SizedBox(height: 16),

            // 3. Search Bar
            TextField(
              style: const TextStyle(color: Colors.white),
              decoration: InputDecoration(
                filled: true,
                fillColor: Colors.white.withOpacity(0.05),
                hintText: 'Search by email...',
                hintStyle: const TextStyle(color: Colors.white30),
                prefixIcon: const Icon(Icons.search, color: Colors.cyan),
                border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide.none),
                contentPadding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              ),
              onChanged: (val) => setState(() => searchQuery = val),
            ),
            const SizedBox(height: 16),

            // 4. Scrollable Content List
            Expanded(
              child: ListView(
                children: [
                  // --- SECTION: CONFLICTS (Red) ---
                  if (filteredConflicts.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("âš  Auth Conflicts (Skipped)",
                          style: TextStyle(
                              color: Colors.redAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    ...filteredConflicts.map((u) => Container(
                          margin: const EdgeInsets.only(bottom: 4),
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 8),
                          decoration: BoxDecoration(
                              color: Colors.redAccent.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(4),
                              border: Border.all(
                                  color: Colors.redAccent.withOpacity(0.3))),
                          child: Row(
                            children: [
                              const Icon(Icons.warning_amber_rounded,
                                  color: Colors.redAccent, size: 16),
                              const SizedBox(width: 8),
                              Expanded(
                                  child: Text(u.email,
                                      style: const TextStyle(
                                          color: Colors.white70))),
                              const Text("Exists in Auth only",
                                  style: TextStyle(
                                      color: Colors.white30, fontSize: 10)),
                            ],
                          ),
                        )),
                    const SizedBox(height: 16),
                  ],

                  // --- SECTION: UPDATES (Orange) ---
                  if (filteredDiffs.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("Updates",
                          style: TextStyle(
                              color: Colors.orangeAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    ...filteredDiffs.map((diff) => Container(
                          margin: const EdgeInsets.only(bottom: 8),
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.05),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                                color: Colors.orangeAccent.withOpacity(0.3)),
                          ),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  const Icon(Icons.edit,
                                      color: Colors.orangeAccent, size: 14),
                                  const SizedBox(width: 8),
                                  Text(diff.email,
                                      style: const TextStyle(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold)),
                                ],
                              ),
                              const Divider(color: Colors.white10),
                              ...diff.changes.entries.map((e) => Padding(
                                    padding: const EdgeInsets.symmetric(
                                        vertical: 2.0),
                                    child: Row(
                                      children: [
                                        Text('${e.key}: ',
                                            style: const TextStyle(
                                                color: Colors.white54,
                                                fontSize: 12)),
                                        Text('${e.value['old']}',
                                            style: const TextStyle(
                                                color: Colors.redAccent,
                                                decoration:
                                                    TextDecoration.lineThrough,
                                                fontSize: 12)),
                                        const Padding(
                                          padding: EdgeInsets.symmetric(
                                              horizontal: 4),
                                          child: Icon(Icons.arrow_right_alt,
                                              color: Colors.white30, size: 14),
                                        ),
                                        Text('${e.value['new']}',
                                            style: const TextStyle(
                                                color: Colors.greenAccent,
                                                fontWeight: FontWeight.bold,
                                                fontSize: 12)),
                                      ],
                                    ),
                                  )),
                            ],
                          ),
                        )),
                    const SizedBox(height: 16),
                  ],

                  // --- SECTION: NEW USERS (Green) ---
                  if (filteredNewUsers.isNotEmpty) ...[
                    const Padding(
                      padding: EdgeInsets.only(bottom: 8.0),
                      child: Text("New Users",
                          style: TextStyle(
                              color: Colors.greenAccent,
                              fontWeight: FontWeight.bold)),
                    ),
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.greenAccent.withOpacity(0.05),
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                            color: Colors.greenAccent.withOpacity(0.2)),
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          if (searchQuery.isEmpty)
                            Padding(
                              padding: const EdgeInsets.all(8.0),
                              child: Text(
                                  "Ready to create ${filteredNewUsers.length} new users.",
                                  style: const TextStyle(color: Colors.white70)),
                            ),
                          // List individual new users
                          ...filteredNewUsers.map((u) => Padding(
                                padding: const EdgeInsets.symmetric(
                                    vertical: 4, horizontal: 8),
                                child: Row(
                                  children: [
                                    const Icon(Icons.add_circle_outline,
                                        color: Colors.greenAccent, size: 14),
                                    const SizedBox(width: 8),
                                    Text(u.email,
                                        style: const TextStyle(
                                            color: Colors.white60,
                                            fontSize: 12)),
                                  ],
                                ),
                              )),
                        ],
                      ),
                    ),
                  ],

                  // Empty State
                  if (filteredConflicts.isEmpty &&
                      filteredDiffs.isEmpty &&
                      filteredNewUsers.isEmpty)
                    const Center(
                      child: Padding(
                        padding: EdgeInsets.all(32.0),
                        child: Text("No matches found.",
                            style: TextStyle(color: Colors.white30)),
                      ),
                    )
                ],
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text('Cancel', style: TextStyle(color: Colors.white54)),
        ),
        FilledButton.icon(
          onPressed: widget.onConfirm,
          icon: const Icon(Icons.check, size: 18),
          label: const Text('Confirm & Sync'),
          style: FilledButton.styleFrom(
              backgroundColor: Colors.cyan, foregroundColor: Colors.black),
        ),
      ],
    );
  }

  Widget _statBadge(String label, int count, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: color.withOpacity(0.3))),
      child: Row(
        children: [
          Icon(Icons.circle, size: 8, color: color),
          const SizedBox(width: 8),
          Text('$label: $count',
              style: TextStyle(
                  color: color, fontWeight: FontWeight.bold, fontSize: 12)),
        ],
      ),
    );
  }
}

class ImportProgressDialog extends StatefulWidget {
  final String tenantId;
  final List<CSVUserData> users;
  final UserDatabaseRepository repo;
  final VoidCallback onComplete;

  const ImportProgressDialog({
    super.key,
    required this.tenantId,
    required this.users,
    required this.repo,
    required this.onComplete,
  });

  @override
  State<ImportProgressDialog> createState() => _ImportProgressDialogState();
}

class _ImportProgressDialogState extends State<ImportProgressDialog> {
  int current = 0;
  int total = 0;
  String message = '';
  bool isComplete = false;
  Map<String, dynamic>? result;

  @override
  void initState() {
    super.initState();
    total = widget.users.length;
    startImport();
  }

  Future<void> startImport() async {
    final res = await widget.repo.importUsers(
      widget.tenantId,
      widget.users,
      (curr, tot, msg) {
        setState(() {
          current = curr;
          total = tot;
          message = msg;
        });
      },
    );

    setState(() {
      isComplete = true;
      result = res;
    });
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: const Color(0xFF111118),
      title: Row(
        children: [
          if (!isComplete)
            const SizedBox(
              width: 24,
              height: 24,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                color: Colors.cyan,
              ),
            )
          else
            const Icon(Icons.check_circle, color: Colors.greenAccent),
          const SizedBox(width: 12),
          Text(
            isComplete ? 'Import Complete' : 'Importing Users...',
            style: const TextStyle(color: Colors.white),
          ),
        ],
      ),
      content: SizedBox(
        width: 400,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (!isComplete) ...[
              LinearProgressIndicator(
                value: total > 0 ? current / total : 0,
                backgroundColor: Colors.white12,
                color: Colors.cyan,
              ),
              const SizedBox(height: 16),
              Text(
                'Progress: $current / $total',
                style: const TextStyle(color: Colors.white70),
              ),
              const SizedBox(height: 8),
              Text(
                message,
                style: const TextStyle(
                  color: Colors.white54,
                  fontSize: 12,
                ),
              ),
            ] else ...[
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.greenAccent.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'âœ“ Successfully imported: ${result!['success']}',
                      style: const TextStyle(
                        color: Colors.greenAccent,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    if (result!['failed'] > 0) ...[
                      const SizedBox(height: 8),
                      Text(
                        'âœ— Failed: ${result!['failed']}',
                        style: const TextStyle(color: Colors.redAccent),
                      ),
                    ],
                  ],
                ),
              ),
              if (result!['failedUsers'].isNotEmpty) ...[
                const SizedBox(height: 16),
                const Text(
                  'Failed users:',
                  style: TextStyle(
                    color: Colors.redAccent,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                SizedBox(
                  height: 150,
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children:
                          (result!['failedUsers'] as List<String>).map(
                        (e) {
                          return Padding(
                            padding:
                                const EdgeInsets.only(bottom: 4.0),
                            child: Text(
                              'â€¢ $e',
                              style: const TextStyle(
                                color: Colors.white70,
                                fontSize: 11,
                              ),
                            ),
                          );
                        },
                      ).toList(),
                    ),
                  ),
                ),
              ],
            ],
          ],
        ),
      ),
      actions: [
        if (isComplete)
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              widget.onComplete();
            },
            child: const Text('Close'),
          ),
      ],
    );
  }
}

================================================================================

// File: lib\Developer\UserDatabase\userdatabaserepository.dart
// lib/Screen/Developer/UserDatabase/userdatabaserepository.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'userdatabasemodel.dart';

class UserDatabaseRepository {
  final FirebaseFirestore db;
  final FirebaseAuth auth = FirebaseAuth.instance;
  static const int RATE_LIMIT_DELAY_MS = 200; // Delay between operations

  UserDatabaseRepository({FirebaseFirestore? db})
      : db = db ?? FirebaseFirestore.instance;

  /// Validate CSV and separate New Users from Updates with Diff logic
  Future<ValidationResult> validateCSVData(
    String tenantId,
    List<CSVUserData> users,
  ) async {
    print("--- DEBUG: STARTING VALIDATION ---");
    
    List<String> errors = [];
    List<String> warnings = [];
    Set<String> validNodeIds = {};
    Set<String> invalidNodeIds = {};

    List<CSVUserData> newUsers = [];
    List<CSVUserData> usersToUpdate = [];
    List<CSVUserData> authConflicts = [];
    List<UserDiff> diffs = [];

    // 1. ---------- LOAD NODES ----------
    final nodesPath = 'tenants/$tenantId/organizations/hierarchy/nodes';
    final nodesSnap = await db.collection(nodesPath).get();
    final existingNodeIds = nodesSnap.docs.map((doc) => doc.id).toSet();

    // 2. ---------- LOAD EXISTING USERS (FETCH ALL STRATEGY) ----------
    Map<String, Map<String, dynamic>> existingFirestoreUsers = {};
    final userPath = 'tenants/$tenantId/users';
    
    print("DEBUG: Fetching ALL users to normalize email case...");
    final allUsersSnap = await db.collection(userPath).get();

    for (var doc in allUsersSnap.docs) {
      final data = doc.data();
      dynamic emailRaw = data['profiledata'] != null 
          ? (data['profiledata'] as Map)['email'] 
          : null;

      if (emailRaw != null) {
        String emailKey = emailRaw.toString().trim().toLowerCase();
        existingFirestoreUsers[emailKey] = {'id': doc.id, ...data};
      }
    }
    
    // 3. ---------- PROCESS CSV ROWS ----------
    Set<String> processedEmails = {};

    for (int i = 0; i < users.length; i++) {
      final user = users[i];
      final rowNum = i + 2;
      final emailLower = user.email.trim().toLowerCase();

      if (!RegExp(r'^[^@]+@[^@]+\.[^@]+').hasMatch(user.email)) {
        errors.add('Row $rowNum: Invalid email - ${user.email}');
        continue;
      }

      if (processedEmails.contains(emailLower)) {
        warnings.add('Row $rowNum: Duplicate skipped - ${user.email}');
        continue;
      }
      processedEmails.add(emailLower);

      if (user.nodeId.isEmpty) errors.add('Row $rowNum: Node ID required');
      else if (existingNodeIds.contains(user.nodeId)) validNodeIds.add(user.nodeId);
      else {
        invalidNodeIds.add(user.nodeId);
        errors.add('Row $rowNum: Invalid Node ID "${user.nodeId}"');
      }

      if (errors.any((e) => e.startsWith('Row $rowNum'))) continue;

      // 4. ---------- COMPARE ----------
      if (existingFirestoreUsers.containsKey(emailLower)) {
        // UPDATE CASE
        final existing = existingFirestoreUsers[emailLower]!;
        Map<String, Map<String, dynamic>> fieldChanges = {};

        void checkChange(String field, dynamic newVal, dynamic oldVal) {
          if (newVal.toString() != oldVal.toString()) {
            fieldChanges[field] = {'old': oldVal, 'new': newVal};
          }
        }

        checkChange('fullName', user.fullName, existing['profiledata']?['fullName'] ?? '');
        checkChange('designation', user.designation, existing['designation'] ?? '');
        checkChange('employeeType', user.employeeType, existing['employeeType'] ?? ''); // New Field
        checkChange('nodeId', user.nodeId, existing['nodeId'] ?? '');
        checkChange('level', user.level, existing['level'] ?? 0);

        if (fieldChanges.isNotEmpty) {
          usersToUpdate.add(user);
          diffs.add(UserDiff(email: user.email, changes: fieldChanges));
        } else {
          warnings.add('${user.email} is up to date.');
        }
      } else {
        // NEW CASE
        try {
          final methods = await auth.fetchSignInMethodsForEmail(user.email);
          if (methods.isNotEmpty) {
            authConflicts.add(user);
            warnings.add('User ${user.email} exists in Auth but not DB.');
          } else {
            newUsers.add(user);
          }
        } catch (e) {
          newUsers.add(user); 
        }
      }
    }

    return ValidationResult(
      isValid: errors.isEmpty,
      errors: errors,
      warnings: warnings,
      validNodeIds: validNodeIds.toList(),
      invalidNodeIds: invalidNodeIds.toList(),
      newUsers: newUsers,
      usersToUpdate: usersToUpdate,
      authConflicts: authConflicts,
      diffs: diffs,
    );
  }

  /// IMPORT OR UPDATE USERS 
  /// FIXED: Now uses pre-fetched Map to ensure Case-Insensitive matching works
  Future<Map<String, dynamic>> importUsers(
    String tenantId,
    List<CSVUserData> users,
    Function(int current, int total, String message) progressCallback,
  ) async {
    int successCount = 0;
    int failureCount = 0;
    List<String> failedUsers = [];

    // ---------------------------------------------------------
    // STEP 1: PRE-FETCH EXISTING USERS TO MAP (THE FIX)
    // ---------------------------------------------------------
    // We must build the same map as validation to find the Doc IDs
    // regardless of whether the email is stored as "Sanjay" or "sanjay".
    Map<String, String> emailToDocIdMap = {};
    
    try {
      final userPath = 'tenants/$tenantId/users';
      final allUsersSnap = await db.collection(userPath).get();
      
      for (var doc in allUsersSnap.docs) {
        final data = doc.data();
        dynamic emailRaw = data['profiledata'] != null 
            ? (data['profiledata'] as Map)['email'] 
            : null;
        if (emailRaw != null) {
          // KEY = Lowercase Email, VALUE = Document ID
          emailToDocIdMap[emailRaw.toString().trim().toLowerCase()] = doc.id;
        }
      }
      print("DEBUG: Import Loop - Mapped ${emailToDocIdMap.length} existing users for lookup.");
    } catch (e) {
      print("DEBUG: Error mapping existing users: $e");
    }

    // ---------------------------------------------------------
    // STEP 2: PROCESS USERS
    // ---------------------------------------------------------
    for (int i = 0; i < users.length; i++) {
      final user = users[i];
      final emailLower = user.email.trim().toLowerCase();
      
      progressCallback(i + 1, users.length, 'Syncing ${user.email}...');

      if (i > 0 && i % 10 == 0) await Future.delayed(const Duration(milliseconds: RATE_LIMIT_DELAY_MS));

      try {
        // CHECK MAP INSTEAD OF QUERYING DB AGAIN
        if (emailToDocIdMap.containsKey(emailLower)) {
          // ============================================
          // UPDATE EXISTING USER
          // ============================================
          final docId = emailToDocIdMap[emailLower]!;
          
          print("DEBUG: Updating existing user $docId (${user.email})");
          
          await db.collection('tenants/$tenantId/users').doc(docId).update({
            'profiledata.fullName': user.fullName,
            'designation': user.designation,
            'employeeType': user.employeeType, // This will now correctly update
            'nodeId': user.nodeId,
            'level': user.level,
            // DO NOT update status or password here
          });
          
          successCount++;
        } else {
          // ============================================
          // CREATE NEW USER
          // ============================================
          print("DEBUG: Creating NEW user (${user.email})");
          
          UserCredential? credential;
          try {
            credential = await FirebaseAuth.instance.createUserWithEmailAndPassword(
              email: user.email,
              password: user.password,
            );

            final userId = credential.user!.uid;
            await db.collection('tenants/$tenantId/users').doc(userId).set({
              'profiledata': {
                'email': user.email,
                'fullName': user.fullName,
              },
              'designation': user.designation,
              'employeeType': user.employeeType, // New Field
              'status': 'active',
              'createdat': FieldValue.serverTimestamp(),
              'nodeId': user.nodeId,
              'level': user.level,
              'importedFromCSV': true,
            });
            successCount++;

          } on FirebaseAuthException catch (e) {
            if (e.code == 'email-already-in-use') {
              failureCount++;
              failedUsers.add('${user.email}: Exists in Auth but missing in DB (Conflict)');
            } else {
              rethrow;
            }
          }
        }
      } catch (e) {
        failureCount++;
        failedUsers.add('${user.email}: $e');
        print("DEBUG: Error processing ${user.email}: $e");
      }
    }

    return {
      'success': successCount,
      'failed': failureCount,
      'failedUsers': failedUsers,
    };
  }

  /// Load users for a node from tenants/{tenantId}/users
  Future<List<Map<String, dynamic>>> loadUsersByNode(
    String tenantId,
    String nodeId,
  ) async {
    final snap = await db
        .collection('tenants/$tenantId/users')
        .where('nodeId', isEqualTo: nodeId)
        .orderBy('createdat', descending: true)
        .get();

    return snap.docs.map((d) => {'id': d.id, ...d.data()}).toList();
  }

  /// Load hierarchy nodes with user counts from tenants/{tenantId}/users
  Future<List<Map<String, dynamic>>> loadHierarchyWithUserCounts(
    String tenantId,
  ) async {
    final nodesSnap = await db
        .collection('tenants/$tenantId/organizations')
        .doc('hierarchy')
        .collection('nodes')
        .get();

    List<Map<String, dynamic>> nodesWithCounts = [];

    for (final nodeDoc in nodesSnap.docs) {
      final nodeId = nodeDoc.id;
      final usersSnap = await db
          .collection('tenants/$tenantId/users')
          .where('nodeId', isEqualTo: nodeId)
          .count()
          .get();

      nodesWithCounts.add({
        'id': nodeId,
        ...nodeDoc.data(),
        'userCount': usersSnap.count ?? 0,
      });
    }

    nodesWithCounts.sort((a, b) {
      final levelCmp = (a['level'] as int).compareTo(b['level'] as int);
      if (levelCmp != 0) return levelCmp;
      return (a['name'] as String).compareTo(b['name'] as String);
    });

    return nodesWithCounts;
  }
}

================================================================================

// File: lib\dynamic_screen\dashboardpanel.dart
import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import 'model/floating_widget.dart';
import 'widget_factory.dart';
import 'model/screen_grid.dart';

Widget buildGridWidget({
  required ScreenGridWidgetSpan item,
  required double cellW,
  required double cellH,
  required double maxW,
  required double maxH,
  required double initialLeft,
  required double initialTop,
  required double initialWidthPx,
  required double initialHeightPx,
  required double globalBlur,
  required double globalOpacity,
  required Color globalTint,
  required VoidCallback onSnap,
}) {
  return FreeDragResizeItem(
    key: ValueKey(item.widgetId),
    item: item,
    gridColumns: 24,
    gridRows: 14,
    cellW: cellW,
    cellH: cellH,
    maxW: maxW,
    maxH: maxH,
    initialLeft: initialLeft,
    initialTop: initialTop,
    initialWidthPx: initialWidthPx,
    initialHeightPx: initialHeightPx,
    globalBlur: globalBlur,
    globalOpacity: globalOpacity,
    globalTint: globalTint,
    onSnap: onSnap,
  );
}

/// Draggable + resizable wrapper used by the dashboard grid.
class FreeDragResizeItem extends StatefulWidget {
  final ScreenGridWidgetSpan item;
  final int gridColumns;
  final int gridRows;

  final double cellW;
  final double cellH;
  final double maxW;
  final double maxH;

  final double initialLeft;
  final double initialTop;
  final double initialWidthPx;
  final double initialHeightPx;

  final double globalBlur;
  final double globalOpacity;
  final Color globalTint;
  final VoidCallback onSnap;

  const FreeDragResizeItem({
    super.key,
    required this.item,
    required this.gridColumns,
    required this.gridRows,
    required this.cellW,
    required this.cellH,
    required this.maxW,
    required this.maxH,
    required this.initialLeft,
    required this.initialTop,
    required this.initialWidthPx,
    required this.initialHeightPx,
    required this.globalBlur,
    required this.globalOpacity,
    required this.globalTint,
    required this.onSnap,
  });

  @override
  State<FreeDragResizeItem> createState() => _FreeDragResizeItemState();
}

class _FreeDragResizeItemState extends State<FreeDragResizeItem> {
  late double left;
  late double top;
  late double widthPx;
  late double heightPx;

  Offset? dragLastGlobal;
  Offset? resizeLastGlobal;

  // ğŸ”¥ FIX: Cache widget content to avoid rebuilding on every frame
  Widget? _cachedContent;
  String? _cachedWidgetId;

  bool get isInteracting => dragLastGlobal != null || resizeLastGlobal != null;

  @override
  void initState() {
    super.initState();
    left = widget.initialLeft;
    top = widget.initialTop;
    widthPx = widget.initialWidthPx;
    heightPx = widget.initialHeightPx;
    
    // Cache the widget content
    _buildCachedContent();
  }

  @override
  void didUpdateWidget(covariant FreeDragResizeItem oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // Rebuild cached content if widget ID changed
    if (oldWidget.item.widgetId != widget.item.widgetId) {
      _buildCachedContent();
    }
    
    if (!isInteracting) {
      left = (widget.item.col * widget.cellW).clamp(0.0, widget.maxW - widget.cellW);
      top = (widget.item.row * widget.cellH).clamp(0.0, widget.maxH - widget.cellH);
      widthPx = (widget.item.colSpan * widget.cellW)
          .clamp(widget.cellW * 2, widget.maxW);
      heightPx = (widget.item.rowSpan * widget.cellH)
          .clamp(widget.cellH * 2, widget.maxH);
    }
  }

  // ğŸ”¥ FIX: Build and cache widget content once
  void _buildCachedContent() {
    _cachedWidgetId = widget.item.widgetId;
    _cachedContent = RepaintBoundary(
      child: DynamicWidgetFactory.create(widget.item.widgetId),
    );
  }

  void snapToGridAndPersist() {
    int col = (left / widget.cellW).round();
    int row = (top / widget.cellH).round();
    int colSpan = (widthPx / widget.cellW).round();
    int rowSpan = (heightPx / widget.cellH).round();

    colSpan = colSpan.clamp(2, widget.gridColumns);
    rowSpan = rowSpan.clamp(2, widget.gridRows);

    col = col.clamp(0, widget.gridColumns - colSpan);
    row = row.clamp(0, widget.gridRows - rowSpan);

    widget.item
      ..col = col
      ..row = row
      ..colSpan = colSpan
      ..rowSpan = rowSpan;

    setState(() {
      left = col * widget.cellW;
      top = row * widget.cellH;
      widthPx = colSpan * widget.cellW;
      heightPx = rowSpan * widget.cellH;
    });

    widget.onSnap();
  }

  @override
  Widget build(BuildContext context) {
    // ğŸ”¥ FIX: Use cached content instead of rebuilding every frame
    final content = _cachedContent ?? const SizedBox.shrink();

    // ğŸ”¥ FIX: Reduce blur during interaction for better performance
    final effectiveBlur = isInteracting 
        ? (widget.globalBlur * 0.5).clamp(0.0, 8.0)  // Half blur when dragging
        : widget.globalBlur;

    final glassCard = GlassContainer(
      blur: effectiveBlur,
      opacity: widget.globalOpacity,
      tint: widget.globalTint,
      borderRadius: BorderRadius.circular(24),
      child: content,
    );

    const hitHandleSize = 24.0;

    return Positioned(
      left: left.clamp(0.0, widget.maxW - widthPx),
      top: top.clamp(0.0, widget.maxH - heightPx),
      width: widthPx.clamp(widget.cellW * 2, widget.maxW),
      height: heightPx.clamp(widget.cellH * 2, widget.maxH),
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onPanStart: (details) {
          final local = details.localPosition;
          final isResize =
              local.dx > widthPx - hitHandleSize && local.dy > heightPx - hitHandleSize;
          
          setState(() {
            if (isResize) {
              resizeLastGlobal = details.globalPosition;
            } else {
              dragLastGlobal = details.globalPosition;
            }
          });
        },
        onPanUpdate: (details) {
          setState(() {
            if (resizeLastGlobal != null) {
              final delta = details.globalPosition - resizeLastGlobal!;
              widthPx = (widthPx + delta.dx)
                  .clamp(widget.cellW * 2, widget.maxW - left);
              heightPx = (heightPx + delta.dy)
                  .clamp(widget.cellH * 2, widget.maxH - top);
              resizeLastGlobal = details.globalPosition;
            } else if (dragLastGlobal != null) {
              final delta = details.globalPosition - dragLastGlobal!;
              left = (left + delta.dx).clamp(0.0, widget.maxW - widthPx);
              top = (top + delta.dy).clamp(0.0, widget.maxH - heightPx);
              dragLastGlobal = details.globalPosition;
            }
          });
        },
        onPanEnd: (_) {
          setState(() {
            dragLastGlobal = null;
            resizeLastGlobal = null;
          });
          snapToGridAndPersist();
        },
        onPanCancel: () {
          setState(() {
            dragLastGlobal = null;
            resizeLastGlobal = null;
          });
          snapToGridAndPersist();
        },
        child: Stack(
          children: [
            // ğŸ”¥ FIX: Isolate glass card repaints
            Positioned.fill(
              child: RepaintBoundary(
                child: glassCard,
              ),
            ),
            
            // Resize handle
            if (!isInteracting || resizeLastGlobal != null)
              Positioned(
                right: 4,
                bottom: 4,
                child: _ResizeHandle(
                  isActive: resizeLastGlobal != null,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

// ğŸ”¥ FIX: Extract resize handle to prevent rebuilds
class _ResizeHandle extends StatelessWidget {
  final bool isActive;

  const _ResizeHandle({required this.isActive});

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      cursor: SystemMouseCursors.resizeDownRight,
      child: Container(
        width: 24.0,
        height: 24.0,
        alignment: Alignment.bottomRight,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          width: isActive ? 16 : 14,
          height: isActive ? 16 : 14,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(4),
            color: isActive ? Colors.cyanAccent : Colors.cyanAccent.withOpacity(0.8),
            boxShadow: isActive
                ? [
                    BoxShadow(
                      color: Colors.cyanAccent.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 2,
                    ),
                  ]
                : null,
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_drawer.dart
import 'package:flutter/material.dart';

import 'repository/dashboard_repository.dart';

class DashboardDrawer extends StatelessWidget {
  final Set<String> allowedWidgetIds;
  final List items;
  // No toggle callback any more.

  const DashboardDrawer({
    super.key,
    required this.allowedWidgetIds,
    required this.items,
  });

  @override
  Widget build(BuildContext context) {
    // If you still want to hide the drawer when only login is allowed, keep this.
    if (allowedWidgetIds.length == 1 && allowedWidgetIds.contains('login')) {
      return const SizedBox.shrink();
    }

    final repo = DashboardRepository();
    final allWidgets = repo.getWidgets();

    return Positioned(
      left: 16,
      top: 64,
      bottom: 16,
      child: MouseRegion(
        opaque: false,
        child: Align(
          alignment: Alignment.topLeft,
          child: Container(
            width: 220,
            decoration: BoxDecoration(
              color: const Color(0xCC05040A),
              borderRadius: BorderRadius.circular(18),
              border: Border.all(color: Colors.white10),
            ),
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 10),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Widgets',
                  style: TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.w600,
                    fontSize: 14,
                  ),
                ),
                const SizedBox(height: 8),
                Expanded(
                  child: ListView(
                    children: [
                      for (final w in allWidgets)
                        ListTile(
                          dense: true,
                          contentPadding: EdgeInsets.zero,
                          leading: const Icon(
                            Icons.widgets,
                            size: 18,
                            color: Colors.cyanAccent,
                          ),
                          title: Text(
                            w.name,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 13,
                            ),
                          ),
                          // No switch / tap handler; purely informational.
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_grid.dart
// lib/dynamic_screen/dashboard_grid.dart
import 'package:flutter/material.dart';

import '../core/wallpaper_service.dart';
import 'model/screen_grid.dart';
import 'widgets/widgets.dart';

class DashboardGrid extends StatelessWidget {
  final ScreenGridConfig grid;
  final List<ScreenGridWidgetSpan> items;
  final VoidCallback onSnap;

  // NEW: glass settings for widgets
  final double globalBlur;
  final double globalOpacity;

  const DashboardGrid({
    super.key,
    required this.grid,
    required this.items,
    required this.onSnap,
    required this.globalBlur,
    required this.globalOpacity,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final cellW = constraints.maxWidth / grid.columns;
        final cellH = constraints.maxHeight / grid.rows;

        // No blur/opacity logic here; only pass through.
        const globalTint = Color(0xFFFFFFFF);

        return ClipRect(
          child: Stack(
            clipBehavior: Clip.hardEdge,
            children: [
              for (final item in items)
                buildGridWidget(
                  item: item,
                  cellW: cellW,
                  cellH: cellH,
                  maxW: constraints.maxWidth,
                  maxH: constraints.maxHeight,
                  initialLeft: cellW * item.col,
                  initialTop: cellH * item.row,
                  initialWidthPx: cellW * item.colSpan,
                  initialHeightPx: cellH * item.rowSpan,
                  globalBlur: globalBlur,
                  globalOpacity: globalOpacity,
                  globalTint: globalTint,
                  onSnap: onSnap,
                ),
            ],
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_layout_persistence.dart
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'model/screen_grid.dart';

class DashboardLayoutPersistence {
  static Future<void> loadLayout({
    required String prefsKey,
    required void Function(List<ScreenGridWidgetSpan>) onLoaded,
    required List<ScreenGridWidgetSpan> Function() defaultItemsBuilder,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(prefsKey);
    if (jsonString == null) {
      debugPrint('[LAYOUT] No saved layout, using defaults');
      onLoaded(defaultItemsBuilder());
      return;
    }

    try {
      final List<dynamic> decoded = jsonDecode(jsonString) as List<dynamic>;
      final loaded = decoded.map((e) {
        final m = e as Map<String, dynamic>;
        return ScreenGridWidgetSpan(
          widgetId: m['id'] as String,
          col: m['col'] as int,
          row: m['row'] as int,
          colSpan: m['colSpan'] as int,
          rowSpan: m['rowSpan'] as int,
        );
      }).toList();
      debugPrint('[LAYOUT] Loaded ${loaded.length} items');
      onLoaded(loaded);
    } catch (e) {
      debugPrint('[LAYOUT] Failed to parse layout: $e');
      onLoaded(defaultItemsBuilder());
    }
  }

  static Future<void> saveLayout({
    required String prefsKey,
    required List<ScreenGridWidgetSpan> items,
  }) async {
    final prefs = await SharedPreferences.getInstance();
    final data = items
        .map((w) => {
              'id': w.widgetId,
              'col': w.col,
              'row': w.row,
              'colSpan': w.colSpan,
              'rowSpan': w.rowSpan,
            })
        .toList();
    await prefs.setString(prefsKey, jsonEncode(data));
    debugPrint('[LAYOUT] Saved layout with ${items.length} items');
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_permissions.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

class DashboardPermissions {
  static const String _tenantId = 'default_tenant';

  /// Pure helper â€“ no setState/mounted/allowedWidgetIds inside this file.
  /// It only logs and then calls [onAllowedWidgetIds].
  static Future<void> loadUserPermissions({
    required BuildContext context,
    required String userId,
    required void Function(Set<String> allowedWidgetIds) onAllowedWidgetIds,
  }) async {
    debugPrint('[PERM] ---- loadUserPermissions START ----');
    debugPrint('[PERM] userId=$userId');

    try {
      // 1) Load user doc
      final userDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(_tenantId)
          .collection('users')
          .doc(userId)
          .get();

      debugPrint('[PERM] userDoc.exists = ${userDoc.exists}');
      if (!userDoc.exists) {
        debugPrint('[PERM] user doc missing -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final data = userDoc.data() as Map<String, dynamic>;
      debugPrint('[PERM] userDoc.data = $data');

      final designation = data['designation'] as String?;
      debugPrint('[PERM] designation = $designation');

      if (designation == null || designation.trim().isEmpty) {
        debugPrint('[PERM] designation null/empty -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      // 2) Load designation metadata
      final metaDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(_tenantId)
          .collection('metadata')
          .doc('designations')
          .get();

      debugPrint('[PERM] metaDoc.exists = ${metaDoc.exists}');
      if (!metaDoc.exists) {
        debugPrint('[PERM] designations meta missing -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final meta = metaDoc.data() as Map<String, dynamic>;
      debugPrint('[PERM] meta keys = ${meta.keys.toList()}');

      final allDesignations =
          meta['designations'] as Map<String, dynamic>? ?? {};
      debugPrint(
          '[PERM] allDesignations keys = ${allDesignations.keys.toList()}');

      final designationData =
          allDesignations[designation] as Map<String, dynamic>?;
      debugPrint('[PERM] designationData = $designationData');

      if (designationData == null) {
        debugPrint(
            '[PERM] designation $designation not found -> signOut & login-only');
        await FirebaseAuth.instance.signOut();
        onAllowedWidgetIds({'login'});
        return;
      }

      final permissionsRaw =
          (designationData['permissions'] as List<dynamic>? ?? []);
      final permissions =
          permissionsRaw.map((e) => e.toString()).toSet();
      debugPrint('[PERM] permissions = $permissions');

      // 3) Map permissions to widget ids
      final allowed = <String>{};
      if (permissions.contains('create_task') ||
          permissions.contains('createtask')) {
        allowed.add('createtask');
      }
      if (permissions.contains('view_assigned_tasks') ||
          permissions.contains('viewassignedtasks')) {
        allowed.add('viewassignedtasks');
      }
      if (permissions.contains('view_all_tasks') ||
          permissions.contains('viewalltasks')) {
        allowed.add('viewalltasks');
      }
      if (permissions.contains('complete_task') ||
          permissions.contains('completetask')) {
        allowed.add('completetask');
      }

      debugPrint('[PERM] allowedWidgetIds computed = $allowed');

      onAllowedWidgetIds(allowed.isEmpty ? {'login'} : allowed);

      debugPrint('[PERM] ---- loadUserPermissions END OK ----');
    } catch (e, st) {
      debugPrint('[PERM] Permission load error: $e');
      debugPrint('[PERM] Stack: $st');
      // Do NOT auto sign-out during debugging; just fall back to login view.
      onAllowedWidgetIds({'login'});
    }
  }
}

================================================================================

// File: lib\dynamic_screen\dashboard_screen.dart
import 'dart:async';
import 'dart:math' as math;

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:walld_flutter/dynamic_screen/dashboard_layout_persistence.dart';
import 'package:walld_flutter/dynamic_screen/model/screen_grid.dart';

import '../core/wallpaper_service.dart';
import 'dashboard_grid.dart';
import 'widget_manifest.dart';

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({super.key});

  @override
  State<DashboardScreen> createState() => DashboardScreenState();
}

class DashboardScreenState extends State<DashboardScreen> {
  // DEBUG: Track instances to find duplicates
  static int _instanceCounter = 0;
  final int _instanceNumber;
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString();

  DashboardScreenState() : _instanceNumber = ++_instanceCounter {
    debugPrint('ğŸ”· DashboardScreen INSTANCE #$_instanceNumber CREATED (ID: $_instanceId)');
  }

  // Grid
  static const ScreenGridConfig grid = ScreenGridConfig(columns: 24, rows: 14);

  // ------------------------------------------------------------
  // EASY KNOBS (change only these)
  // ------------------------------------------------------------

  /// Scale factor for ALL default widgets (only affects "defaultItemsForAllowed",
  /// i.e., first-run / no saved layout yet).
  static const double defaultWidgetScale = 0.75;

  /// Default widget base size in grid units (before scale).
  static const int baseColSpan = 7;
  static const int baseRowSpan = 4;

  /// Default start position (X/Y) in grid units for the first widget.
  static const int defaultStartCol = 0; // X
  static const int defaultStartRow = 0; // Y

  /// Login widget defaults (separate knobs).
  static const int loginCol = 6;
  static const int loginRow = 3;
  static const int loginColSpan = 12;
  static const int loginRowSpan = 8;

  int get defaultColSpan =>
      math.max(2, (baseColSpan * defaultWidgetScale).round());

  int get defaultRowSpan =>
      math.max(2, (baseRowSpan * defaultWidgetScale).round());

  // ------------------------------------------------------------

  bool loading = true;
  String? error;
  Set<String> allowedWidgetIds = const {'login'};
  final List<ScreenGridWidgetSpan> items = [];

  StreamSubscription<User?>? authSubscription;
  String get userId => FirebaseAuth.instance.currentUser?.uid ?? 'anon';
  String get layoutPrefsKey => 'dashboard_layout_v1_$userId';

  @override
  void initState() {
    super.initState();
    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - initState() - Setting up auth listener');

    authSubscription = FirebaseAuth.instance.authStateChanges().listen((user) {
      debugPrint('ğŸ”· DashboardScreen #$_instanceNumber AUTH CHANGED: user=${user?.uid}');

      if (user == null) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - User logged out, showing login only');
        showLoginOnly();
      } else {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - User logged in, calling bootstrap()');
        unawaited(bootstrap());
      }
    });

    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Initial bootstrap call');
    unawaited(bootstrap());
  }

  @override
  void dispose() {
    debugPrint('ğŸ”· DashboardScreen #$_instanceNumber DISPOSED');
    authSubscription?.cancel();
    super.dispose();
  }

  void showLoginOnly() {
    setState(() {
      loading = false;
      error = null;
      allowedWidgetIds = const {'login'};
      items
        ..clear()
        ..add(
          ScreenGridWidgetSpan(
            widgetId: 'login',
            col: loginCol,
            row: loginRow,
            colSpan: loginColSpan,
            rowSpan: loginRowSpan,
          ),
        );
    });
  }

  Future<void> bootstrap() async {
    debugPrint('ğŸ”·ğŸ”·ğŸ”· BOOTSTRAP START - DashboardScreen #$_instanceNumber');

    setState(() {
      loading = true;
      error = null;
    });

    try {
      // 1. Get all widgets from manifest
      allowedWidgetIds = widgetManifest.map((w) => w['id'] as String).toSet();

      // 2. Load layout from persistence
      await DashboardLayoutPersistence.loadLayout(
        prefsKey: layoutPrefsKey,
        onLoaded: (loaded) {
          debugPrint(
            'ğŸ”· DashboardScreen #$_instanceNumber - Layout loaded from disk: ${loaded.length} widgets',
          );
          items
            ..clear()
            ..addAll(filterToAllowed(loaded));
        },
        defaultItemsBuilder: defaultItemsForAllowed,
      );

      // 3. Fallback if empty
      if (items.isEmpty) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Layout empty, using defaults');
        items.addAll(defaultItemsForAllowed());
      }

      if (!mounted) {
        debugPrint('ğŸ”· DashboardScreen #$_instanceNumber - Widget not mounted after bootstrap, aborting');
        return;
      }

      setState(() => loading = false);

      debugPrint('ğŸ”·ğŸ”·ğŸ”· BOOTSTRAP END - DashboardScreen #$_instanceNumber - ${items.length} widgets loaded');
    } catch (e) {
      debugPrint('âŒ DashboardScreen #$_instanceNumber - Bootstrap error: $e');
      if (!mounted) return;
      setState(() {
        loading = false;
        error = e.toString();
      });
    }
  }

  List<ScreenGridWidgetSpan> filterToAllowed(List<ScreenGridWidgetSpan> input) {
    return input.where((w) => allowedWidgetIds.contains(w.widgetId)).toList();
  }

  List<ScreenGridWidgetSpan> defaultItemsForAllowed() {
    // Login-only case
    if (allowedWidgetIds.length == 1 && allowedWidgetIds.contains('login')) {
      return [
        ScreenGridWidgetSpan(
          widgetId: 'login',
          col: loginCol,
          row: loginRow,
          colSpan: loginColSpan,
          rowSpan: loginRowSpan,
        ),
      ];
    }

    final ids = allowedWidgetIds.where((id) => id != 'login').toList();
    if (ids.isEmpty) {
      return [
        ScreenGridWidgetSpan(
          widgetId: 'login',
          col: loginCol,
          row: loginRow,
          colSpan: loginColSpan,
          rowSpan: loginRowSpan,
        ),
      ];
    }

    // Size knobs (scaled)
    final w = math.min(defaultColSpan, grid.columns);
    final h = math.min(defaultRowSpan, grid.rows);

    // Start position knobs (X/Y)
    int c = defaultStartCol.clamp(0, math.max(0, grid.columns - w));
    int r = defaultStartRow.clamp(0, math.max(0, grid.rows - h));

    final out = <ScreenGridWidgetSpan>[];

    for (final id in ids) {
      out.add(ScreenGridWidgetSpan(
        widgetId: id,
        col: c,
        row: r,
        colSpan: w,
        rowSpan: h,
      ));

      // Next position
      c += w;

      // Wrap to next row
      if (c >= grid.columns || c + w > grid.columns) {
        c = 0;
        r += h;
      }

      // Wrap to top if overflow
      if (r >= grid.rows || r + h > grid.rows) {
        r = 0;
      }
    }

    return out;
  }

  Future<void> saveLayout() async {
    await DashboardLayoutPersistence.saveLayout(
      prefsKey: layoutPrefsKey,
      items: items,
    );
  }

  void onSnap() {
    unawaited(saveLayout());
  }

  @override
  Widget build(BuildContext context) {
    if (loading) {
      return const Center(
        child: SizedBox(
          width: 28,
          height: 28,
          child: CircularProgressIndicator(color: Colors.cyan),
        ),
      );
    }

    if (error != null) {
      return Center(
        child: Text(
          'Dashboard error: $error',
          style: const TextStyle(color: Colors.redAccent),
        ),
      );
    }

    final wallpaper = WallpaperService.instance;

    return AnimatedBuilder(
      animation: wallpaper,
      builder: (context, _) {
        final glassBlur = wallpaper.globalGlassBlur;
        final glassOpacity = wallpaper.globalGlassOpacity;

        return Stack(
          children: [
            // Wallpaper background
            Positioned.fill(
              child: DecoratedBox(
                decoration: wallpaper.backgroundDecoration,
              ),
            ),

            // Foreground widgets (bounded area)
            Positioned.fill(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(18, 70, 18, 18),
                child: RepaintBoundary(
                  child: DashboardGrid(
                    grid: grid,
                    items: items,
                    onSnap: onSnap,
                    globalBlur: glassBlur,
                    globalOpacity: glassOpacity,
                  ),
                ),
              ),
            ),

            // Debug info (optional)
            if (kDebugMode)
              Positioned(
                left: 12,
                bottom: 10,
                child: IgnorePointer(
                  child: Text(
                    'Widgets: ${items.length} | Allowed: ${allowedWidgetIds.length} | '
                    'Instance: $_instanceNumber | '
                    'DefaultSpan: ${defaultColSpan}x${defaultRowSpan} | '
                    'Start: ${defaultStartCol},${defaultStartRow} | '
                    'Scale: $defaultWidgetScale',
                    style: const TextStyle(
                      color: Colors.white54,
                      fontSize: 11,
                      fontFamily: 'monospace',
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets.dart
export 'widgets/create_task_widget.dart';
export 'widgets/view_assigned_tasks_widget.dart';
export 'widgets/complete_task_widget.dart';
export 'widgets/view_all_tasks_widget.dart';

================================================================================

// File: lib\dynamic_screen\widget_factory.dart
import 'package:flutter/material.dart';
import 'widgets/login_widget.dart';
import 'widgets/create_task_widget.dart';
import 'widgets/view_assigned_tasks_widget.dart';
import 'widgets/view_all_tasks_widget.dart';
import 'widgets/complete_task_widget.dart';

class DynamicWidgetFactory {
  static Widget create(String widgetId) {
    // 1. Normalize the ID: remove underscores and make lowercase
    // This ensures 'create_task' and 'createtask' both work.
    final normalizedId = widgetId.toLowerCase().replaceAll('_', '');

    switch (normalizedId) {
      case 'login':
        return const LoginWidget();
        
      case 'createtask':
        return const CreateTaskWidget();
        
      case 'viewassignedtasks':
        return const ViewAssignedTasksWidget();
        
      case 'viewalltasks':
        return const ViewAllTasksWidget();
        
      case 'completetask':
        return const CompleteTaskWidget();

      default:
        // This handles the "Widget Not Found" error gracefully
        return _buildNotFoundWidget(widgetId);
    }
  }

  static Widget _buildNotFoundWidget(String id) {
    return Container(
      color: Colors.red.withOpacity(0.1),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.broken_image_outlined, color: Colors.red, size: 32),
            const SizedBox(height: 8),
            Text(
              'Unknown Widget\n"$id"',
              textAlign: TextAlign.center,
              style: const TextStyle(color: Colors.red, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widget_manifest.dart
// lib/dynamic_screen/widget_manifest.dart
final List<Map<String, dynamic>> widgetManifest = [
  {
    'id': 'login',
    'name': 'Login',
  },
  {
    'id': 'create_task',
    'name': 'Create Task',
  },
  {
    'id': 'view_assigned_tasks',
    'name': 'View Assigned Tasks',
  },
  {
    'id': 'view_all_tasks',
    'name': 'View All Tasks',
  },
  {
    'id': 'complete_task',
    'name': 'Complete Task',
  },
];

================================================================================

// File: lib\dynamic_screen\model\floating_widget.dart
// lib/dynamic_screen/model/floating_widget.dart
class FloatingWidgetItem {
  final String widgetId;
  double x;      // left position in pixels
  double y;      // top position in pixels
  double width;  // widget width in pixels
  double height; // widget height in pixels

  FloatingWidgetItem({
    required this.widgetId,
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });
}

================================================================================

// File: lib\dynamic_screen\model\grid_layout.dart
class GridLayoutConfig {
  final int columns;
  final double rowHeight; // logical pixels per grid row

  const GridLayoutConfig({
    this.columns = 120,
    this.rowHeight = 700,
  });
}

class WidgetGridItem {
  final String widgetId;
  int col;      // 0-based column index
  int row;      // 0-based row index
  int colSpan;  // number of columns spanned
  int rowSpan;  // number of rows spanned

  WidgetGridItem({
    required this.widgetId,
    required this.col,
    required this.row,
    required this.colSpan,
    required this.rowSpan,
  });
}

================================================================================

// File: lib\dynamic_screen\model\screen_grid.dart
class ScreenGridConfig {
  final int columns;
  final int rows;

  const ScreenGridConfig({
    this.columns = 240,
    this.rows = 140,
  });
}

class ScreenGridWidgetSpan {
  final String widgetId;
  int col;      // 0-based column index
  int row;      // 0-based row index
  int colSpan;  // how many screen columns this widget uses
  int rowSpan;  // how many screen rows this widget uses

  ScreenGridWidgetSpan({
    required this.widgetId,
    required this.col,
    required this.row,
    required this.colSpan,
    required this.rowSpan,
  });
}

================================================================================

// File: lib\dynamic_screen\model\task_form_models.dart
import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';

enum TaskFieldType { text, dropdown, date }

TaskFieldType _parseFieldType(String raw) {
  switch (raw) {
    case 'dropdown':
      return TaskFieldType.dropdown;
    case 'date':
      return TaskFieldType.date;
    case 'text':
    default:
      return TaskFieldType.text;
  }
}

class TaskFormFieldConfig {
  final String id;
  final String label;
  final bool required;
  final TaskFieldType type;
  final List<String> options;

  TaskFormFieldConfig({
    required this.id,
    required this.label,
    required this.required,
    required this.type,
    this.options = const [],
  });

  factory TaskFormFieldConfig.fromMap(Map<String, dynamic> map) {
    return TaskFormFieldConfig(
      id: map['id'] as String,
      label: (map['label'] as String?) ?? map['id'] as String,
      required: (map['required'] as bool?) ?? false,
      type: _parseFieldType(map['type'] as String? ?? 'text'),
      options: (map['options'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          const [],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'label': label,
      'required': required,
      'type': switch (type) {
        TaskFieldType.text => 'text',
        TaskFieldType.dropdown => 'dropdown',
        TaskFieldType.date => 'date',
      },
      'options': options,
    };
  }
}

class TaskFormDefinition {
  final String name;
  final String description;
  final List<TaskFormFieldConfig> fields;

  TaskFormDefinition({
    required this.name,
    required this.description,
    required this.fields,
  });

  factory TaskFormDefinition.fromDoc(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>? ?? {};
    final schema = data['schema'] as Map<String, dynamic>? ?? {};
    final List<dynamic> rawFields = schema['fields'] as List<dynamic>? ?? [];
    final fields = rawFields
        .map((f) => TaskFormFieldConfig.fromMap(f as Map<String, dynamic>))
        .toList();

    return TaskFormDefinition(
      name: data['name'] as String? ?? 'Create Task',
      description:
          data['description'] as String? ?? 'Form to create and assign tasks',
      fields: fields,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'name': name,
      'description': description,
      'schema': {
        'fields': fields.map((f) => f.toMap()).toList(),
      },
    };
  }

  factory TaskFormDefinition.fromCacheJson(String json) {
    final data = jsonDecode(json) as Map<String, dynamic>;
    final schema = data['schema'] as Map<String, dynamic>? ?? {};
    final List<dynamic> rawFields = schema['fields'] as List<dynamic>? ?? [];
    final fields = rawFields
        .map((f) => TaskFormFieldConfig.fromMap(f as Map<String, dynamic>))
        .toList();

    return TaskFormDefinition(
      name: data['name'] as String? ?? 'Create Task',
      description:
          data['description'] as String? ?? 'Form to create and assign tasks',
      fields: fields,
    );
  }
}

class TaskFormRepository {
  static const _prefsFormKey = 'cached_task_creation_form';

  final String tenantId;

  TaskFormRepository({required this.tenantId});

  Future<TaskFormDefinition> loadCreateTaskFormOnce() async {
    final prefs = await SharedPreferences.getInstance();
    final cached = prefs.getString(_prefsFormKey);
    if (cached != null) {
      return TaskFormDefinition.fromCacheJson(cached);
    }

    final docRef = FirebaseFirestore.instance
        .collection('tenants')
        .doc(tenantId)
        .collection('forms')
        .doc('task_creation');

    final snap = await docRef.get();
    final def = TaskFormDefinition.fromDoc(snap);

    await prefs.setString(_prefsFormKey, jsonEncode(def.toMap()));
    return def;
  }

  Future<void> createTask({
    required String createdBy,
    required Map<String, dynamic> values,
  }) async {
    final tasksCol = FirebaseFirestore.instance
        .collection('tenants')
        .doc(tenantId)
        .collection('tasks');

    final now = DateTime.now();
    final core = <String, dynamic>{
      'title': values['title'] ?? '',
      'description': values['description'] ?? '',
      'status': 'PENDING',
      'created_by': createdBy,
      'created_at': now.toIso8601String(),
      'updated_at': now.toIso8601String(),
    };

    if (values['dueDate'] != null && values['dueDate'] is DateTime) {
      core['due_date'] = (values['dueDate'] as DateTime).toIso8601String();
    }

    final custom = Map<String, dynamic>.from(values)
      ..remove('title')
      ..remove('description')
      ..remove('dueDate');

    if (custom.isNotEmpty) {
      core['custom_fields'] = custom;
    }

    await tasksCol.add(core);
  }
}

================================================================================

// File: lib\dynamic_screen\model\widget.dart
class WidgetModel {
  final String id;
  final String name;

  WidgetModel({required this.id, required this.name});
}

================================================================================

// File: lib\dynamic_screen\repository\dashboard_repository.dart
import '../model/widget.dart';
import '../widget_manifest.dart';

class DashboardRepository {
  List<WidgetModel> getWidgets() {
    return widgetManifest.map((w) => WidgetModel(id: w['id'] as String, name: w['name'] as String)).toList();
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\complete_task_widget.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart'; // adjust package name if different

class CompleteTaskWidget extends StatelessWidget {
  const CompleteTaskWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Glass color derived from global glass opacity
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = (maxW < maxH ? maxW : maxH);
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.05).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.70).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0);

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // <-- uses the local bgColor
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Complete Task',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'Panel to mark tasks as completed demo.',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\create_task_widget.dart
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

/// Simple non-interactive card widget (no create-task logic).
class CreateTaskWidget extends StatelessWidget {
  const CreateTaskWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same as CompleteTaskWidget [file:4]
      builder: (context, _) {
        final ws = WallpaperService.instance; // [file:4]
        // Same glass color as CompleteTaskWidget
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45)); // [file:4]

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH); // [file:3]
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.05).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.70).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:3]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor,
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ), // same decoration as CompleteTaskWidget except min differences [file:4]
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Task Panel',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ), // [file:3]
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'This area can be used to show summary or status of tasks. '
                      'Creation flow has been removed.',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ), // [file:3]
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Static widget',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.cyanAccent.withOpacity(0.85),
                        fontSize: smallFont,
                      ),
                    ),
                  ), // [file:3]
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\login_widget.dart
// lib/dynamicscreen/widgets/loginwidget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../core/wallpaper_service.dart';

class LoginWidget extends StatefulWidget {
  const LoginWidget({super.key});

  @override
  State<LoginWidget> createState() => _LoginWidgetState();
}

class _LoginWidgetState extends State<LoginWidget> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;

  // DEBUG ID to track widget lifecycle
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString().substring(8);

  _LoginWidgetState() {
    debugPrint('ğŸ”‘ LoginWidget CREATED (ID: $_instanceId)');
  }

  @override
  void dispose() {
    debugPrint('ğŸ”‘ LoginWidget DISPOSED (ID: $_instanceId)');
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> signIn() async {
    debugPrint('ğŸ”‘ LoginWidget #$_instanceId - signIn() START');

    if (!(_formKey.currentState?.validate() ?? false)) {
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - Form validation failed');
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - Calling FirebaseAuth.signInWithEmailAndPassword');
      
      final cred = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: _emailController.text.trim(),
        password: _passwordController.text.trim(),
      );
      
      debugPrint('âœ… LoginWidget #$_instanceId - LOGIN SUCCESS: User ${cred.user?.uid}');
      debugPrint('ğŸ”‘ LoginWidget #$_instanceId - NOT navigating manually. Waiting for DashboardScreen listener.');
      
      // âœ… FIX CONFIRMED: NO NAVIGATION CODE HERE!
      // DO NOT call Navigator.pushReplacement()
      // The DashboardScreen's authStateChanges listener will handle the transition.

    } on FirebaseAuthException catch (e) {
      debugPrint('âŒ LoginWidget #$_instanceId - Auth Error: ${e.code} - ${e.message}');
      setState(() {
        _errorMessage = _getErrorMessage(e.code);
      });
    } catch (e) {
      debugPrint('âŒ LoginWidget #$_instanceId - Unknown Error: $e');
      setState(() {
        _errorMessage = "Unexpected error. Please try again.";
      });
    } finally {
      if (mounted) {
        debugPrint('ğŸ”‘ LoginWidget #$_instanceId - signIn() FINISHED, resetting loading state');
        setState(() {
          _isLoading = false;
        });
      } else {
         debugPrint('âš ï¸ LoginWidget #$_instanceId - Widget unmounted after signIn, skipping setState');
      }
    }
  }

  String _getErrorMessage(String code) {
    switch (code) {
      case 'user-not-found':
        return 'No account found. Please register first.';
      case 'wrong-password':
        return 'Incorrect password.';
      case 'invalid-email':
        return 'Invalid email format.';
      case 'user-disabled':
        return 'Account disabled. Contact admin.';
      case 'too-many-requests':
        return 'Too many attempts. Try again later.';
      default:
        return 'Login failed. Please try again.';
    }
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;

        // Glass color derived from global glass opacity
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);

            // When the box is short, compress everything a bit
            final double compress =
                shortest < 360 ? 0.85 : (shortest < 420 ? 0.92 : 1.0);

            final double unit = (shortest / 11.0).clamp(10.0, 32.0) * compress;
            final double radius = (unit * 0.9).clamp(12.0, 24.0);
            final double margin = (unit * 0.22).clamp(6.0, 14.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.65 * compress).clamp(8.0, 20.0));

            final double titleFont = (unit * 1.1).clamp(18.0, 26.0);
            final double subtitleFont = (unit * 0.72).clamp(11.0, 16.0);
            final double fieldFont = (unit * 0.80).clamp(12.0, 18.0);
            final double smallFont = (unit * 0.70).clamp(10.0, 14.0);
            final double gap = (unit * 0.40 * compress).clamp(4.0, 12.0);
            final double fieldVerticalPad =
                (unit * 0.30 * compress).clamp(4.0, 8.0);
            final double fieldRadius = (unit * 0.55).clamp(8.0, 14.0);

            // âœ… Wrap in Material + SingleChildScrollView
            return Material(
              type: MaterialType.transparency,
              child: Container(
                margin: EdgeInsets.all(margin),
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: BorderRadius.circular(radius),
                  border: Border.all(color: const Color(0x22FFFFFF)),
                  boxShadow: const [
                    BoxShadow(
                      color: Color(0x33000000),
                      blurRadius: 18,
                      offset: Offset(0, 10),
                    ),
                  ],
                ),
                padding: padding,
                child: SingleChildScrollView(  // âœ… Make scrollable
                  physics: const BouncingScrollPhysics(),
                  child: Form(
                    key: _formKey,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        // Logo
                        const Icon(
                          Icons.image_outlined,
                          color: Colors.cyanAccent,
                          size: 48,
                        ),
                        SizedBox(height: gap),

                        // Title
                        Text(
                          'Wall-D',
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: titleFont,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        SizedBox(height: gap * 0.5),

                        // Subtitle
                        Text(
                          'Sign in with your work account',
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            color: Colors.white60,
                            fontSize: subtitleFont,
                          ),
                        ),
                        SizedBox(height: gap * 1.5),

                        // Email field
                        TextFormField(
                          controller: _emailController,
                          keyboardType: TextInputType.emailAddress,
                          style: TextStyle(color: Colors.white, fontSize: fieldFont),
                          decoration: InputDecoration(
                            labelText: 'Email',
                            floatingLabelBehavior: FloatingLabelBehavior.auto,
                            labelStyle: const TextStyle(color: Colors.white70),
                            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                            filled: true,
                            fillColor: Colors.white.withOpacity(0.04),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(
                                color: Colors.cyanAccent,
                                width: 2,
                              ),
                            ),
                            contentPadding: EdgeInsets.symmetric(
                              horizontal: unit * 0.5,
                              vertical: fieldVerticalPad,
                            ),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Email required';
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: gap),

                        // Password field
                        TextFormField(
                          controller: _passwordController,
                          obscureText: true,
                          style: TextStyle(color: Colors.white, fontSize: fieldFont),
                          decoration: InputDecoration(
                            labelText: 'Password',
                            floatingLabelBehavior: FloatingLabelBehavior.auto,
                            labelStyle: const TextStyle(color: Colors.white70),
                            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                            filled: true,
                            fillColor: Colors.white.withOpacity(0.04),
                            border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            enabledBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(color: Colors.white24),
                            ),
                            focusedBorder: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(fieldRadius),
                              borderSide: const BorderSide(
                                color: Colors.cyanAccent,
                                width: 2,
                              ),
                            ),
                            contentPadding: EdgeInsets.symmetric(
                              horizontal: unit * 0.5,
                              vertical: fieldVerticalPad,
                            ),
                          ),
                          validator: (value) {
                            if (value == null || value.isEmpty) {
                              return 'Password required';
                            }
                            return null;
                          },
                        ),
                        SizedBox(height: gap),

                        // Error message (optional)
                        if (_errorMessage != null) ...[
                          Container(
                            width: double.infinity,
                            padding: EdgeInsets.all(unit * 0.35),
                            decoration: BoxDecoration(
                              color: Colors.red.shade900,
                              borderRadius: BorderRadius.circular(fieldRadius),
                              border: Border.all(color: Colors.red.shade700),
                            ),
                            child: Row(
                              children: [
                                const Icon(
                                  Icons.error_outline,
                                  color: Colors.redAccent,
                                  size: 16,
                                ),
                                SizedBox(width: unit * 0.3),
                                Expanded(
                                  child: Text(
                                    _errorMessage!,
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontSize: smallFont,
                                    ),
                                    maxLines: 2,
                                    overflow: TextOverflow.ellipsis,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          SizedBox(height: gap),
                        ],

                        // Sign in button
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton(
                            onPressed: _isLoading ? null : signIn,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.cyanAccent,
                              foregroundColor: Colors.black,
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(fieldRadius),
                              ),
                              padding: EdgeInsets.symmetric(
                                vertical: fieldVerticalPad + 1,
                              ),
                              elevation: 8,
                            ),
                            child: _isLoading
                                ? SizedBox(
                                    height: unit,
                                    width: unit,
                                    child: const CircularProgressIndicator(
                                      color: Colors.black,
                                      strokeWidth: 2,
                                    ),
                                  )
                                : Text(
                                    'Sign In',
                                    style: TextStyle(
                                      fontSize: fieldFont,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                          ),
                        ),
                        SizedBox(height: gap),

                        Text(
                          "You'll see your dashboard after login",
                          textAlign: TextAlign.center,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                            fontSize: smallFont,
                            color: Colors.white38,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\view_all_tasks_widget.dart
// lib/dynamic_screen/widgets/view_all_tasks_widget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

class ViewAllTasksWidget extends StatelessWidget {
  const ViewAllTasksWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same reactive glass source [file:9]
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Same glass color formula as CompleteTaskWidget [file:9]
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);
            final double unit = (shortest / 8.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.85).clamp(12.0, 42.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding =
                EdgeInsets.all((unit * 0.75).clamp(8.0, 28.0));
            final double titleFont = (unit * 1.00).clamp(12.0, 24.0);
            final double bodyFont = (unit * 0.66).clamp(10.0, 17.0);
            final double smallFont = (unit * 0.55).clamp(9.0, 15.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:8]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // updated to dynamic glass color [file:9]
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'View All Tasks',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Text(
                      'Summary view of all tasks (demo).',
                      maxLines: 4,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white70,
                        fontSize: bodyFont,
                        height: 1.2,
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\view_assigned_tasks_widget.dart
// lib/dynamic_screen/widgets/view_assigned_tasks_widget.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:walld_flutter/core/wallpaper_service.dart';

class ViewAssignedTasksWidget extends StatelessWidget {
  const ViewAssignedTasksWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance, // same as CompleteTaskWidget [file:11]
      builder: (context, _) {
        final ws = WallpaperService.instance;
        // Same glass color formula as CompleteTaskWidget [file:11]
        final Color bgColor = const Color(0xFF11111C)
            .withOpacity((ws.globalGlassOpacity * 3).clamp(0.05, 0.45));

        return LayoutBuilder(
          builder: (context, constraints) {
            final maxW = constraints.maxWidth;
            final maxH = constraints.maxHeight;
            final shortest = math.min(maxW, maxH);
            final double unit = (shortest / 9.0).clamp(10.0, 48.0);
            final double radius = (unit * 0.90).clamp(12.0, 44.0);
            final double margin = (unit * 0.25).clamp(4.0, 12.0);
            final EdgeInsets padding = EdgeInsets.symmetric(
              horizontal: (unit * 0.90).clamp(10.0, 30.0),
              vertical: (unit * 0.70).clamp(8.0, 24.0),
            );
            final double titleFont = (unit * 1.10).clamp(12.0, 26.0);
            final double bodyFont = (unit * 0.72).clamp(10.0, 18.0);
            final double smallFont = (unit * 0.60).clamp(9.0, 16.0);
            final double gap = (unit * 0.60).clamp(6.0, 18.0); // [file:10]

            return Container(
              margin: EdgeInsets.all(margin),
              decoration: BoxDecoration(
                color: bgColor, // updated from 0xCC0B0F1C to glass color [file:10][file:11]
                borderRadius: BorderRadius.circular(radius),
                border: Border.all(color: const Color(0x22FFFFFF)),
                boxShadow: const [
                  BoxShadow(
                    color: Color(0x33000000),
                    blurRadius: 18,
                    offset: Offset(0, 10),
                  ),
                ],
              ),
              padding: padding,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'View Assigned Tasks',
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: titleFont,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  SizedBox(height: gap),
                  Expanded(
                    child: Align(
                      alignment: Alignment.topLeft,
                      child: Text(
                        'Tasks currently assigned to you will appear here (demo).',
                        maxLines: 4,
                        overflow: TextOverflow.ellipsis,
                        style: TextStyle(
                          color: Colors.white70,
                          fontSize: bodyFont,
                          height: 1.2,
                        ),
                      ),
                    ),
                  ),
                  Align(
                    alignment: Alignment.bottomRight,
                    child: Text(
                      'Demo widget content',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: smallFont,
                      ),
                    ),
                  ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

================================================================================

// File: lib\dynamic_screen\widgets\widgets.dart
// lib/dynamic_screen/widgets/widgets.dart
import 'dart:math' as math;

import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import '../model/screen_grid.dart';
import '../widget_factory.dart';

/// Used by DashboardGrid to build a draggable/resizable widget tile.
Widget buildGridWidget({
  required ScreenGridWidgetSpan item,
  required double cellW,
  required double cellH,
  required double maxW,
  required double maxH,
  required double initialLeft,
  required double initialTop,
  required double initialWidthPx,
  required double initialHeightPx,
  required double globalBlur,
  required double globalOpacity,
  required Color globalTint,
  required VoidCallback onSnap,
}) {
  return FreeDragResizeItem(
    key: ValueKey(item.widgetId),
    item: item,
    gridColumns: 24,
    gridRows: 14,
    cellW: cellW,
    cellH: cellH,
    maxW: maxW,
    maxH: maxH,
    initialLeft: initialLeft,
    initialTop: initialTop,
    initialWidthPx: initialWidthPx,
    initialHeightPx: initialHeightPx,
    globalBlur: globalBlur,
    globalOpacity: globalOpacity,
    globalTint: globalTint,
    onSnap: onSnap,
  );
}

class _LiveLayout {
  final double left;
  final double top;
  final double width;
  final double height;

  const _LiveLayout({
    required this.left,
    required this.top,
    required this.width,
    required this.height,
  });

  _LiveLayout copyWith({
    double? left,
    double? top,
    double? width,
    double? height,
  }) {
    return _LiveLayout(
      left: left ?? this.left,
      top: top ?? this.top,
      width: width ?? this.width,
      height: height ?? this.height,
    );
  }
}

/// Draggable + resizable wrapper used by the dashboard grid.
///
/// Performance fixes:
/// - No setState() on each pointer update (uses ValueNotifier for layout).
/// - While dragging/resizing, renders a cheap outline placeholder (no blur/shadow).
/// - Cached inner widget content so it does not rebuild while moving.
class FreeDragResizeItem extends StatefulWidget {
  final ScreenGridWidgetSpan item;

  final int gridColumns;
  final int gridRows;

  final double cellW;
  final double cellH;

  final double maxW;
  final double maxH;

  final double initialLeft;
  final double initialTop;
  final double initialWidthPx;
  final double initialHeightPx;

  final double globalBlur;
  final double globalOpacity;
  final Color globalTint;

  final VoidCallback onSnap;

  const FreeDragResizeItem({
    super.key,
    required this.item,
    required this.gridColumns,
    required this.gridRows,
    required this.cellW,
    required this.cellH,
    required this.maxW,
    required this.maxH,
    required this.initialLeft,
    required this.initialTop,
    required this.initialWidthPx,
    required this.initialHeightPx,
    required this.globalBlur,
    required this.globalOpacity,
    required this.globalTint,
    required this.onSnap,
  });

  @override
  State<FreeDragResizeItem> createState() => _FreeDragResizeItemState();
}

class _FreeDragResizeItemState extends State<FreeDragResizeItem> {
  // Cached widget content
  Widget? _cachedContent;
  String? _cachedWidgetId;

  // Live layout updated without setState()
  late final ValueNotifier<_LiveLayout> _layoutVN;

  // Interaction state (dragging/resizing)
  late final ValueNotifier<bool> _interactingVN;

  // Drag state
  Offset? _dragStartGlobal;
  _LiveLayout? _dragStartLayout;

  // Resize state
  Offset? _resizeStartGlobal;
  _LiveLayout? _resizeStartLayout;

  static const double _minSpan = 2; // min 2x2 cells
  static const double _handleSize = 18;

  bool get _isDragging => _dragStartGlobal != null;
  bool get _isResizing => _resizeStartGlobal != null;
  bool get _isInteracting => _isDragging || _isResizing;

  @override
  void initState() {
    super.initState();

    _layoutVN = ValueNotifier<_LiveLayout>(
      _LiveLayout(
        left: widget.initialLeft,
        top: widget.initialTop,
        width: widget.initialWidthPx,
        height: widget.initialHeightPx,
      ),
    );

    _interactingVN = ValueNotifier<bool>(false);

    _buildCachedContent();
  }

  @override
  void didUpdateWidget(covariant FreeDragResizeItem oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.item.widgetId != widget.item.widgetId) {
      _buildCachedContent();
    }

    if (!_isInteracting) {
      _layoutVN.value = _LiveLayout(
        left: (widget.item.col * widget.cellW)
            .clamp(0.0, math.max(0.0, widget.maxW - widget.cellW)),
        top: (widget.item.row * widget.cellH)
            .clamp(0.0, math.max(0.0, widget.maxH - widget.cellH)),
        width: (widget.item.colSpan * widget.cellW)
            .clamp(widget.cellW * _minSpan, widget.maxW),
        height: (widget.item.rowSpan * widget.cellH)
            .clamp(widget.cellH * _minSpan, widget.maxH),
      );
    }
  }

  @override
  void dispose() {
    _layoutVN.dispose();
    _interactingVN.dispose();
    super.dispose();
  }

  void _buildCachedContent() {
    _cachedWidgetId = widget.item.widgetId;
    _cachedContent = RepaintBoundary(
      child: DynamicWidgetFactory.create(widget.item.widgetId),
    );
  }

  double _clampLeft(double left, double width) {
    final maxLeft = math.max(0.0, widget.maxW - width);
    return left.clamp(0.0, maxLeft);
  }

  double _clampTop(double top, double height) {
    final maxTop = math.max(0.0, widget.maxH - height);
    return top.clamp(0.0, maxTop);
  }

  double _clampWidth(double width) {
    final minW = widget.cellW * _minSpan;
    return width.clamp(minW, widget.maxW);
  }

  double _clampHeight(double height) {
    final minH = widget.cellH * _minSpan;
    return height.clamp(minH, widget.maxH);
  }

  void _setInteracting(bool v) {
    if (_interactingVN.value != v) _interactingVN.value = v;
  }

  // Drag handlers
  void _onDragStart(DragStartDetails d) {
    _dragStartGlobal = d.globalPosition;
    _dragStartLayout = _layoutVN.value;
    _setInteracting(true);
  }

  void _onDragUpdate(DragUpdateDetails d) {
    if (_dragStartGlobal == null || _dragStartLayout == null) return;

    final delta = d.globalPosition - _dragStartGlobal!;
    final start = _dragStartLayout!;

    final newLeft = _clampLeft(start.left + delta.dx, start.width);
    final newTop = _clampTop(start.top + delta.dy, start.height);

    _layoutVN.value = start.copyWith(left: newLeft, top: newTop);
  }

  void _onDragEnd([DragEndDetails? _]) {
    _dragStartGlobal = null;
    _dragStartLayout = null;
    _snapToGridAndPersist();
  }

  // Resize handlers
  void _onResizeStart(DragStartDetails d) {
    _resizeStartGlobal = d.globalPosition;
    _resizeStartLayout = _layoutVN.value;
    _setInteracting(true);
  }

  void _onResizeUpdate(DragUpdateDetails d) {
    if (_resizeStartGlobal == null || _resizeStartLayout == null) return;

    final delta = d.globalPosition - _resizeStartGlobal!;
    final start = _resizeStartLayout!;

    final newWidth = _clampWidth(start.width + delta.dx);
    final newHeight = _clampHeight(start.height + delta.dy);

    final newLeft = _clampLeft(start.left, newWidth);
    final newTop = _clampTop(start.top, newHeight);

    _layoutVN.value = start.copyWith(
      left: newLeft,
      top: newTop,
      width: newWidth,
      height: newHeight,
    );
  }

  void _onResizeEnd([DragEndDetails? _]) {
    _resizeStartGlobal = null;
    _resizeStartLayout = null;
    _snapToGridAndPersist();
  }

  void _snapToGridAndPersist() {
    final l = _layoutVN.value;

    int col = (l.left / widget.cellW).round();
    int row = (l.top / widget.cellH).round();
    int colSpan = (l.width / widget.cellW).round();
    int rowSpan = (l.height / widget.cellH).round();

    colSpan = colSpan.clamp(_minSpan.toInt(), widget.gridColumns);
    rowSpan = rowSpan.clamp(_minSpan.toInt(), widget.gridRows);

    col = col.clamp(0, widget.gridColumns - colSpan);
    row = row.clamp(0, widget.gridRows - rowSpan);

    widget.item
      ..col = col
      ..row = row
      ..colSpan = colSpan
      ..rowSpan = rowSpan;

    _layoutVN.value = _LiveLayout(
      left: col * widget.cellW,
      top: row * widget.cellH,
      width: colSpan * widget.cellW,
      height: rowSpan * widget.cellH,
    );

    _setInteracting(false);
    widget.onSnap();
  }

  // Outline-only placeholder used while interacting
  Widget _buildCheapPlaceholder() {
    final borderColor = Colors.cyanAccent.withOpacity(0.55);
    final glowColor = Colors.cyanAccent.withOpacity(0.12);

    return IgnorePointer(
      child: Container(
        decoration: BoxDecoration(
          color: Colors.transparent,
          borderRadius: BorderRadius.circular(24),
          border: Border.all(color: borderColor, width: 2),
          boxShadow: [
            BoxShadow(
              color: glowColor,
              blurRadius: 10,
              spreadRadius: 1,
            ),
          ],
        ),
        child: const SizedBox.expand(),
      ),
    );
  }

  Widget _buildFullGlassCard(Widget content) {
    // Global blur is applied in WorkspaceShell; disable per-widget blur.
    return GlassContainer(
      blur: widget.globalBlur, 
      opacity: widget.globalOpacity,
      tint: widget.globalTint,
      blurMode: GlassBlurMode.perWidget,  // âœ… Enable blur
      borderRadius: BorderRadius.circular(24),
      qualityMode: GlassQualityMode.auto,
      isInteracting: _isInteracting,
      disableShadows: false,
      padding: EdgeInsets.zero,
      child: content,
    );
  }

  @override
  Widget build(BuildContext context) {
    final content = _cachedContent ?? const SizedBox.shrink();

    // Only this tile rebuilds per tick; expensive inner content is cached.
    return ValueListenableBuilder<_LiveLayout>(
      valueListenable: _layoutVN,
      builder: (context, l, _) {
        return Positioned(
          left: l.left,
          top: l.top,
          width: l.width,
          height: l.height,

          // IMPORTANT: Positioned is the direct child of the Stack in DashboardGrid.
          child: RepaintBoundary(
            child: Stack(
              children: [
                // Card surface: placeholder vs full glass
                Positioned.fill(
                  child: ValueListenableBuilder<bool>(
                    valueListenable: _interactingVN,
                    builder: (context, interacting, __) {
                      if (interacting) {
                        return _buildCheapPlaceholder();
                      }
                      return _buildFullGlassCard(content);
                    },
                  ),
                ),

                // Drag overlay
                Positioned.fill(
                  child: Listener(
                    behavior: HitTestBehavior.translucent,
                    child: GestureDetector(
                      behavior: HitTestBehavior.translucent,
                      onPanStart: _onDragStart,
                      onPanUpdate: _onDragUpdate,
                      onPanEnd: _onDragEnd,
                      child: const SizedBox.expand(),
                    ),
                  ),
                ),

                // Resize handle (bottom-right)
                Positioned(
                  right: 6,
                  bottom: 6,
                  child: Listener(
                    behavior: HitTestBehavior.opaque,
                    child: GestureDetector(
                      onPanStart: _onResizeStart,
                      onPanUpdate: _onResizeUpdate,
                      onPanEnd: _onResizeEnd,
                      child: Container(
                        width: _handleSize,
                        height: _handleSize,
                        decoration: BoxDecoration(
                          color: Colors.white
                              .withOpacity(_isInteracting ? 0.10 : 0.14),
                          borderRadius: BorderRadius.circular(6),
                          border: Border.all(
                            color: Colors.white.withOpacity(0.18),
                            width: 1,
                          ),
                        ),
                        child: Icon(
                          Icons.open_in_full,
                          size: 12,
                          color: Colors.white.withOpacity(0.65),
                        ),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\task\task_tabs_manifest.dart
import 'package:flutter/material.dart';
import '../core/wallpaper_service.dart'; // NEW IMPORT
import 'pages/create_task_page/create_task_page.dart';
import 'pages/view_all_tasks_page.dart';
import 'pages/view_assigned_tasks_page/view_assigned_tasks_page.dart';
import 'pages/complete_task_page.dart';

class TaskTabIds {
  static const create = 'create';
  static const viewAll = 'viewall';
  static const viewAssigned = 'viewassigned';
  static const complete = 'complete';
}

class TaskTabDef {
  final String id;
  final String title;
  final IconData icon;
  final WidgetBuilder builder;

  TaskTabDef({
    required this.id,
    required this.title,
    required this.icon,
    required this.builder,
  });
}

final List<TaskTabDef> taskTabs = [
  TaskTabDef(
    id: TaskTabIds.create,
    title: 'Create',
    icon: Icons.add_task_rounded,
    builder: (context) => const CreateTaskPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.viewAssigned,
    title: 'Assigned',
    icon: Icons.assignment_ind_rounded,
    builder: (context) => const ViewAssignedTasksPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.viewAll,
    title: 'All',
    icon: Icons.view_list_rounded,
    builder: (context) => const ViewAllTasksPage(),
  ),
  TaskTabDef(
    id: TaskTabIds.complete,
    title: 'Complete',
    icon: Icons.check_circle_rounded,
    builder: (context) => const CompleteTaskPage(),
  ),
];

/// UPDATED: Now uses WallpaperService instead of local gradient
BoxDecoration backgroundDecoration() {
  return WallpaperService.instance.backgroundDecoration;
}

================================================================================

// File: lib\task\task_workspace.dart
// lib/task/task_workspace.dart

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../core/glass_container.dart';
import '../core/wallpaper_service.dart';

import 'pages/complete_task_page.dart';
import 'pages/create_task_page/create_task_page.dart';
import 'pages/view_all_tasks_page.dart';
import 'pages/view_assigned_tasks_page/view_assigned_tasks_page.dart';

import 'task_tabs_manifest.dart';
import 'widgets/task_side_panel.dart';

class TaskWorkspace extends StatefulWidget {
  const TaskWorkspace({super.key});

  @override
  State<TaskWorkspace> createState() => TaskWorkspaceState();
}

class TaskWorkspaceState extends State<TaskWorkspace> {
  // Match TaskTabIds from task_tabs_manifest.dart
  String selectedTabId = TaskTabIds.viewAssigned;

  TaskTabDef get _currentTab =>
      taskTabs.firstWhere((t) => t.id == selectedTabId, orElse: () => taskTabs.first);

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final double glassBlur = WallpaperService.instance.globalGlassBlur;
        final double glassOpacity = WallpaperService.instance.globalGlassOpacity;

        return Padding(
          padding: const EdgeInsets.fromLTRB(18, 70, 18, 18),
          child: Row(
            children: [
              // LEFT: side panel â€“ API fixed to match TaskSidePanel
              SizedBox(
                width: 240,
                child: TaskSidePanel(
                  selectedTabId: selectedTabId,
                  onSelect: (id) {
                    setState(() {
                      selectedTabId = id;
                    });
                  },
                ),
              ),

              const SizedBox(width: 18),

              // RIGHT: main glass content
              Expanded(
                child: GlassContainer(
                  blur: glassBlur,
                  opacity: glassOpacity,
                  tint: Colors.white,
                  borderRadius: BorderRadius.circular(24),
                  padding: const EdgeInsets.all(24),
                  // OLD:
                  // blurMode: GlassBlurMode.auto,
                  // NEW: force blur for this panel
                  blurMode: GlassBlurMode.perWidget,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Header uses TaskTabDef.title/icon (no .name)
                      Row(
                        children: [
                          Icon(
                            _currentTab.icon,
                            color: Colors.cyan,
                            size: 28,
                          ),
                          const SizedBox(width: 12),
                          Text(
                            _currentTab.title,
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const Spacer(),
                          if (kDebugMode)
                            Text(
                              'Blur: ${glassBlur.toStringAsFixed(1)}  |  '
                              'Opacity: ${(glassOpacity * 100).toStringAsFixed(0)}%',
                              style: const TextStyle(
                                color: Colors.white54,
                                fontSize: 12,
                                fontFamily: 'monospace',
                              ),
                            ),
                        ],
                      ),

                      const SizedBox(height: 24),

                      // Body: use builder from TaskTabDef so pages stay singleâ€‘sourced
                      Expanded(
                        child: _currentTab.builder(context),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\task\pages\complete_task_page.dart
import 'package:flutter/material.dart';

class CompleteTaskPage extends StatelessWidget {
  const CompleteTaskPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text('Complete Task (full-screen page placeholder)', style: TextStyle(color: Colors.white70)),
    );
  }
}

================================================================================

// File: lib\task\pages\view_all_tasks_page.dart
import 'package:flutter/material.dart';
// lib/task/pages/view_all_tasks_page.dart
class ViewAllTasksPage extends StatelessWidget {
  const ViewAllTasksPage({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text(
        'View All Tasks full-screen page placeholder',
        style: TextStyle(color: Colors.white70),
      ),
    );
  }
}


================================================================================

// File: lib\task\pages\create_task_page\create_task_page.dart
import 'dart:math' as math;

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../Developer/DynamicForms/dynamic_forms_repository.dart';
import '../../../Developer/DynamicForms/form_models.dart';
import 'models/assignment_data.dart';
import 'widgets/task_form_renderer.dart';

class CreateTaskPage extends StatefulWidget {
  const CreateTaskPage({super.key});

  @override
  State<CreateTaskPage> createState() => _CreateTaskPageState();
}

class _CreateTaskPageState extends State<CreateTaskPage> {
  static const String tenantId = 'default_tenant';

  static FormSchemaMeta? _cachedTaskCreationForm;
  static Object? _cachedLoadError;

  final DynamicFormsRepository _repo = DynamicFormsRepository();
  final GlobalKey<TaskFormRendererState> _rendererKey =
      GlobalKey<TaskFormRendererState>();

  FormSchemaMeta? _form;
  bool _loading = true;
  bool _submitting = false;

  @override
  void initState() {
    super.initState();
    if (_cachedTaskCreationForm != null || _cachedLoadError != null) {
      _form = _cachedTaskCreationForm;
      _loading = false;
    } else {
      _loadFormOnce();
    }
  }

  Future<void> _loadFormOnce() async {
    try {
      final forms = await _repo.loadForms(tenantId);
      final found = forms.firstWhere(
        (f) => f.formId == 'task_creation',
        orElse: () => forms.first,
      );
      _cachedTaskCreationForm = found;
      _cachedLoadError = null;
      if (!mounted) return;
      setState(() {
        _form = found;
        _loading = false;
      });
    } catch (e) {
      _cachedLoadError = e;
      if (!mounted) return;
      setState(() => _loading = false);
    }
  }

  Future<void> _createTaskFromPayload(
    Map<String, dynamic> values,
  ) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('You must be logged in to create a task'),
          backgroundColor: Colors.redAccent,
        ),
      );
      return;
    }

    setState(() => _submitting = true);

    try {
      final now = DateTime.now();
      final tasksCol = FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('tasks');

      final renderer = _rendererKey.currentState;
      if (renderer == null) {
        throw Exception('Form renderer not available');
      }

      final assignmentData = renderer.getAssignmentData();
      if (assignmentData == null || !assignmentData.isValid) {
        throw Exception('Invalid assignment data');
      }

      if (assignmentData.assignmentType == 'subordinate_unit') {
        final headUid =
            assignmentData.nodeToHeadUserMap[assignmentData.selectedNodeId];
        await _createSingleTask(
          tasksCol,
          values,
          user.uid,
          now,
          headUid,
          null,
        );
      } else if (assignmentData.assignmentType == 'team_member') {
        // âœ… pass leadMemberId into multi-user creation
        await _createTeamMemberTasks(
          tasksCol,
          values,
          user.uid,
          now,
          assignmentData.selectedUserIds,
          assignmentData.groupName,
          assignmentData.leadMemberId, // PASS lead member ID
        );
      }

      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Task(s) created successfully'),
          backgroundColor: Colors.cyan,
        ),
      );
      _rendererKey.currentState?.resetForm();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to create task: $e'),
          backgroundColor: Colors.redAccent,
        ),
      );
    } finally {
      if (mounted) setState(() => _submitting = false);
    }
  }

  // single-assignee path (subordinate unit)
  Future<void> _createSingleTask(
    CollectionReference tasksCol,
    Map<String, dynamic> values,
    String assignerUid,
    DateTime now,
    String? assignedToUserId,
    String? groupId, {
    String? groupName,
  }) async {
    final data = {
      'title': values['title'] ?? '',
      'description': values['description'] ?? '',
      'status': 'PENDING',
      'assigned_by': assignerUid,
      if (assignedToUserId != null) 'assigned_to': assignedToUserId,
      'created_at': now.toIso8601String(),
      'updated_at': now.toIso8601String(),
      'group_id': groupId,
      if (groupName != null && groupName.isNotEmpty) 'group_name': groupName,
      'custom_fields': Map<String, dynamic>.from(values),
    };

    data['custom_fields'].remove('title');
    data['custom_fields'].remove('description');
    data['custom_fields'].remove('assignee');

    final renderer = _rendererKey.currentState;
    final due = renderer?.getSelectedDueDate();
    if (due != null) {
      data['due_date'] = due.toIso8601String();
    }

    final docRef = await tasksCol.add(data);
    debugPrint('âœ… Task created for user: $assignedToUserId (doc: ${docRef.id})');
  }

  // multi-user path (team members) with lead_member
  Future<void> _createTeamMemberTasks(
    CollectionReference tasksCol,
    Map<String, dynamic> values,
    String assignerUid,
    DateTime now,
    List<String> userIds,
    String? groupName,
    String? leadMemberId, // NEW PARAMETER
  ) async {
    String? groupId;

    if (userIds.length > 1 &&
        groupName != null &&
        groupName.isNotEmpty) {
      final groupDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('task_groups')
          .add({
        'name': groupName,
        'created_by': assignerUid,
        'created_at': now.toIso8601String(),
        'member_count': userIds.length,
        'members': userIds,
        'lead_member': leadMemberId, // also store in group doc
      });
      groupId = groupDoc.id;
      debugPrint('âœ… Task group created: $groupName (id: $groupId)');
    }

    final allAssigneesString = userIds.join(',');

    final data = {
      'title': values['title'] ?? '',
      'description': values['description'] ?? '',
      'status': 'PENDING',
      'assigned_by': assignerUid,
      'assigned_to': allAssigneesString,
      'created_at': now.toIso8601String(),
      'updated_at': now.toIso8601String(),
      'group_id': groupId,
      'group_name': groupName,
      'lead_member': leadMemberId, // NEW FIELD on task
      'custom_fields': Map<String, dynamic>.from(values),
    };

    data['custom_fields'].remove('title');
    data['custom_fields'].remove('description');
    data['custom_fields'].remove('assignee');

    final renderer = _rendererKey.currentState;
    final due = renderer?.getSelectedDueDate();
    if (due != null) {
      data['due_date'] = due.toIso8601String();
    }

    final docRef = await tasksCol.add(data);
    debugPrint(
      'âœ… Group task created for users: $allAssigneesString '
      '(lead: $leadMemberId, doc: ${docRef.id})',
    );
  }

  Future<void> _onCreatePressed() async {
    final state = _rendererKey.currentState;
    if (state == null) return;

    final payload = await state.submitExternally();
    if (payload == null) return;

    await _createTaskFromPayload(payload);
  }

  @override
  Widget build(BuildContext context) {
    final loadError = _cachedLoadError;

    if (_loading) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
        ),
      );
    }

    if (_form == null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.error_outline_rounded,
              color: Colors.redAccent,
              size: 48,
            ),
            const SizedBox(height: 16),
            Text(
              loadError == null
                  ? 'Create Task form config not available.'
                  : 'Failed to load form',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.w600,
              ),
            ),
            if (loadError != null) ...[
              const SizedBox(height: 8),
              Text(
                loadError.toString(),
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 12,
                ),
                textAlign: TextAlign.center,
              ),
            ],
          ],
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (_form!.description.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: Text(
              _form!.description,
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 14,
              ),
            ),
          ),
        Expanded(
          child: TaskFormRenderer(
            key: _rendererKey,
            tenantId: tenantId,
            form: _form!,
          ),
        ),
        const SizedBox(height: 16),
        SizedBox(
          width: double.infinity,
          height: 48,
          child: FilledButton.icon(
            onPressed: _submitting ? null : _onCreatePressed,
            icon: _submitting
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      valueColor: AlwaysStoppedAnimation(Colors.black),
                    ),
                  )
                : const Icon(Icons.add_task_rounded),
            label: Text(_submitting ? 'Creatingâ€¦' : 'Create Task'),
          ),
        ),
      ],
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\mixins\user_data_loader_mixin.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

mixin UserDataLoaderMixin<T extends StatefulWidget> on State<T> {
  int? _currentUserLevel;
  String? _currentUserNodeId;

  int? get currentUserLevel => _currentUserLevel;
  String? get currentUserNodeId => _currentUserNodeId;

  Future<void> loadCurrentUserData(String tenantId) async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) return;

      final userDoc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('users')
          .doc(user.uid)
          .get();

      if (!userDoc.exists) return;

      final data = userDoc.data();
      if (data == null) return;

      if (mounted) {
        setState(() {
          _currentUserLevel = data['level'] as int?;
          _currentUserNodeId = data['nodeId'] as String?;
        });
      }

      debugPrint(
          'Loaded current user: level=$_currentUserLevel, nodeId=$_currentUserNodeId');
    } catch (e) {
      debugPrint('Error loading current user data: $e');
    }
  }
}

================================================================================

// File: lib\task\pages\create_task_page\models\assignment_data.dart
class AssignmentData {
  final String assignmentType; // 'subordinate_unit' or 'team_member'
  final String? selectedNodeId; // for subordinate_unit
  final List<String> selectedUserIds; // for team_member
  final String? groupName; // for multi-user team_member
  final String? leadMemberId; // â† NEW: lead member UID for groups
  final Map<String, String> nodeToHeadUserMap; // nodeId -> headUserId mapping

  AssignmentData({
    required this.assignmentType,
    this.selectedNodeId,
    this.selectedUserIds = const [],
    this.groupName,
    this.leadMemberId,
    this.nodeToHeadUserMap = const {},
  });

  bool get isValid {
    if (assignmentType == 'subordinate_unit') {
      return selectedNodeId != null && selectedNodeId != 'none';
    } else if (assignmentType == 'team_member') {
      if (selectedUserIds.isEmpty) return false;
      
      // If multiple users, group name AND lead member are required
      if (selectedUserIds.length > 1) {
        return groupName != null && 
               groupName!.trim().isNotEmpty &&
               leadMemberId != null &&
               selectedUserIds.contains(leadMemberId);
      }
      return true;
    }
    return false;
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\assignment_type_selector.dart
import 'package:flutter/material.dart';
import '../../../../core/glass_container.dart';

class AssignmentTypeSelector extends StatelessWidget {
  final String? selectedType;
  final ValueChanged<String?> onChanged;

  const AssignmentTypeSelector({
    super.key,
    required this.selectedType,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    final items = [
      const DropdownMenuItem(
        value: 'subordinate_unit',
        child: Text(
          'Subordinate Unit (Department/Team)',
          style: TextStyle(color: Colors.white),
        ),
      ),
      const DropdownMenuItem(
        value: 'team_member',
        child: Text(
          'Team Member (Colleague)',
          style: TextStyle(color: Colors.white),
        ),
      ),
    ];

    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: PopupMenuButton<String>(
        color: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(14),
        ),
        offset: const Offset(0, 8),
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: 'Assignment Type',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon: const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
          ),
          child: Text(
            selectedType == 'subordinate_unit'
                ? 'Subordinate Unit'
                : selectedType == 'team_member'
                    ? 'Team Member'
                    : 'Select Type',
            style: const TextStyle(color: Colors.white),
          ),
        ),
        itemBuilder: (context) => items
            .map(
              (item) => PopupMenuItem<String>(
                value: item.value,
                padding: EdgeInsets.zero,
                child: GlassContainer(
                  blur: 28,
                  opacity: 0.3,
                  tint: Colors.black,
                  blurMode: GlassBlurMode.perWidget,
                  borderRadius: BorderRadius.circular(10),
                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: SizedBox(
                    width: 250,
                    child: item.child,
                  ),
                ),
              ),
            )
            .toList(),
        onSelected: onChanged,
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\dynamic_date_field.dart
import 'package:flutter/material.dart';
import '../../../../core/glass_container.dart';

class DynamicDateField extends StatefulWidget {
  final String label;
  final bool required;
  final ValueChanged<DateTime?> onChanged;

  const DynamicDateField({
    super.key,
    required this.label,
    required this.required,
    required this.onChanged,
  });

  @override
  State<DynamicDateField> createState() => _DynamicDateFieldState();
}

class _DynamicDateFieldState extends State<DynamicDateField> {
  DateTime? _value;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: InkWell(
        onTap: _pickDateTime,
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: widget.label,
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon:
                const Icon(Icons.calendar_today, color: Colors.cyanAccent),
          ),
          child: Text(
            _value == null
                ? 'Select date & time'
                : '${_value!.year}-${_value!.month.toString().padLeft(2, '0')}-${_value!.day.toString().padLeft(2, '0')} '
                    '${_value!.hour.toString().padLeft(2, '0')}:${_value!.minute.toString().padLeft(2, '0')}',
            style: const TextStyle(color: Colors.white),
          ),
        ),
      ),
    );
  }

  Future<void> _pickDateTime() async {
    final now = DateTime.now();
    final initial = _value ?? now;

    final pickedDate = await showDatePicker(
      context: context,
      initialDate: initial.isBefore(now) ? now : initial,
      firstDate: now,
      lastDate: DateTime(now.year + 10),
      builder: (context, child) {
        return Theme(
          data: ThemeData.dark().copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Colors.cyanAccent,
              onPrimary: Colors.black,
              surface: Colors.transparent,
              onSurface: Colors.white,
            ),
            dialogBackgroundColor: Colors.transparent,
          ),
          child: _wrapGlass(child!),
        );
      },
    );

    if (pickedDate == null) return;

    final pickedTime = await showTimePicker(
      context: context,
      initialTime: TimeOfDay.fromDateTime(initial),
      builder: (context, child) {
        return Theme(
          data: ThemeData.dark().copyWith(
            colorScheme: const ColorScheme.dark(
              primary: Colors.cyanAccent,
              onPrimary: Colors.black,
              surface: Colors.transparent,
              onSurface: Colors.white,
            ),
            dialogBackgroundColor: Colors.transparent,
          ),
          child: _wrapGlass(child!),
        );
      },
    );

    if (pickedTime == null) return;

    final combined = DateTime(
      pickedDate.year,
      pickedDate.month,
      pickedDate.day,
      pickedTime.hour,
      pickedTime.minute,
    );

    final clamped = combined.isBefore(now) ? now : combined;
    setState(() => _value = clamped);
    widget.onChanged(clamped);
  }

  Widget _wrapGlass(Widget child) {
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(
          minWidth: 640,
          maxWidth: 640,
          minHeight: 420,
          maxHeight: 420,
        ),
        child: GlassContainer(
          blur: 40,
          opacity: 0.22,
          tint: Colors.black,
          borderRadius: BorderRadius.circular(22),
          blurMode: GlassBlurMode.perWidget,
          padding: const EdgeInsets.all(8),
          child: ClipRRect(
            borderRadius: BorderRadius.circular(18),
            child: child,
          ),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\task_form_renderer.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import '../../../../Developer/DynamicForms/form_models.dart';
import '../../../../core/glass_container.dart';
import '../mixins/user_data_loader_mixin.dart';
import '../models/assignment_data.dart';
import 'assignment_type_selector.dart';
import 'dynamic_date_field.dart';
import 'team_member_selector.dart';

class TaskFormRenderer extends StatefulWidget {
  final String tenantId;
  final FormSchemaMeta form;

  const TaskFormRenderer({
    super.key,
    required this.tenantId,
    required this.form,
  });

  @override
  State<TaskFormRenderer> createState() => TaskFormRendererState();
}

class TaskFormRendererState extends State<TaskFormRenderer>
    with UserDataLoaderMixin {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, dynamic> _values = {};
  final Map<String, bool> _checkboxValues = {};
  final Map<String, String?> _dropdownValues = {};
  final Map<String, List<DropdownMenuItem<String>>> _dropdownItems = {};
  final Map<String, bool> _loadingDropdown = {};

  // Assignment tracking
  String? _assignmentType;
  String? _selectedNodeId;
  List<String> _selectedUserIds = [];
  String? _groupName;
  String? _leadMemberId; // NEW: selected lead member UID
  Map<String, String> _nodeToHeadUserMap = {};

  DateTime? getSelectedDueDate() {
    final key = firstDateFieldKey;
    if (key == null) return null;
    final v = _values[key];
    return v is DateTime ? v : null;
  }

  String? get firstDateFieldKey {
    for (final f in widget.form.fields) {
      if (f.type == 'date') return f.id;
    }
    return null;
  }

  AssignmentData? getAssignmentData() {
    return AssignmentData(
      assignmentType: _assignmentType ?? '',
      selectedNodeId: _selectedNodeId,
      selectedUserIds: _selectedUserIds,
      groupName: _groupName,
      leadMemberId: _leadMemberId, // NEW
      nodeToHeadUserMap: _nodeToHeadUserMap,
    );
  }

  @override
  void initState() {
    super.initState();
    loadCurrentUserData(widget.tenantId);

    for (final field in widget.form.fields) {
      if (field.type == 'checkbox') {
        _checkboxValues[field.id] = false;
      } else if (field.type == 'dropdown') {
        _dropdownValues[field.id] =
            field.options.isNotEmpty ? field.options.first.toString() : null;
        _loadDropdownOptions(field);
      } else if (field.type == 'date') {
        _values[field.id] = null;
      } else {
        _controllers[field.id] = TextEditingController();
      }
    }
  }

  @override
  void dispose() {
    for (final c in _controllers.values) {
      c.dispose();
    }
    super.dispose();
  }

  void resetForm() {
    _formKey.currentState?.reset();
    for (final c in _controllers.values) {
      c.clear();
    }
    for (final key in _checkboxValues.keys) {
      _checkboxValues[key] = false;
    }
    _assignmentType = null;
    _selectedNodeId = null;
    _selectedUserIds.clear();
    _groupName = null;
    _leadMemberId = null; // NEW
    _values.clear();
    setState(() {});
  }

  Future<void> _loadDropdownOptions(FormFieldMeta field) async {
    // Skip assignTo - custom assignment section handles it
    if (field.id.toLowerCase() == 'assignto' ||
        field.id.toLowerCase() == 'assign_to' ||
        field.label.toLowerCase().contains('assign to')) {
      return;
    }

    final canLoadFromFirestore = field.dataSource == 'firestore' &&
        field.collection != null &&
        field.displayField != null &&
        field.valueField != null;

    if (!canLoadFromFirestore) {
      _dropdownItems[field.id] = field.options
          .map(
            (o) => DropdownMenuItem<String>(
              value: o.toString(),
              child: Text(
                o.toString(),
                style: const TextStyle(color: Colors.white),
              ),
            ),
          )
          .toList();
      if (mounted) setState(() {});
      return;
    }

    if (mounted) setState(() => _loadingDropdown[field.id] = true);

    try {
      final snap = await FirebaseFirestore.instance
          .collection('tenants/${widget.tenantId}/${field.collection}')
          .get();

      final items = snap.docs.map((doc) {
        final data = doc.data();
        final value = data[field.valueField] ?? doc.id;
        final label = data[field.displayField] ?? value.toString();
        return DropdownMenuItem<String>(
          value: value.toString(),
          child: Text(
            label.toString(),
            style: const TextStyle(color: Colors.white),
          ),
        );
      }).toList();

      _dropdownItems[field.id] = items;
      if (_dropdownValues[field.id] == null && items.isNotEmpty) {
        _dropdownValues[field.id] = items.first.value;
      }
    } finally {
      if (mounted) setState(() => _loadingDropdown[field.id] = false);
    }
  }

  Future<void> _loadSubordinateUnits() async {
    if (currentUserLevel == null || currentUserNodeId == null) {
      await loadCurrentUserData(widget.tenantId);
    }

    if (currentUserLevel == null || currentUserNodeId == null) {
      debugPrint('Cannot load subordinate units: user data not available');
      return;
    }

    final targetLevel = currentUserLevel! + 1;

    try {
      final hierarchySnap = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(widget.tenantId)
          .collection('organizations')
          .doc('hierarchy')
          .collection('nodes')
          .where('level', isEqualTo: targetLevel)
          .where('isActive', isEqualTo: true)
          .where('parentId', isEqualTo: currentUserNodeId)
          .get();

      final Map<String, String> nodeToHead = {};
      final List<DropdownMenuItem<String>> items = [];

      for (final nodeDoc in hierarchySnap.docs) {
        final nodeId = nodeDoc.id;
        final nodeData = nodeDoc.data();
        final nodeName = nodeData['name'] as String? ?? nodeId;
        final nodeType = nodeData['type'] as String? ?? 'unit';

        final headSnap = await FirebaseFirestore.instance
            .collection('tenants')
            .doc(widget.tenantId)
            .collection('users')
            .where('nodeId', isEqualTo: nodeId)
            .where('level', isEqualTo: targetLevel)
            .where('employeeType', isEqualTo: 'head')
            .where('status', isEqualTo: 'active')
            .limit(1)
            .get();

        if (headSnap.docs.isNotEmpty) {
          final headUserId = headSnap.docs.first.id;
          nodeToHead[nodeId] = headUserId;

          items.add(
            DropdownMenuItem<String>(
              value: nodeId,
              child: Text(
                '$nodeName - $nodeType',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          );
        }
      }

      if (items.isEmpty) {
        items.add(
          const DropdownMenuItem<String>(
            value: 'none',
            child: Text(
              'No subordinate units found',
              style: TextStyle(color: Colors.white70),
            ),
          ),
        );
      }

      setState(() {
        _nodeToHeadUserMap = nodeToHead;
        _dropdownItems['subordinate_unit_selector'] = items;
        if (_selectedNodeId == null && items.isNotEmpty) {
          _selectedNodeId = items.first.value;
        }
      });
    } catch (e) {
      debugPrint('Error loading subordinate units: $e');
    }
  }

  String? _runValidation(FormFieldMeta field, String value) {
    if (field.required && value.isEmpty) {
      return '${field.label} is required';
    }
    if (field.type == 'email' && value.isNotEmpty) {
      final ok = RegExp(r'^[^@]+@[^@]+\.[^@]+$').hasMatch(value);
      if (!ok) return 'Invalid email';
    }
    if (field.validation != null && value.isNotEmpty) {
      final re = RegExp(field.validation!);
      if (!re.hasMatch(value)) {
        return 'Invalid ${field.label}';
      }
    }
    return null;
  }

  Future<Map<String, dynamic>?> submitExternally() async {
    final ok = _formKey.currentState?.validate() ?? false;
    if (!ok) return null;

    final assignmentData = getAssignmentData();
    if (assignmentData == null || !assignmentData.isValid) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Please complete assignment selection'),
          backgroundColor: Colors.redAccent,
        ),
      );
      return null;
    }

    for (final entry in _controllers.entries) {
      _values[entry.key] = entry.value.text.trim();
    }
    for (final entry in _checkboxValues.entries) {
      _values[entry.key] = entry.value;
    }
    for (final entry in _dropdownValues.entries) {
      _values[entry.key] = entry.value;
    }

    for (final field in widget.form.fields) {
      if (field.type == 'date') {
        if (!_values.containsKey(field.id)) {
          _values[field.id] = null;
        }
      }
    }

    return Map.from(_values);
  }

  Widget _buildField(FormFieldMeta field) {
    if (field.id.toLowerCase() == 'assignto' ||
        field.id.toLowerCase() == 'assign_to' ||
        field.label.toLowerCase().contains('assign to')) {
      return const SizedBox.shrink();
    }

    switch (field.type) {
      case 'email':
      case 'text':
      case 'password':
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: TextFormField(
            controller: _controllers[field.id],
            obscureText: field.type == 'password',
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              labelText: field.label,
              labelStyle: const TextStyle(color: Colors.white70),
              floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
              enabledBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.white24),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.cyanAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              errorBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.redAccent),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedErrorBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.redAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              filled: true,
              fillColor: Colors.white.withOpacity(0.04),
            ),
            validator: (v) => _runValidation(field, v?.trim() ?? ''),
          ),
        );

      case 'dropdown':
        final loading = _loadingDropdown[field.id] ?? false;
        final options = _dropdownItems[field.id] ??
            field.options
                .map(
                  (o) => DropdownMenuItem<String>(
                    value: o.toString(),
                    child: Text(o.toString()),
                  ),
                )
                .toList();

        if (loading) {
          return const Padding(
            padding: EdgeInsets.only(bottom: 16.0),
            child: Center(
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          );
        }

        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: PopupMenuButton<String>(
            color: Colors.transparent,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(14),
            ),
            offset: const Offset(0, 8),
            child: InputDecorator(
              decoration: InputDecoration(
                labelText: field.label,
                labelStyle: const TextStyle(color: Colors.white70),
                floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
                enabledBorder: OutlineInputBorder(
                  borderSide: const BorderSide(color: Colors.white24),
                  borderRadius: BorderRadius.circular(18),
                ),
                focusedBorder: OutlineInputBorder(
                  borderSide:
                      const BorderSide(color: Colors.cyanAccent, width: 2),
                  borderRadius: BorderRadius.circular(18),
                ),
                filled: true,
                fillColor: Colors.white.withOpacity(0.04),
                suffixIcon:
                    const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
              ),
              child: Text(
                _dropdownValues[field.id] ?? 'Select ${field.label}',
                style: const TextStyle(color: Colors.white),
              ),
            ),
            itemBuilder: (context) => options
                .map(
                  (item) => PopupMenuItem<String>(
                    value: item.value,
                    padding: EdgeInsets.zero,
                    child: GlassContainer(
                      blur: 28,
                      opacity: 0.3,
                      tint: Colors.black,
                      blurMode: GlassBlurMode.perWidget,
                      borderRadius: BorderRadius.circular(10),
                      padding: const EdgeInsets.symmetric(
                          horizontal: 16, vertical: 12),
                      child: SizedBox(
                        width: 200,
                        child: item.child,
                      ),
                    ),
                  ),
                )
                .toList(),
            onSelected: (v) {
              setState(() => _dropdownValues[field.id] = v);
            },
          ),
        );

      case 'checkbox':
        return Padding(
          padding: const EdgeInsets.only(bottom: 12.0),
          child: Container(
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.04),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: Colors.white24),
            ),
            child: CheckboxListTile(
              value: _checkboxValues[field.id] ?? false,
              onChanged: (v) {
                setState(() => _checkboxValues[field.id] = v ?? false);
              },
              title: Text(
                field.label,
                style: const TextStyle(color: Colors.white),
              ),
              activeColor: Colors.cyanAccent,
              checkColor: Colors.black,
              controlAffinity: ListTileControlAffinity.leading,
            ),
          ),
        );

      case 'date':
        return DynamicDateField(
          label: field.label,
          required: field.required,
          onChanged: (value) => _values[field.id] = value,
        );

      default:
        return Padding(
          padding: const EdgeInsets.only(bottom: 16.0),
          child: Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.redAccent.withOpacity(0.1),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.redAccent),
            ),
            child: Text(
              'Unsupported field type: ${field.type}',
              style: const TextStyle(color: Colors.redAccent),
            ),
          ),
        );
    }
  }

  // helper to get label for selected subordinate node
  String _labelForSelectedNode(List<DropdownMenuItem<String>> items) {
    if (_selectedNodeId == null || _selectedNodeId == 'none') {
      return 'Select Subordinate Unit';
    }

    final item = items.firstWhere(
      (i) => i.value == _selectedNodeId,
      orElse: () => items.first,
    );

    if (item.child is Text) {
      return (item.child as Text).data ?? 'Select Subordinate Unit';
    }
    return 'Select Subordinate Unit';
  }

  Widget _buildSubordinateUnitDropdown() {
    final items = _dropdownItems['subordinate_unit_selector'] ?? [];

    if (items.isEmpty) {
      return const Padding(
        padding: EdgeInsets.all(16.0),
        child: Center(
          child: CircularProgressIndicator(
            valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
          ),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: PopupMenuButton<String>(
        color: Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(14),
        ),
        offset: const Offset(0, 8),
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: 'Assign To (Subordinate Unit)',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
            suffixIcon:
                const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
          ),
          child: Text(
            _labelForSelectedNode(items),
            style: const TextStyle(color: Colors.white),
          ),
        ),
        itemBuilder: (context) => items
            .map(
              (item) => PopupMenuItem<String>(
                value: item.value,
                padding: EdgeInsets.zero,
                child: GlassContainer(
                  blur: 28,
                  opacity: 0.3,
                  tint: Colors.black,
                  blurMode: GlassBlurMode.perWidget,
                  borderRadius: BorderRadius.circular(10),
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                  child: SizedBox(
                    width: 250,
                    child: item.child,
                  ),
                ),
              ),
            )
            .toList(),
        onSelected: (v) {
          setState(() => _selectedNodeId = v);
        },
      ),
    );
  }

  Widget _buildAssignmentSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SizedBox(height: 8),
        const Text(
          'Task Assignment',
          style: TextStyle(
            color: Colors.cyanAccent,
            fontSize: 16,
            fontWeight: FontWeight.w600,
          ),
        ),
        const SizedBox(height: 16),

        AssignmentTypeSelector(
          selectedType: _assignmentType,
          onChanged: (type) {
            setState(() {
              _assignmentType = type;
              _selectedNodeId = null;
              _selectedUserIds.clear();
              _groupName = null;
              _leadMemberId = null; // reset lead
            });

            if (type == 'subordinate_unit') {
              _loadSubordinateUnits();
            }
          },
        ),

        if (_assignmentType == 'subordinate_unit') ...[
          _buildSubordinateUnitDropdown(),
        ] else if (_assignmentType == 'team_member') ...[
          if (currentUserNodeId != null && currentUserLevel != null) ...[
            TeamMemberSelector(
              tenantId: widget.tenantId,
              currentNodeId: currentUserNodeId!,
              currentLevel: currentUserLevel!,
              selectedUserIds: _selectedUserIds,
              onSelectionChanged: (userIds) {
                setState(() {
                  _selectedUserIds = userIds;
                  if (_leadMemberId != null &&
                      !userIds.contains(_leadMemberId)) {
                    _leadMemberId = null;
                  }
                });
              },
            ),
            const SizedBox(height: 16),

            if (_selectedUserIds.length > 1) ...[
              TextFormField(
                style: const TextStyle(color: Colors.white),
                decoration: InputDecoration(
                  labelText: 'Group Name *',
                  labelStyle: const TextStyle(color: Colors.white70),
                  floatingLabelStyle:
                      const TextStyle(color: Colors.cyanAccent),
                  hintText: 'Enter a name for this task group',
                  hintStyle: const TextStyle(color: Colors.white38),
                  enabledBorder: OutlineInputBorder(
                    borderSide: const BorderSide(color: Colors.white24),
                    borderRadius: BorderRadius.circular(18),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderSide:
                        const BorderSide(color: Colors.cyanAccent, width: 2),
                    borderRadius: BorderRadius.circular(18),
                  ),
                  filled: true,
                  fillColor: Colors.white.withOpacity(0.04),
                ),
                validator: (v) {
                  if (_selectedUserIds.length > 1 &&
                      (v == null || v.trim().isEmpty)) {
                    return 'Group name is required for multi-user tasks';
                  }
                  return null;
                },
                onChanged: (value) {
                  _groupName = value.trim();
                },
              ),
              const SizedBox(height: 16),

              _buildLeadMemberDropdown(),

              const SizedBox(height: 8),
              const Text(
                'This task will be assigned to the selected team members as a group. The lead member will coordinate the task.',
                style: TextStyle(
                  color: Colors.white70,
                  fontSize: 12,
                  fontStyle: FontStyle.italic,
                ),
              ),
            ],
          ] else
            const Padding(
              padding: EdgeInsets.all(16.0),
              child: Text(
                'Loading user data...',
                style: TextStyle(color: Colors.white70),
              ),
            ),
        ],
      ],
    );
  }

  // Lead member dropdown built from selected users
  Widget _buildLeadMemberDropdown() {
    return FutureBuilder<List<Map<String, String>>>(
      future: _loadSelectedUserNames(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(8.0),
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          );
        }

        final userOptions = snapshot.data ?? [];
        if (userOptions.isEmpty) {
          return const SizedBox.shrink();
        }

        return PopupMenuButton<String>(
          color: Colors.transparent,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(14),
          ),
          offset: const Offset(0, 8),
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: 'Select Lead Member *',
              labelStyle: const TextStyle(color: Colors.white70),
              floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
              enabledBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.white24),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.cyanAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              errorBorder: OutlineInputBorder(
                borderSide: const BorderSide(color: Colors.redAccent),
                borderRadius: BorderRadius.circular(18),
              ),
              focusedErrorBorder: OutlineInputBorder(
                borderSide:
                    const BorderSide(color: Colors.redAccent, width: 2),
                borderRadius: BorderRadius.circular(18),
              ),
              filled: true,
              fillColor: Colors.white.withOpacity(0.04),
              suffixIcon:
                  const Icon(Icons.arrow_drop_down, color: Colors.cyanAccent),
            ),
            child: Text(
              _leadMemberId != null
                  ? userOptions
                          .firstWhere(
                            (u) => u['uid'] == _leadMemberId,
                            orElse: () => {'name': 'Select Lead Member'},
                          )['name'] ??
                      'Select Lead Member'
                  : 'Select Lead Member',
              style: const TextStyle(color: Colors.white),
            ),
          ),
          itemBuilder: (context) => userOptions
              .map(
                (user) => PopupMenuItem<String>(
                  value: user['uid'],
                  padding: EdgeInsets.zero,
                  child: GlassContainer(
                    blur: 28,
                    opacity: 0.3,
                    tint: Colors.black,
                    blurMode: GlassBlurMode.perWidget,
                    borderRadius: BorderRadius.circular(10),
                    padding: const EdgeInsets.symmetric(
                        horizontal: 16, vertical: 12),
                    child: SizedBox(
                      width: 250,
                      child: Row(
                        children: [
                          const Icon(Icons.star,
                              size: 16, color: Colors.amberAccent),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              user['name'] ?? '',
                              style: const TextStyle(color: Colors.white),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              )
              .toList(),
          onSelected: (uid) {
            setState(() => _leadMemberId = uid);
          },
        );
      },
    );
  }

  
Future<List<Map<String, String>>> _loadSelectedUserNames() async {
  if (_selectedUserIds.isEmpty) return [];

  try {
    final userDocs = await Future.wait(
      _selectedUserIds.map(
        (uid) => FirebaseFirestore.instance
            .collection('tenants')
            .doc(widget.tenantId)
            .collection('users')
            .doc(uid)
            .get(),
      ),
    );

    return userDocs.map((doc) {
      if (!doc.exists) {
        // fallback to UID if doc missing
        return {'uid': doc.id, 'name': doc.id};
      }

      final data = doc.data();
      final fullName = data?['profiledata']?['fullName'] ??
          data?['fullName'] ??
          doc.id;

      return {
        'uid': doc.id,
        'name': fullName.toString(), // âœ… actual name used in UI
      };
    }).toList();
  } catch (e) {
    debugPrint('Error loading user names: $e');
    return [];
  }
}

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: ListView(
        children: [
          ...widget.form.fields.map(_buildField),
          const SizedBox(height: 16),
          _buildAssignmentSection(),
        ],
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\create_task_page\widgets\team_member_selector.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

class TeamMemberSelector extends StatefulWidget {
  final String tenantId;
  final String currentNodeId;
  final int currentLevel;
  final List<String> selectedUserIds;
  final ValueChanged<List<String>> onSelectionChanged;

  const TeamMemberSelector({
    super.key,
    required this.tenantId,
    required this.currentNodeId,
    required this.currentLevel,
    required this.selectedUserIds,
    required this.onSelectionChanged,
  });

  @override
  State<TeamMemberSelector> createState() => _TeamMemberSelectorState();
}

class _TeamMemberSelectorState extends State<TeamMemberSelector> {
  final TextEditingController _searchController = TextEditingController();
  List<Map<String, dynamic>> _allUsers = [];
  List<Map<String, dynamic>> _filteredUsers = [];
  bool _loading = true;

  @override
  void initState() {
    super.initState();
    _loadTeamMembers();
    _searchController.addListener(_filterUsers);
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Future<void> _loadTeamMembers() async {
    setState(() => _loading = true);

    try {
      final usersSnap = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(widget.tenantId)
          .collection('users')
          .where('nodeId', isEqualTo: widget.currentNodeId)
          .where('level', isEqualTo: widget.currentLevel)
          .where('status', isEqualTo: 'active')
          .get();

      _allUsers = usersSnap.docs.map((doc) {
        final data = doc.data();
        final uid = doc.id;

        // âœ… Use profile_data.fullName â†’ fallback to fullName â†’ fallback to uid
        final fullName =
            data['profiledata']?['fullName'] ?? data['fullName'] ?? uid;

        final designation = data['designation'] ?? 'No Designation';

        return {
          'uid': uid,
          'name': fullName,
          'designation': designation,
        };
      }).toList();

      _filteredUsers = List.from(_allUsers);
      debugPrint('Loaded ${_allUsers.length} team members');
    } catch (e) {
      debugPrint('Error loading team members: $e');
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  void _filterUsers() {
    final query = _searchController.text.toLowerCase();
    setState(() {
      if (query.isEmpty) {
        _filteredUsers = List.from(_allUsers);
      } else {
        _filteredUsers = _allUsers.where((user) {
          final name = (user['name'] as String).toLowerCase();
          final designation = (user['designation'] as String).toLowerCase();
          return name.contains(query) || designation.contains(query);
        }).toList();
      }
    });
  }

  void _toggleUser(String uid) {
    final newSelection = List<String>.from(widget.selectedUserIds);
    if (newSelection.contains(uid)) {
      newSelection.remove(uid);
    } else {
      newSelection.add(uid);
    }
    widget.onSelectionChanged(newSelection);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Search field
        TextFormField(
          controller: _searchController,
          style: const TextStyle(color: Colors.white),
          decoration: InputDecoration(
            labelText: 'Search Team Members',
            labelStyle: const TextStyle(color: Colors.white70),
            floatingLabelStyle: const TextStyle(color: Colors.cyanAccent),
            prefixIcon: const Icon(Icons.search, color: Colors.cyanAccent),
            enabledBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.white24),
              borderRadius: BorderRadius.circular(18),
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: const BorderSide(color: Colors.cyanAccent, width: 2),
              borderRadius: BorderRadius.circular(18),
            ),
            filled: true,
            fillColor: Colors.white.withOpacity(0.04),
          ),
        ),
        const SizedBox(height: 12),

        // Selected count
        if (widget.selectedUserIds.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Text(
              '${widget.selectedUserIds.length} member(s) selected',
              style: const TextStyle(
                color: Colors.cyanAccent,
                fontSize: 12,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),

        // User list
        if (_loading)
          const Center(
            child: Padding(
              padding: EdgeInsets.all(24.0),
              child: CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          )
        else if (_filteredUsers.isEmpty)
          const Padding(
            padding: EdgeInsets.all(24.0),
            child: Center(
              child: Text(
                'No team members found',
                style: TextStyle(color: Colors.white70),
              ),
            ),
          )
        else
          Container(
            constraints: const BoxConstraints(maxHeight: 300),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.04),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(color: Colors.white24),
            ),
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: _filteredUsers.length,
              itemBuilder: (context, index) {
                final user = _filteredUsers[index];
                final uid = user['uid'] as String;
                final isSelected = widget.selectedUserIds.contains(uid);

                return CheckboxListTile(
                  value: isSelected,
                  onChanged: (_) => _toggleUser(uid),
                  title: Text(
                    user['name'] as String, // âœ… shows fullName, not UID
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                  subtitle: Text(
                    user['designation'] as String, // e.g. "team_lead"
                    style: const TextStyle(
                      color: Colors.white70,
                      fontSize: 12,
                    ),
                  ),
                  activeColor: Colors.cyanAccent,
                  checkColor: Colors.black,
                  controlAffinity: ListTileControlAffinity.leading,
                );
              },
            ),
          ),
      ],
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\view_assigned_tasks_page.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

import '../../../core/glass_container.dart';
import 'models/assigned_task_view_model.dart';
import 'widgets/assigned_task_list.dart';
import 'widgets/assigned_task_workspace.dart';

class ViewAssignedTasksPage extends StatefulWidget {
  const ViewAssignedTasksPage({super.key});

  static const String tenantId = 'default_tenant';

  @override
  State<ViewAssignedTasksPage> createState() => _ViewAssignedTasksPageState();
}

class _ViewAssignedTasksPageState extends State<ViewAssignedTasksPage> {
  AssignedTaskViewModel? _selectedTask;

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    if (user == null) {
      return const Center(
        child: Text(
          'You must be logged in to see assigned tasks.',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    final uid = user.uid;

    final stream = FirebaseFirestore.instance
        .collection('tenants')
        .doc(ViewAssignedTasksPage.tenantId)
        .collection('tasks')
        .orderBy('created_at', descending: true)
        .snapshots();

    return StreamBuilder<QuerySnapshot<Map<String, dynamic>>>(
      stream: stream,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
            ),
          );
        }

        if (snapshot.hasError) {
          return _buildError(snapshot.error);
        }

        final allDocs = snapshot.data?.docs ?? [];

        // Filter tasks where current uid is in assigned_to (comma-separated)
        final myTasks = allDocs.where((doc) {
          final data = doc.data();
          final assignedTo = (data['assigned_to'] ?? '') as String;
          if (assignedTo.isEmpty) return false;
          final assignees =
              assignedTo.split(',').map((s) => s.trim()).toList();
          return assignees.contains(uid);
        }).toList();

        if (myTasks.isEmpty) {
          return const Center(
            child: Text(
              'No tasks are currently assigned to you.',
              style: TextStyle(color: Colors.white70),
            ),
          );
        }

        final models = myTasks.map((doc) {
          final data = doc.data();
          return AssignedTaskViewModel.fromFirestore(
            docId: doc.id,
            data: data,
          );
        }).toList();

        // Ensure selected task is valid
        if (_selectedTask != null) {
          final exists = models.any((t) => t.docId == _selectedTask!.docId);
          if (!exists) {
            _selectedTask = null;
          }
        }

        return Row(
          children: [
            // LEFT: list of assigned tasks
            Expanded(
              flex: 2,
              child: AssignedTaskList(
                tenantId: ViewAssignedTasksPage.tenantId,
                currentUserUid: uid,
                tasks: models,
                selectedTaskId: _selectedTask?.docId,
                onTaskSelected: (task) {
                  setState(() => _selectedTask = task);
                },
              ),
            ),


            // RIGHT: details / workspace for selected task
            Expanded(
              flex: 3,
              child: _selectedTask == null
                  ? _buildEmptyWorkspace()
                  : AssignedTaskWorkspace(
                      task: _selectedTask!,
                      currentUserUid: uid,
                      tenantId: ViewAssignedTasksPage.tenantId,
                      onBack: () {
                        setState(() => _selectedTask = null);
                      },
                    ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildEmptyWorkspace() {
    return Center(
      child: GlassContainer(
        blur: 18,
        opacity: 0.12,
        tint: Colors.black,
        borderRadius: BorderRadius.circular(18),
        padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 20),
        child: const Text(
          'Select a task from the left to see details.',
          style: TextStyle(
            color: Colors.white70,
            fontSize: 14,
          ),
        ),
      ),
    );
  }

  Widget _buildError(Object? error) {
    String debugMessage = 'Unknown snapshot error: $error';
    String consoleUrl = '';

    if (error is FirebaseException && error.message != null) {
      final msg = error.message!;
      final marker = 'https://';
      final idx = msg.indexOf(marker);
      if (idx != -1) {
        consoleUrl = msg.substring(idx).trim();
        debugPrint('ğŸ”¥ FIRESTORE INDEX URL: $consoleUrl');
      } else {
        debugPrint('Firestore error (no URL found): $msg');
      }
    } else {
      debugPrint(debugMessage);
    }

    return Center(
      child: Text(
        'Failed to load assigned tasks.\n'
        'Check debug console for Firestore details.',
        textAlign: TextAlign.center,
        style: const TextStyle(color: Colors.redAccent),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\models\assigned_task_view_model.dart
// lib/task/pages/view_assigned_tasks_page/models/assigned_task_view_model.dart

class AssignedTaskViewModel {
  final String docId;
  final String title;
  final String description;
  final String status;
  final String priority;
  final DateTime? dueDate;
  final String groupName;

  /// Raw comma-separated string from Firestore (`assigned_to`)
  final String assignedToRaw;

  /// Parsed list of assignee UIDs
  final List<String> assignedToUids;

  final int assigneeCount;

  /// UID of lead member (can be null)
  final String? leadMemberId;

  /// UID of user who assigned the task
  final String? assignedByUid;

  AssignedTaskViewModel({
    required this.docId,
    required this.title,
    required this.description,
    required this.status,
    required this.priority,
    required this.dueDate,
    required this.groupName,
    required this.assignedToRaw,
    required this.assignedToUids,
    required this.assigneeCount,
    required this.leadMemberId,
    required this.assignedByUid,
  });

  factory AssignedTaskViewModel.fromFirestore({
    required String docId,
    required Map<String, dynamic> data,
  }) {
    final title = (data['title'] ?? '') as String;
    final description = (data['description'] ?? '') as String;
    final status = (data['status'] ?? 'PENDING') as String;
    final priority =
        (data['custom_fields']?['priority'] ?? '').toString().toUpperCase();

    final dueIso = (data['due_date'] ?? '') as String;
    DateTime? due;
    if (dueIso.isNotEmpty) {
      try {
        due = DateTime.parse(dueIso);
      } catch (_) {
        due = null;
      }
    }

    final groupName = (data['group_name'] ?? '') as String;

    final assignedTo = (data['assigned_to'] ?? '') as String;
    final assignedToUids = assignedTo.isEmpty
        ? <String>[]
        : assignedTo.split(',').map((s) => s.trim()).where((s) => s.isNotEmpty).toList();
    final assigneeCount = assignedToUids.length;

    final leadMemberId = data['lead_member'] as String?;
    final assignedByUid = data['assigned_by'] as String?;

    return AssignedTaskViewModel(
      docId: docId,
      title: title,
      description: description,
      status: status,
      priority: priority,
      dueDate: due,
      groupName: groupName,
      assignedToRaw: assignedTo,
      assignedToUids: assignedToUids,
      assigneeCount: assigneeCount,
      leadMemberId: leadMemberId,
      assignedByUid: assignedByUid,
    );
  }

  bool get isGroupTask => groupName.isNotEmpty && assigneeCount > 1;
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_card.dart
import 'package:flutter/material.dart';

import '../../../../core/glass_container.dart';
import '../models/assigned_task_view_model.dart';
import 'lead_badge.dart';

class AssignedTaskCard extends StatelessWidget {
  final AssignedTaskViewModel task;
  final bool isSelected;
  final String? leadMemberName;
  final bool isCurrentUserLead;

  const AssignedTaskCard({
    super.key,
    required this.task,
    required this.isSelected,
    this.leadMemberName,
    required this.isCurrentUserLead, 
  });

  @override
  Widget build(BuildContext context) {
    final bgOpacity = isSelected ? 0.22 : 0.18;
    final borderColor =
        isSelected ? Colors.cyanAccent.withOpacity(0.8) : Colors.white12;

    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: borderColor, width: isSelected ? 1.2 : 0.6),
      ),
      child: GlassContainer(
        blur: 18,
        opacity: bgOpacity,
        tint: Colors.black,
        borderRadius: BorderRadius.circular(18),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildTitleRow(),
            const SizedBox(height: 4),
            if (task.groupName.isNotEmpty) _buildGroupRow(),
            _buildLeadRow(),
            if (task.description.isNotEmpty) ...[
              const SizedBox(height: 4),
              Text(
                task.description,
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 13,
                ),
              ),
            ],
            const SizedBox(height: 6),
            _buildStatusRow(),
          ],
        ),
      ),
    );
  }

  Widget _buildTitleRow() {
    return Row(
      children: [
        Expanded(
          child: Text(
            task.title.isEmpty ? '(No title)' : task.title,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        if (task.isGroupTask)
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
            decoration: BoxDecoration(
              color: Colors.purpleAccent.withOpacity(0.15),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: Colors.purpleAccent.withOpacity(0.8),
                width: 0.8,
              ),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.group,
                    size: 14, color: Colors.purpleAccent),
                const SizedBox(width: 4),
                Text(
                  '${task.assigneeCount} members',
                  style: const TextStyle(
                    color: Colors.purpleAccent,
                    fontSize: 11,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),
      ],
    );
  }

  Widget _buildGroupRow() {
    return Padding(
      padding: const EdgeInsets.only(bottom: 2),
      child: Text(
        'Group: ${task.groupName}',
        style: const TextStyle(
          color: Colors.purpleAccent,
          fontSize: 12,
          fontStyle: FontStyle.italic,
        ),
      ),
    );
  }

  Widget _buildLeadRow() {
    final name = (leadMemberName != null && leadMemberName!.isNotEmpty)
        ? leadMemberName
        : task.leadMemberId;

    String leadText;
    if (name == null || name.isEmpty) {
      leadText = 'Lead: â€”';
    } else if (isCurrentUserLead) {
      leadText = 'Lead: You ($name)';  // â† Show "You (Full Name)"
    } else {
      leadText = 'Lead: $name';
    }

    return Padding(
      padding: const EdgeInsets.only(bottom: 2),
      child: Text(
        leadText,
        style: const TextStyle(
          color: Colors.amberAccent,
          fontSize: 12,
        ),
      ),
    );
  }



  Widget _buildStatusRow() {
    return Row(
      children: [
        if (task.priority.isNotEmpty)
          _Chip(
            label: task.priority,
            color: Colors.deepOrangeAccent,
          ),
        const SizedBox(width: 6),
        _Chip(
          label: task.status,
          color: task.status == 'COMPLETED'
              ? Colors.greenAccent
              : Colors.cyanAccent,
        ),
        const Spacer(),
        if (task.dueDate != null)
          Text(
            'Due: '
            '${task.dueDate!.year}-${task.dueDate!.month.toString().padLeft(2, '0')}-'
            '${task.dueDate!.day.toString().padLeft(2, '0')} '
            '${task.dueDate!.hour.toString().padLeft(2, '0')}:'
            '${task.dueDate!.minute.toString().padLeft(2, '0')}',
            style: const TextStyle(
              color: Colors.white60,
              fontSize: 12,
            ),
          ),
      ],
    );
  }
}

class _Chip extends StatelessWidget {
  final String label;
  final Color color;

  const _Chip({required this.label, required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.8), width: 0.8),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontSize: 11,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_list.dart
// lib/task/pages/view_assigned_tasks_page/widgets/assigned_task_list.dart

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import '../models/assigned_task_view_model.dart';
import 'assigned_task_card.dart';

class AssignedTaskList extends StatefulWidget {
  final String tenantId;
  final String currentUserUid;
  final List<AssignedTaskViewModel> tasks;

  /// ID of the currently selected task (can be null)
  final String? selectedTaskId;

  /// Callback when user taps a task in the list
  final ValueChanged<AssignedTaskViewModel> onTaskSelected;

  const AssignedTaskList({
    super.key,
    required this.tenantId,
    required this.currentUserUid,
    required this.tasks,
    required this.selectedTaskId,
    required this.onTaskSelected,
  });

  @override
  State<AssignedTaskList> createState() => _AssignedTaskListState();
}

class _AssignedTaskListState extends State<AssignedTaskList> {
  final Map<String, String> _userNameCache = {};

  @override
  void initState() {
    super.initState();
    _prefetchLeadNames();
  }

  @override
  void didUpdateWidget(covariant AssignedTaskList oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.tasks != widget.tasks) {
      _prefetchLeadNames();
    }
  }

  Future<void> _prefetchLeadNames() async {
    final leadIds = widget.tasks
        .map((t) => t.leadMemberId)
        .whereType<String>()
        .where((id) => !_userNameCache.containsKey(id))
        .toSet();

    if (leadIds.isEmpty) return;

    try {
      final futures = leadIds.map((uid) async {
        final doc = await FirebaseFirestore.instance
            .collection('tenants')
            .doc(widget.tenantId)
            .collection('users')
            .doc(uid)
            .get();

        if (!doc.exists) {
          _userNameCache[uid] = uid;
          return;
        }

        final data = doc.data();
        final fullName = data?['profiledata']?['fullName'] ??
            data?['fullName'] ??
            uid;
        _userNameCache[uid] = fullName.toString();
      });

      await Future.wait(futures);
      if (mounted) setState(() {});
    } catch (e) {
      debugPrint('Error prefetching lead member names: $e');
    }
  }

  String _getLeadName(String? leadUid) {
    if (leadUid == null) return '';
    return _userNameCache[leadUid] ?? leadUid;
  }

  @override
  Widget build(BuildContext context) {
    if (widget.tasks.isEmpty) {
      return const Center(
        child: Text(
          'No tasks are currently assigned to you.',
          style: TextStyle(color: Colors.white70),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: ListView.separated(
        itemCount: widget.tasks.length,
        separatorBuilder: (_, __) => const SizedBox(height: 10),
        itemBuilder: (context, index) {
          final task = widget.tasks[index];
          final leadName = _getLeadName(task.leadMemberId);
          final isLead = task.leadMemberId == widget.currentUserUid;
          final isSelected = task.docId == widget.selectedTaskId;

          return GestureDetector(
            onTap: () => widget.onTaskSelected(task),
            child: AssignedTaskCard(
              task: task,
              isSelected: isSelected,
              leadMemberName: leadName,
              isCurrentUserLead: isLead,
            ),
          );
        },
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\assigned_task_workspace.dart
import 'package:flutter/material.dart';

import '../../../../core/glass_container.dart';
import '../models/assigned_task_view_model.dart';
import 'task_details_panel.dart';
import '../../../../chat/models/chat_channel.dart';
import '../../../../chat/models/chat_conversation.dart';
import '../../../../chat/widgets/chat_shell.dart';

class AssignedTaskWorkspace extends StatefulWidget {
  final AssignedTaskViewModel task;
  final String currentUserUid;
  final String tenantId;
  final VoidCallback onBack;

  const AssignedTaskWorkspace({
    super.key,
    required this.task,
    required this.currentUserUid,
    required this.tenantId,
    required this.onBack,
  });

  @override
  State<AssignedTaskWorkspace> createState() => _AssignedTaskWorkspaceState();
}

class _AssignedTaskWorkspaceState extends State<AssignedTaskWorkspace> {
  // later this can control which subâ€‘view is visible: details, Ask Doubt chat, Submit Progress chat, etc.
  String _activeView = 'details'; // 'details' | 'ask_doubt' | 'submit_progress'

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Top bar with back button and title
        Padding(
          padding: const EdgeInsets.fromLTRB(8, 8, 8, 4),
          child: Row(
            children: [
              IconButton(
                icon: const Icon(Icons.arrow_back_ios_new_rounded,
                    color: Colors.white70, size: 18),
                onPressed: widget.onBack,
                tooltip: 'Back to list',
              ),
              const SizedBox(width: 4),
              Text(
                'Task details',
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
        ),

        const SizedBox(height: 4),

        Expanded(
          child: GlassContainer(
            blur: 18,
            opacity: 0.1,
            tint: Colors.black,
            borderRadius: BorderRadius.circular(18),
            padding: const EdgeInsets.all(16),
            child: _buildActiveView(),
          ),
        ),
      ],
    );
  }

    Widget _buildActiveView() {
    final conversation = ChatConversation(
      conversationId: widget.task.docId,
      taskTitle: widget.task.title,
      assignedByUid: widget.task.assignedByUid ?? '',
      assignedToUids: widget.task.assignedToUids,
      leadMemberUid: widget.task.leadMemberId,
      groupName: widget.task.groupName,
      dueDate: widget.task.dueDate,
    );

    switch (_activeView) {
      case 'ask_doubt':
        return ChatShell(
          tenantId: widget.tenantId,
          conversation: conversation,
          channel: ChatChannel.assignedBy,
          currentUserId: widget.currentUserUid,
        );

      case 'submit_progress':
        // For now, reuse the same assignedBy channel; later you can preâ€‘tag messages as progress
        return ChatShell(
          tenantId: widget.tenantId,
          conversation: conversation,
          channel: ChatChannel.assignedBy,
          currentUserId: widget.currentUserUid,
        );

      case 'details':
      default:
        return TaskDetailsPanel(
          task: widget.task,
          currentUserUid: widget.currentUserUid,
          onAskDoubt: () {
            setState(() => _activeView = 'ask_doubt');
          },
          onSubmitProgress: () {
            setState(() => _activeView = 'submit_progress');
          },
        );
    }
  }

}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\lead_badge.dart
import 'package:flutter/material.dart';

class LeadBadge extends StatelessWidget {
  final bool isCurrentUserLead;

  const LeadBadge({
    super.key,
    required this.isCurrentUserLead,
  });

  @override
  Widget build(BuildContext context) {
    if (!isCurrentUserLead) return const SizedBox.shrink();

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 3),
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.16),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.amber, width: 0.8),
      ),
      child: const Text(
        'YOU ARE THE LEAD',
        style: TextStyle(
          color: Colors.amber,
          fontSize: 10,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
  }
}

================================================================================

// File: lib\task\pages\view_assigned_tasks_page\widgets\task_details_panel.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';

import '../../../../core/glass_container.dart';
import '../models/assigned_task_view_model.dart';
import 'lead_badge.dart';

class TaskDetailsPanel extends StatefulWidget {
  final AssignedTaskViewModel task;
  final String currentUserUid;
  final VoidCallback onAskDoubt;
  final VoidCallback onSubmitProgress;

  const TaskDetailsPanel({
    super.key,
    required this.task,
    required this.currentUserUid,
    required this.onAskDoubt,
    required this.onSubmitProgress,
  });

  @override
  State<TaskDetailsPanel> createState() => _TaskDetailsPanelState();
}

class _TaskDetailsPanelState extends State<TaskDetailsPanel> {
  static const String tenantId = 'default_tenant';

  String? _assignedByName;
  List<String>? _assignedToNames;
  String? _leadMemberName;
  bool _loadingNames = true;

  @override
  void initState() {
    super.initState();
    _loadNames();
  }

  @override
  void didUpdateWidget(covariant TaskDetailsPanel oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.task.docId != widget.task.docId) {
      _loadNames();
    }
  }

  Future<void> _loadNames() async {
    setState(() {
      _loadingNames = true;
      _assignedByName = null;
      _assignedToNames = null;
      _leadMemberName = null;
    });

    try {
      final assignedByUid = widget.task.assignedByUid;
      final leadUid = widget.task.leadMemberId;
      final assigneeUids = widget.task.assignedToUids;

      final futures = <Future<void>>[];

      if (assignedByUid != null) {
        futures.add(_loadSingleUserName(assignedByUid)
            .then((name) => _assignedByName = name));
      }

      if (leadUid != null) {
        futures.add(_loadSingleUserName(leadUid)
            .then((name) => _leadMemberName = name));
      }

      if (assigneeUids.isNotEmpty) {
        futures.add(_loadMultipleUserNames(assigneeUids)
            .then((names) => _assignedToNames = names));
      }

      await Future.wait(futures);
    } catch (e) {
      debugPrint('Error loading names for task details: $e');
    } finally {
      if (mounted) {
        setState(() {
          _loadingNames = false;
        });
      }
    }
  }

  Future<String> _loadSingleUserName(String uid) async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('tenants')
          .doc(tenantId)
          .collection('users')
          .doc(uid)
          .get();

      if (!doc.exists) return uid;

      final data = doc.data();
      final fullName = data?['profiledata']?['fullName'] ??
          data?['fullName'] ??
          uid;
      return fullName.toString();
    } catch (_) {
      return uid;
    }
  }

  Future<List<String>> _loadMultipleUserNames(List<String> uids) async {
    final results = <String>[];
    for (final uid in uids) {
      results.add(await _loadSingleUserName(uid));
    }
    return results;
  }

  @override
  Widget build(BuildContext context) {
    final task = widget.task;
    final isCurrentUserLead =
        task.leadMemberId != null && task.leadMemberId == widget.currentUserUid;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header row: title + lead badge (if current user is lead)
        Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Expanded(
              child: Text(
                task.title.isEmpty ? '(No title)' : task.title,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 18,
                  fontWeight: FontWeight.w700,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            const SizedBox(width: 8),
            LeadBadge(isCurrentUserLead: isCurrentUserLead),
          ],
        ),

        const SizedBox(height: 8),

        if (task.groupName.isNotEmpty)
          Text(
            'Group: ${task.groupName}',
            style: const TextStyle(
              color: Colors.purpleAccent,
              fontSize: 12,
              fontStyle: FontStyle.italic,
            ),
          ),

        const SizedBox(height: 4),

        if (task.description.isNotEmpty)
          Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Text(
              task.description,
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 13,
              ),
            ),
          ),

        const Divider(color: Colors.white10, height: 16),

        if (_loadingNames)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 8),
            child: SizedBox(
              height: 20,
              width: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation(Colors.cyanAccent),
              ),
            ),
          )
        else
          _buildMetaRows(isCurrentUserLead),

        const Spacer(),

        _buildFooterButtons(isCurrentUserLead),
      ],
    );
  }

  Widget _buildMetaRows(bool isCurrentUserLead) {
    final task = widget.task;

    final assignedBy = _assignedByName ?? task.assignedByUid ?? 'Unknown';
    final assignees = _assignedToNames ?? task.assignedToUids;
    final lead = _leadMemberName ?? task.leadMemberId ?? 'â€”';

    final leadLabel = isCurrentUserLead ? 'You ($lead)' : lead;

    final due = task.dueDate;
    final dueText = due == null
        ? 'â€”'
        : '${_monthName(due.month)} ${due.day}, ${due.year} '
          'at ${due.hour.toString().padLeft(2, '0')}:${due.minute.toString().padLeft(2, '0')}';

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _metaRow('Assigned by', assignedBy),
        const SizedBox(height: 4),
        _metaRow('Assigned to', assignees.isEmpty ? 'â€”' : assignees.join(', ')),
        const SizedBox(height: 4),
        _metaRow('Lead', leadLabel),
        const SizedBox(height: 4),
        _metaRow('Status', task.status),
        const SizedBox(height: 4),
        _metaRow('Priority', task.priority.isEmpty ? 'â€”' : task.priority),
        const SizedBox(height: 4),
        _metaRow('Due date', dueText),
      ],
    );
  }

  Widget _metaRow(String label, String value) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SizedBox(
          width: 90,
          child: Text(
            '$label:',
            style: const TextStyle(
              color: Colors.white54,
              fontSize: 12,
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
        const SizedBox(width: 4),
        Expanded(
          child: Text(
            value,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 12,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildFooterButtons(bool isCurrentUserLead) {
    return Row(
      children: [
        Expanded(
          child: OutlinedButton.icon(
            onPressed: widget.onAskDoubt,
            style: OutlinedButton.styleFrom(
              side: const BorderSide(color: Colors.cyanAccent),
              foregroundColor: Colors.cyanAccent,
              padding: const EdgeInsets.symmetric(vertical: 10),
              textStyle: const TextStyle(fontSize: 12),
            ),
            icon: const Icon(Icons.help_outline_rounded, size: 16),
            label: const Text('Ask Doubt'),
          ),
        ),
        const SizedBox(width: 8),
        Expanded(
          child: FilledButton.icon(
            onPressed: isCurrentUserLead ? widget.onSubmitProgress : null,
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 10),
              backgroundColor:
                  isCurrentUserLead ? Colors.greenAccent : Colors.green.shade200,
              foregroundColor: Colors.black,
              textStyle: const TextStyle(fontSize: 12),
            ),
            icon: const Icon(Icons.task_alt_rounded, size: 16),
            label: const Text('Submit Progress'),
          ),
        ),
      ],
    );
  }

  String _monthName(int month) {
    const names = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ];
    if (month < 1 || month > 12) return month.toString();
    return names[month - 1];
  }
}

================================================================================

// File: lib\task\widgets\task_side_panel.dart
import 'package:flutter/material.dart';

import '../../core/glass_container.dart';
import '../../core/wallpaper_service.dart';
import '../task_tabs_manifest.dart';

class TaskSidePanel extends StatelessWidget {
  final String selectedTabId;
  final ValueChanged<String> onSelect;

  const TaskSidePanel({
    super.key,
    required this.selectedTabId,
    required this.onSelect,
  });

  @override
  Widget build(BuildContext context) {
    final wallpaper = WallpaperService.instance;

    return AnimatedBuilder(
      animation: wallpaper,
      builder: (context, _) {
        final double glassBlur = wallpaper.globalGlassBlur;
        final double glassOpacity = wallpaper.globalGlassOpacity;

        return GlassContainer(
            blur: glassBlur,
            opacity: glassOpacity * 0.7,
            tint: Colors.white,
            borderRadius: BorderRadius.circular(20),
            padding: const EdgeInsets.symmetric(vertical: 10),
            // ADD THIS:
            blurMode: GlassBlurMode.perWidget,
          child: Column(
            children: [
              const SizedBox(height: 6),
              const Text(
                'TASK',
                style: TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.w700,
                  letterSpacing: 1.2,
                ),
              ),
              const SizedBox(height: 10),
              Expanded(
                child: ListView(
                  children: [
                    for (final t in taskTabs)
                      _item(
                        selected: selectedTabId == t.id,
                        icon: t.icon,
                        title: t.title,
                        onTap: () => onSelect(t.id),
                      ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _item({
    required bool selected,
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    final Color fg = selected ? Colors.cyanAccent : Colors.white70;

    return InkWell(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
        decoration: BoxDecoration(
          color: selected ? Colors.cyan.withOpacity(0.12) : Colors.transparent,
          borderRadius: BorderRadius.circular(14),
          border: Border.all(
            color:
                selected ? Colors.cyanAccent.withOpacity(0.5) : Colors.white12,
          ),
        ),
        child: Row(
          children: [
            Icon(icon, color: fg, size: 18),
            const SizedBox(width: 10),
            Text(
              title,
              style: TextStyle(
                color: fg,
                fontWeight: selected ? FontWeight.w600 : FontWeight.w400,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

================================================================================

// File: lib\workspace\loading_screen.dart
import 'dart:async';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../core/permissions_cache.dart';
import '../core/wallpaper_service.dart';
import '../dynamic_screen/dashboard_permissions.dart';

class LoadingScreen extends StatefulWidget {
  final VoidCallback onLoadingComplete;

  const LoadingScreen({
    super.key,
    required this.onLoadingComplete,
  });

  @override
  State<LoadingScreen> createState() => _LoadingScreenState();
}

class _LoadingScreenState extends State<LoadingScreen>
    with SingleTickerProviderStateMixin {
  late final AnimationController _pulseController;
  late final Animation<double> _pulse;

  final ValueNotifier<double> _progress = ValueNotifier<double>(0.0);
  final ValueNotifier<String> _status = ValueNotifier<String>('Initializingâ€¦');

  bool _completed = false;
  Object? _error;

  @override
  void initState() {
    super.initState();

    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1400),
    )..repeat(reverse: true);

    _pulse = Tween<double>(begin: 0.96, end: 1.04).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );

    // Start after first frame so context is stable.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      unawaited(_startLoadingSequence());
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _progress.dispose();
    _status.dispose();
    super.dispose();
  }

  Future<void> _startLoadingSequence() async {
    if (_completed) return;

    try {
      _error = null;

      await _step(0.10, 'Loading wallpaperâ€¦', () async {
        // Safe even if already loaded (WallpaperService guards internally)
        await WallpaperService.instance.loadSettings();
      });

      await _step(0.35, 'Checking authenticationâ€¦', () async {
        // Just touching currentUser is cheap; no extra delay needed
        FirebaseAuth.instance.currentUser;
      });

      await _step(0.65, 'Loading permissionsâ€¦', () async {
        final user = FirebaseAuth.instance.currentUser;
        if (user == null) return;

        // Use cache first
        final cached = PermissionsCache.instance.getCachedPermissions(user.uid);
        if (cached != null) return;

        final ids = await _loadPermissions(user.uid);
        PermissionsCache.instance.setCachedPermissions(user.uid, ids);
      });

      await _step(0.90, 'Finalizingâ€¦', () async {
        // Tiny yield to ensure UI paints last progress update
        await Future<void>.delayed(const Duration(milliseconds: 60));
      });

      _progress.value = 1.0;
      _status.value = 'Ready';

      await Future<void>.delayed(const Duration(milliseconds: 160));
      _complete();
    } catch (e) {
      _error = e;
      _status.value = 'Loading failed. Retry?';
      if (kDebugMode) {
        debugPrint('[LoadingScreen] error: $e');
      }
    }
  }

  Future<void> _step(
    double progress,
    String message,
    Future<void> Function() action,
  ) async {
    _progress.value = progress;
    _status.value = message;
    await action();
  }

  Future<Set<String>> _loadPermissions(String userId) async {
    final completer = Completer<Set<String>>();

    await DashboardPermissions.loadUserPermissions(
      context: context,
      userId: userId,
      onAllowedWidgetIds: (ids) {
        if (!completer.isCompleted) completer.complete(ids);
      },
    );

    // Safety: don't hang forever on network issues.
    return completer.future.timeout(
      const Duration(seconds: 10),
      onTimeout: () => <String>{'login'},
    );
  }

  void _complete() {
    if (_completed) return;
    _completed = true;
    widget.onLoadingComplete();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.transparent,
      body: Stack(
        children: [
          // Wallpaper background: repaints only this layer on wallpaper changes.
          Positioned.fill(
            child: AnimatedBuilder(
              animation: WallpaperService.instance,
              builder: (_, __) => DecoratedBox(
                decoration: WallpaperService.instance.backgroundDecoration,
              ),
            ),
          ),

          // Subtle dark overlay for legibility
          Positioned.fill(
            child: DecoratedBox(
              decoration: BoxDecoration(
                color: Colors.black.withOpacity(0.45),
              ),
            ),
          ),

          Center(
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 520),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 22),
                child: ScaleTransition(
                  scale: _pulse,
                  child: _Card(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const SizedBox(height: 6),
                        const Text(
                          'WALL-D',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 22,
                            fontWeight: FontWeight.w800,
                            letterSpacing: 1.4,
                          ),
                        ),
                        const SizedBox(height: 10),
                        const Text(
                          'Preparing your workspaceâ€¦',
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(color: Colors.white70, fontSize: 12),
                        ),
                        const SizedBox(height: 18),

                        ValueListenableBuilder<double>(
                          valueListenable: _progress,
                          builder: (_, p, __) {
                            return ClipRRect(
                              borderRadius: BorderRadius.circular(999),
                              child: LinearProgressIndicator(
                                value: p.clamp(0.0, 1.0),
                                minHeight: 8,
                                backgroundColor: Colors.white.withOpacity(0.10),
                                valueColor: const AlwaysStoppedAnimation<Color>(
                                  Colors.cyanAccent,
                                ),
                              ),
                            );
                          },
                        ),

                        const SizedBox(height: 12),

                        ValueListenableBuilder<String>(
                          valueListenable: _status,
                          builder: (_, msg, __) {
                            return Text(
                              msg,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: const TextStyle(
                                color: Colors.white60,
                                fontSize: 12,
                              ),
                            );
                          },
                        ),

                        if (_error != null) ...[
                          const SizedBox(height: 14),
                          Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            children: [
                              TextButton(
                                onPressed: _complete,
                                child: const Text('Continue'),
                              ),
                              const SizedBox(width: 8),
                              FilledButton(
                                onPressed: () {
                                  _error = null;
                                  unawaited(_startLoadingSequence());
                                },
                                child: const Text('Retry'),
                              ),
                            ],
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _Card extends StatelessWidget {
  final Widget child;
  const _Card({required this.child});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(18, 16, 18, 14),
      decoration: BoxDecoration(
        color: const Color(0xCC0B0B12),
        borderRadius: BorderRadius.circular(18),
        border: Border.all(color: Colors.white.withOpacity(0.10)),
        boxShadow: const [
          BoxShadow(
            color: Color(0xAA000000),
            blurRadius: 24,
            offset: Offset(0, 14),
          ),
        ],
      ),
      child: child,
    );
  }
}

================================================================================

// File: lib\workspace\universal_top_bar.dart
import 'package:flutter/material.dart';

import '../core/glass_container.dart';
import '../workspace/workspace_switcher.dart';
import 'workspace_controller.dart';
import '../core/wallpaper_service.dart';

class UniversalTopBar extends StatelessWidget {
  final WorkspaceController workspaceController;
  final VoidCallback onWallpaperSettings;
  final VoidCallback onGlassSettings;
  final VoidCallback onSignOut;

  const UniversalTopBar({
    super.key,
    required this.workspaceController,
    required this.onWallpaperSettings,
    required this.onGlassSettings,
    required this.onSignOut,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: WallpaperService.instance,
      builder: (context, _) {
        final ws = WallpaperService.instance;
        final double glassBlur = ws.globalGlassBlur;
        final double glassOpacity = ws.globalGlassOpacity;

        return SafeArea(
          child: Padding(
            padding: const EdgeInsets.fromLTRB(18, 12, 18, 0),
            child: SizedBox(
              height: 40,
              child: GlassContainer(
                blur: glassBlur,  // NOW REACTIVE
                opacity: glassOpacity,  // NOW REACTIVE
                tint: Colors.white,
                borderRadius: BorderRadius.circular(20),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 0),
                blurMode: GlassBlurMode.perWidget,  // FORCE BLUR (top bar is tiny)
                child: Stack(
                  alignment: Alignment.center,
                  children: [
                    // LEFT: Branding
                    const Align(
                      alignment: Alignment.centerLeft,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.blur_on_rounded,
                            color: Colors.cyan,
                            size: 18,
                          ),
                          SizedBox(width: 8),
                          Text(
                            'Wall-D Workspace',
                            style: TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ],
                      ),
                    ),

                    // CENTER: Workspace Switcher
                    Align(
                      alignment: Alignment.center,
                      child: WorkspaceSwitcher(
                        controller: workspaceController,
                      ),
                    ),

                    // RIGHT: Settings & Actions
                    Align(
                      alignment: Alignment.centerRight,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          IconButton(
                            icon: const Icon(
                              Icons.wallpaper_rounded,
                              color: Colors.white70,
                              size: 18,
                            ),
                            tooltip: 'Wallpaper settings',
                            onPressed: onWallpaperSettings,
                          ),
                          IconButton(
                            icon: const Icon(
                              Icons.tune_rounded,
                              color: Colors.white70,
                              size: 18,
                            ),
                            tooltip: 'Glass settings',
                            onPressed: onGlassSettings,
                          ),
                          IconButton(
                            icon: const Icon(
                              Icons.logout_rounded,
                              color: Colors.redAccent,
                              size: 18,
                            ),
                            tooltip: 'Sign out',
                            onPressed: onSignOut,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

================================================================================

// File: lib\workspace\workspace_controller.dart
import 'package:flutter/foundation.dart';
import 'workspace_ids.dart';

class WorkspaceController extends ChangeNotifier {
  String _current = WorkspaceIds.dashboard;

  String get current => _current;

  // FIX: Added 'switchTo' to match the call in UniversalTopBar
  void switchTo(String id) {
    if (id == _current) return;
    _current = id;
    notifyListeners();
  }

  // Optional: Keep this if other files use it, or alias it
  void setWorkspace(String id) => switchTo(id);
}

================================================================================

// File: lib\workspace\workspace_ids.dart
class WorkspaceIds {
  static const dashboard = 'dashboard';
  static const task = 'task';
}

================================================================================

// File: lib\workspace\workspace_shell.dart
import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:walld_flutter/core/permissions_cache.dart';
import 'package:walld_flutter/workspace/universal_top_bar.dart';
import 'package:walld_flutter/workspace/workspace_controller.dart';
import 'package:walld_flutter/workspace/workspace_ids.dart';

import '../core/performance_state.dart';
import '../core/wallpaper_service.dart';
import '../dynamic_screen/dashboard_screen.dart';
import '../task/task_workspace.dart';

// Imports from the other 2 files
import 'widgets/fps_counter.dart';
import 'mixins/shell_performance_mixin.dart';

class WorkspaceShell extends StatefulWidget {
  final WorkspaceController workspaceController;

  const WorkspaceShell({
    super.key,
    required this.workspaceController,
  });

  @override
  State<WorkspaceShell> createState() => WorkspaceShellState();
}

// Mixin added here to separate performance logic
class WorkspaceShellState extends State<WorkspaceShell>
    with SingleTickerProviderStateMixin, ShellPerformanceMixin {
  
  // DEBUG INSTANCE TRACKING
  static int _instanceCounter = 0;
  final int _instanceNumber;
  final String _instanceId = DateTime.now().millisecondsSinceEpoch.toString();

  late final AnimationController animationController;
  late final Animation<Offset> _slideForward;
  late final Animation<Offset> _slideBackward;
  late final Animation<double> _fadeOut;
  late final Animation<double> _fadeIn;

  int _currentIndex = 0;
  int _previousIndex = 0;
  bool _isAnimating = false;
  bool _isForward = true;

  Duration _lastBuildDuration = Duration.zero;

  WorkspaceShellState() : _instanceNumber = ++_instanceCounter {
    debugPrint('ğŸ¢ WorkspaceShell INSTANCE #$_instanceNumber CREATED (ID: $_instanceId)');
  }

  @override
  void initState() {
    super.initState();
    debugPrint('ğŸ¢ WorkspaceShell #$_instanceNumber - initState()');

    _currentIndex = _getCurrentIndex();
    _previousIndex = _currentIndex;

    animationController = AnimationController(
      duration: const Duration(milliseconds: 360),
      vsync: this,
    );

    _setupCachedAnimations();

    animationController.addStatusListener((status) {
      if (status == AnimationStatus.forward) {
        setAnimating(true); // From Mixin
        if (mounted) setState(() => _isAnimating = true);
      } else if (status == AnimationStatus.completed) {
        setAnimating(false); // From Mixin
        if (mounted) {
          setState(() {
            _isAnimating = false;
            _previousIndex = _currentIndex;
          });
        }
      }
    });

    widget.workspaceController.addListener(_onWorkspaceChanged);
    
    // Initialize performance tracking from Mixin
    initPerformanceTracking();
  }

  void _setupCachedAnimations() {
    const curve = Curves.easeInOutCubicEmphasized;

    _slideForward = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(-1.0, 0.0),
    ).animate(CurvedAnimation(parent: animationController, curve: curve));

    _slideBackward = Tween<Offset>(
      begin: Offset.zero,
      end: const Offset(1.0, 0.0),
    ).animate(CurvedAnimation(parent: animationController, curve: curve));

    _fadeOut = Tween<double>(begin: 1.0, end: 0.0).animate(
      CurvedAnimation(
        parent: animationController,
        curve: const Interval(0.0, 0.60, curve: Curves.easeOut),
      ),
    );

    _fadeIn = Tween<double>(begin: 0.2, end: 1.0).animate(
      CurvedAnimation(
        parent: animationController,
        curve: const Interval(0.10, 0.85, curve: Curves.easeIn),
      ),
    );
  }

  int _getCurrentIndex() {
    return widget.workspaceController.current == WorkspaceIds.task ? 1 : 0;
  }

  void _onWorkspaceChanged() {
    final newIndex = _getCurrentIndex();
    if (newIndex == _currentIndex) return;
    if (_isAnimating) return;

    setState(() {
      _previousIndex = _currentIndex;
      _currentIndex = newIndex;
      _isForward = newIndex > _previousIndex;
    });

    animationController.forward(from: 0.0);
  }

  // NOTE: This logic stays here because it accesses AnimationController
  @override
  void onLowEndModeChanged(bool isLowEnd) {
    if (isLowEnd) {
      animationController.duration = const Duration(milliseconds: 300);
    }
  }

  Future<void> pickWallpaperFromWindows() async {
    await WallpaperService.instance.pickWallpaper();
  }

  Future<void> signOut() async {
  try {
    debugPrint('WorkspaceShell #$_instanceNumber - Starting logout process...');

    PermissionsCache.instance.clearCache();
    debugPrint('Permissions cache cleared');

    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
    debugPrint('SharedPreferences cleared');

    WallpaperService.instance.wallpaperPath = null;
    WallpaperService.instance.globalGlassOpacity = 0.12;
    WallpaperService.instance.globalGlassBlur = 16.0;
    debugPrint('WallpaperService reset');

    await FirebaseAuth.instance.signOut();
    debugPrint('Firebase Auth signed out');

    if (!mounted) return;

    

    // SnackBar...
  } catch (e) {
    debugPrint('Sign out error: $e');
  }
}


  Future<void> openGlobalGlassSheet() async {
  final service = WallpaperService.instance;
  double tempOpacity = service.globalGlassOpacity;
  double tempBlur = service.globalGlassBlur;

  final applied = await showModalBottomSheet<bool>(
    context: context,
    backgroundColor: const Color(0xFF05040A),
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
    ),
    builder: (context) {
      return StatefulBuilder(
        builder: (context, setModalState) {
          return SafeArea(
            top: false,
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text('Glass settings', style: TextStyle(color: Colors.white, fontSize: 16)),
                  const SizedBox(height: 20),
                  
                  // Opacity slider
                  Row(
                    children: [
                      const Text('Opacity', style: TextStyle(color: Colors.white70)),
                      Expanded(
                        child: Slider(
                          min: 0.04,
                          max: 0.30,
                          divisions: 26,
                          value: tempOpacity.clamp(0.04, 0.30),
                          onChanged: (v) {
                            setModalState(() => tempOpacity = v);
                            service.setGlassOpacity(v); // âœ… Auto-saves now!
                          },
                        ),
                      ),
                    ],
                  ),
                  
                  // Blur slider
                  Row(
                    children: [
                      const Text('Blur', style: TextStyle(color: Colors.white70)),
                      Expanded(
                        child: Slider(
                          min: 0,
                          max: 30,
                          divisions: 30,
                          value: tempBlur.clamp(0, 30),
                          onChanged: (v) {
                            setModalState(() => tempBlur = v);
                            service.setGlassBlur(v); // âœ… Auto-saves now!
                          },
                        ),
                      ),
                    ],
                  ),
                  
                  // Close button
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () => Navigator.pop(context, true),
                      child: const Text('Close'),
                    ),
                  ),
                ],
              ),
            ),
          );
        },
      );
    },
  );
  
  // âŒ REMOVED: No need to manually save anymore
  // if (applied == true) {
  //   service.setGlassOpacity(tempOpacity);
  //   service.setGlassBlur(tempBlur);
  //   await service.saveSettings();
  // }
}


  @override
  void dispose() {
    debugPrint('ğŸ¢ WorkspaceShell #$_instanceNumber DISPOSED');
    widget.workspaceController.removeListener(_onWorkspaceChanged);
    animationController.dispose();
    disposePerformanceTracking(); // From Mixin
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final buildStart = DateTime.now();

    final outgoingSlide = _isForward ? _slideForward : _slideBackward;
    final incomingSlide = _isForward
        ? Tween<Offset>(begin: const Offset(1.0, 0.0), end: Offset.zero).animate(
            CurvedAnimation(parent: animationController, curve: Curves.easeInOutCubicEmphasized))
        : Tween<Offset>(begin: const Offset(-1.0, 0.0), end: Offset.zero).animate(
            CurvedAnimation(parent: animationController, curve: Curves.easeInOutCubicEmphasized));

    final result = Scaffold(
      backgroundColor: Colors.transparent,
      body: Stack(
        children: [
          // 1) Wallpaper
          Positioned.fill(
            child: AnimatedBuilder(
              animation: WallpaperService.instance,
              builder: (_, __) => DecoratedBox(
                decoration: WallpaperService.instance.backgroundDecoration,
              ),
            ),
          ),

          // 2) Content
          RepaintBoundary(
            child: AnimatedBuilder(
              animation: animationController,
              builder: (context, child) {
                return Stack(
                  children: [
                    Positioned.fill(
                      child: Visibility(
                        visible: _currentIndex == 0 || _isAnimating,
                        child: SlideTransition(
                          position: _currentIndex == 0 ? incomingSlide : outgoingSlide,
                          child: FadeTransition(
                            opacity: _currentIndex == 0 ? _fadeIn : _fadeOut,
                            child: const RepaintBoundary(
                                child: DashboardScreen(key: PageStorageKey('dashboardscreen'))),
                          ),
                        ),
                      ),
                    ),
                    Positioned.fill(
                      child: Visibility(
                        visible: _currentIndex == 1 || _isAnimating,
                        child: SlideTransition(
                          position: _currentIndex == 1 ? incomingSlide : outgoingSlide,
                          child: FadeTransition(
                            opacity: _currentIndex == 1 ? _fadeIn : _fadeOut,
                            child: const RepaintBoundary(
                                child: TaskWorkspace(key: PageStorageKey('taskworkspace'))),
                          ),
                        ),
                      ),
                    ),
                  ],
                );
              },
            ),
          ),

          // 3) Top Bar
          RepaintBoundary(
            child: UniversalTopBar(
              workspaceController: widget.workspaceController,
              onWallpaperSettings: pickWallpaperFromWindows,
              onGlassSettings: openGlobalGlassSheet,
              onSignOut: signOut,
            ),
          ),

          // 4) FPS Counter (Using Mixin Data)
          if (showFPS)
            Positioned(
              top: 60, right: 16,
              child: ValueListenableBuilder<double>(
                valueListenable: fpsNotifier,
                builder: (context, fps, _) {
                  return ValueListenableBuilder<bool>(
                    valueListenable: isAnimatingNotifier,
                    builder: (context, isAnimating, _) {
                      return FPSCounter(
                        fps: fps,
                        isAnimating: isAnimating,
                        isLowEnd: isLowEndDevice,
                        vsyncLocked: vsyncLockDetected,
                        avgFrameTime: avgFrameTimeWindow,
                        warmupStable: PerformanceState.instance.isWarmupStable,
                        onToggle: toggleFPS,
                      );
                    },
                  );
                },
              ),
            ),
        ],
      ),
    );

    _lastBuildDuration = DateTime.now().difference(buildStart);
    if (kDebugMode && _lastBuildDuration.inMilliseconds > 24) {
      debugPrint('[BUILD] #$_instanceNumber dt=${_lastBuildDuration.inMilliseconds}ms');
    }

    return result;
  }
}

================================================================================

// File: lib\workspace\workspace_switcher.dart
import 'package:flutter/material.dart';
import '../core/glass_container.dart';
import 'workspace_controller.dart';
import 'workspace_ids.dart';

class WorkspaceSwitcher extends StatelessWidget {
  final WorkspaceController controller;

  const WorkspaceSwitcher({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: controller,
      builder: (_, __) {
        final current = controller.current;

        return GlassContainer(
          blur: 16,
          opacity: 0.10,
          tint: Colors.white,
          borderRadius: BorderRadius.circular(999),
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              _pillIcon(
                selected: current == WorkspaceIds.dashboard,
                icon: Icons.dashboard_customize_rounded,
                tooltip: 'Dashboard',
                onTap: () => controller.setWorkspace(WorkspaceIds.dashboard),
              ),
              const SizedBox(width: 6),
              _pillIcon(
                selected: current == WorkspaceIds.task,
                icon: Icons.task_alt_rounded,
                tooltip: 'Task',
                onTap: () => controller.setWorkspace(WorkspaceIds.task),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _pillIcon({
    required bool selected,
    required IconData icon,
    required String tooltip,
    required VoidCallback onTap,
  }) {
    final fg = selected ? Colors.cyanAccent : Colors.white70;
    final bg = selected ? Colors.cyan.withOpacity(0.16) : Colors.transparent;

    return Tooltip(
      message: tooltip,
      child: InkWell(
        borderRadius: BorderRadius.circular(999),
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
          decoration: BoxDecoration(
            color: bg,
            borderRadius: BorderRadius.circular(999),
            border: Border.all(
              color: selected ? Colors.cyanAccent.withOpacity(0.6) : Colors.white24,
              width: 1,
            ),
          ),
          child: Icon(icon, size: 18, color: fg),
        ),
      ),
    );
  }
}

================================================================================

// File: lib\workspace\mixins\shell_performance_mixin.dart
import 'dart:collection';
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/material.dart';

import '../../core/performance_state.dart';
import '../../core/wallpaper_service.dart';

mixin ShellPerformanceMixin<T extends StatefulWidget> on State<T> {
  
  // State variables for Performance
  final ValueNotifier<double> fpsNotifier = ValueNotifier<double>(60.0);
  final ValueNotifier<bool> isAnimatingNotifier = ValueNotifier<bool>(false);
  
  bool showFPS = true;
  bool isLowEndDevice = false;
  bool vsyncLockDetected = false;
  double avgFrameTimeWindow = 0.0;
  
  // Internal trackers
  final Queue<double> _frameMsWindow = Queue<double>();
  static const int _windowSize = 180;
  static const double _targetFrameTime = 16.67;
  static const double _jankThreshold = 33.33;
  static const double _severeJankThreshold = 50.0;
  
  int _frameCount = 0;
  int _consecutive30fpsLike = 0;
  int _stableChecks = 0;
  bool _warmupMarked = false;
  
  DateTime _lastPerfLog = DateTime.fromMillisecondsSinceEpoch(0);
  DateTime _lastJankLog = DateTime.fromMillisecondsSinceEpoch(0);
  DateTime _lastSevereJankLog = DateTime.fromMillisecondsSinceEpoch(0);

  // Method to be overridden by Shell to adjust animations
  void onLowEndModeChanged(bool isLowEnd) {}

  void initPerformanceTracking() {
    SchedulerBinding.instance.addTimingsCallback(_onFrameTimings);
  }

  void disposePerformanceTracking() {
    SchedulerBinding.instance.removeTimingsCallback(_onFrameTimings);
    fpsNotifier.dispose();
    isAnimatingNotifier.dispose();
  }

  void setAnimating(bool animating) {
    isAnimatingNotifier.value = animating;
  }
  
  void toggleFPS() {
    if (mounted) setState(() => showFPS = !showFPS);
  }

  void _onFrameTimings(List<FrameTiming> timings) {
    for (final t in timings) {
      final frameMs = t.totalSpan.inMicroseconds / 1000.0;

      _frameMsWindow.addLast(frameMs);
      while (_frameMsWindow.length > _windowSize) {
        _frameMsWindow.removeFirst();
      }

      final avgMs = _frameMsWindow.isEmpty
          ? _targetFrameTime
          : _frameMsWindow.reduce((a, b) => a + b) / _frameMsWindow.length;

      avgFrameTimeWindow = avgMs;

      final fps = (1000.0 / avgMs).clamp(1.0, 240.0);
      _frameCount++;

      PerformanceState.instance.currentFps = fps;

      if (_frameCount % 10 == 0) {
        fpsNotifier.value = fps;
      }

      if (!isLowEndDevice && fps < 50) {
        isLowEndDevice = true;
        onLowEndModeChanged(true);
        _applyPerformanceOptimizations(fps);
      }

      if (!kDebugMode) continue;

      if (frameMs >= _severeJankThreshold) {
        final now = DateTime.now();
        if (now.difference(_lastSevereJankLog).inMilliseconds >= 700) {
          _lastSevereJankLog = now;
          _logJank(severe: true, frameMs: frameMs, fps: fps);
        }
      } else if (frameMs >= _jankThreshold) {
        final now = DateTime.now();
        if (now.difference(_lastJankLog).inMilliseconds >= 900) {
          _lastJankLog = now;
          _logJank(severe: false, frameMs: frameMs, fps: fps);
        }
      }

      _detectVsyncLock(avgMs);
      _checkWarmupStability(avgMs, fps);

      final now = DateTime.now();
      if (now.difference(_lastPerfLog).inSeconds >= 10) {
        _lastPerfLog = now;
        debugPrint(
          '[PERF] fps=${fps.toStringAsFixed(1)} avg=${avgMs.toStringAsFixed(1)}ms '
          'stable=${PerformanceState.instance.isWarmupStable ? "Y" : "N"}',
        );
      }
    }
  }

  void _logJank({required bool severe, required double frameMs, required double fps}) {
    final tag = severe ? 'JANK:S' : 'JANK:M';
    final dropped = (frameMs / _targetFrameTime).floor();
    debugPrint('[$tag] dt=${frameMs.toStringAsFixed(1)}ms drop=$dropped fps=${fps.toStringAsFixed(1)}');
    
    if (severe) {
      developer.Timeline.instantSync('JANK_SEVERE', arguments: {'dtMs': frameMs, 'fps': fps});
    }
  }

  void _detectVsyncLock(double avgMs) {
    if (avgMs > 30.0 && avgMs < 36.5) {
      if (++_consecutive30fpsLike >= 12) vsyncLockDetected = true;
    } else if (avgMs < 22.0) {
      _consecutive30fpsLike = 0;
      vsyncLockDetected = false;
    }
  }

  void _checkWarmupStability(double avgMs, double fps) {
    if (_warmupMarked || _frameMsWindow.length < 120) return;
    
    final severeCount = _frameMsWindow.where((ms) => ms >= _severeJankThreshold).length;
    final stable = fps >= 45 && !isAnimatingNotifier.value && severeCount <= 6;

    if (stable) {
      if (++_stableChecks >= 6) {
        _warmupMarked = true;
        PerformanceState.instance.isWarmupStable = true;
        if (kDebugMode) debugPrint('[WARMUP] Stable! fps=${fps.toStringAsFixed(1)}');
      }
    } else {
      _stableChecks = 0;
    }
  }

  void _applyPerformanceOptimizations(double avgFps) {
    final ws = WallpaperService.instance;
    if (avgFps < 25) {
      ws.setGlassBlur(0.0);
      ws.setGlassOpacity(0.04);
      if (kDebugMode) debugPrint('[OPT] extreme blur=0 op=0.04');
    } else if (avgFps < 40) {
      ws.setGlassBlur(6.0);
      ws.setGlassOpacity(0.08);
      if (kDebugMode) debugPrint('[OPT] medium blur=6 op=0.08');
    } else if (avgFps < 50) {
      ws.setGlassBlur(8.0);
      ws.setGlassOpacity(0.10);
      if (kDebugMode) debugPrint('[OPT] light blur=8 op=0.10');
    }
  }
}

================================================================================

// File: lib\workspace\widgets\fps_counter.dart
import 'package:flutter/material.dart';

class FPSCounter extends StatelessWidget {
  final double fps;
  final bool isAnimating;
  final bool isLowEnd;
  final bool vsyncLocked;
  final double avgFrameTime;
  final bool warmupStable;
  final VoidCallback onToggle;

  const FPSCounter({
    super.key,
    required this.fps,
    required this.isAnimating,
    required this.isLowEnd,
    required this.vsyncLocked,
    required this.avgFrameTime,
    required this.warmupStable,
    required this.onToggle,
  });

  @override
  Widget build(BuildContext context) {
    Color fpsColor;
    String status;

    if (fps >= 58) {
      fpsColor = Colors.greenAccent;
      status = 'EXCELLENT';
    } else if (fps >= 50) {
      fpsColor = Colors.yellowAccent;
      status = 'GOOD';
    } else if (fps >= 40) {
      fpsColor = Colors.orangeAccent;
      status = 'FAIR';
    } else if (fps >= 28 && fps <= 32) {
      fpsColor = Colors.redAccent;
      status = 'VSYNC 30FPS';
    } else {
      fpsColor = Colors.red;
      status = 'LOW';
    }

    return GestureDetector(
      onTap: onToggle,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.85),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: fpsColor.withOpacity(0.6), width: 2),
          boxShadow: [
            BoxShadow(
              color: fpsColor.withOpacity(0.25),
              blurRadius: 14,
              spreadRadius: 2,
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.speed, color: fpsColor, size: 18),
                const SizedBox(width: 6),
                Text(
                  '${fps.toStringAsFixed(1)} FPS',
                  style: TextStyle(
                    color: fpsColor,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    fontFamily: 'monospace',
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Text(
              status,
              style: TextStyle(
                color: fpsColor.withOpacity(0.9),
                fontSize: 11,
                fontWeight: FontWeight.w700,
                letterSpacing: 0.5,
              ),
            ),
            if (avgFrameTime > 0) ...[
              const SizedBox(height: 4),
              Text(
                'Frame: ${avgFrameTime.toStringAsFixed(1)}ms',
                style: const TextStyle(
                  color: Colors.white70,
                  fontSize: 10,
                  fontFamily: 'monospace',
                ),
              ),
            ],
            if (warmupStable) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.greenAccent.withOpacity(0.18),
                  borderRadius: BorderRadius.circular(4),
                  border: Border.all(
                    color: Colors.greenAccent.withOpacity(0.45),
                    width: 1,
                  ),
                ),
                child: const Text(
                  'WARM-UP OK',
                  style: TextStyle(
                    color: Colors.greenAccent,
                    fontSize: 9,
                    fontWeight: FontWeight.w800,
                  ),
                ),
              ),
            ],
            if (vsyncLocked) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: Colors.redAccent.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(4),
                  border: Border.all(color: Colors.redAccent, width: 1),
                ),
                child: const Text(
                  'VSYNC LOCKED',
                  style: TextStyle(
                    color: Colors.redAccent,
                    fontSize: 9,
                    fontWeight: FontWeight.w900,
                  ),
                ),
              ),
            ],
            if (isLowEnd) ...[
              const SizedBox(height: 4),
              const Text(
                'OPTIMIZED',
                style: TextStyle(
                  color: Colors.orangeAccent,
                  fontSize: 9,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
            if (isAnimating) ...[
              const SizedBox(height: 4),
              const Text(
                'ANIMATING',
                style: TextStyle(
                  color: Colors.cyanAccent,
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

================================================================================

